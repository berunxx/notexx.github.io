<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notex`s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.notex.top/"/>
  <updated>2019-12-23T10:59:48.715Z</updated>
  <id>https://www.notex.top/</id>
  
  <author>
    <name>notex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java实现LRU算法</title>
    <link href="https://www.notex.top/2019/07/java-lru.html"/>
    <id>https://www.notex.top/2019/07/java-lru.html</id>
    <published>2019-07-18T04:22:19.000Z</published>
    <updated>2019-12-23T10:59:48.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>LRU 的全称是 Least Recently Used ，它是一种最少使用算法，当存储的空间已满时，将最久未使用到的数据淘汰。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>使用HashMap和双向链表实现。因为HashMap的get()方法时间复杂度为O(1)，双向链表使节点添加/删除操作O(1)。</p><ul><li>get(key) 获取缓存中的值</li><li>put(key, value) 添加值，当缓存容量满了时，则删除最久未访问的数据。</li></ul><p>建立一个Node类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    String value;</span><br><span class="line">    Node next;</span><br><span class="line">    Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Node类里面包含了key、value 和前置节点、后置节点。<br>LRUCache实现类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node head;</span><br><span class="line">    Map&lt;String, Node&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>; <span class="comment">// 容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除末尾节点</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="comment">// 移动 node 到头节点</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 已经存在该 key 将key 移动到头结点</span></span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            <span class="comment">// 移除末尾节点</span></span><br><span class="line">            removeNode(node);</span><br><span class="line">            <span class="comment">// 移动 node 到头节点</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 容量判断</span></span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 删除 尾节点</span></span><br><span class="line">                map.remove(tail.key);</span><br><span class="line">                removeNode(tail);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入节点 到 头节点</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            map.put(key, node);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n.prev.next = n.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            n.next.prev = n.prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = n.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node f = head;</span><br><span class="line">        head = n;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            f.prev = n;</span><br><span class="line">            head.next = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>建立一个测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置容量为10 的缓存</span></span><br><span class="line">        LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">            cache.put(<span class="string">""</span> + i, <span class="string">""</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        Node head = cache.head;</span><br><span class="line">        <span class="comment">// 输出缓存中的元素</span></span><br><span class="line">        <span class="comment">// output: 11 10 9 8 7 6 5 4 3 2  </span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(cache.get(<span class="string">"0"</span>)); <span class="comment">// "0"没有在缓存中 output: ""</span></span><br><span class="line">        System.out.println(cache.get(<span class="string">"3"</span>)); <span class="comment">// output: "3"</span></span><br><span class="line">        System.out.println(cache.get(<span class="string">"4"</span>)); <span class="comment">// output: "4"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为上面 获取了 '3'、'4'这两个元素，所以缓存中的元素顺序发生了变化</span></span><br><span class="line">        Node head2 = cache.head;</span><br><span class="line">        <span class="comment">// output: 4 3 11 10 9 8 7 6 5 2</span></span><br><span class="line">        <span class="keyword">while</span> (head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head2.value + <span class="string">" "</span>);</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的测试 LRU 缓存是将最新使用的元素更新到链表的前面，当超出容量时，则移除链表末尾的元素。<br><img src="https://ws1.sinaimg.cn/large/64202e18ly1g53xf21frlj20fw06wjri.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;LRU 的全称是 Least Recently Used ，它是一种最少使用算法，当存储的空间已满时，将最久未使用到的数据淘汰。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="算法" scheme="https://www.notex.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java关键字：instanceof、transient、 final</title>
    <link href="https://www.notex.top/2019/04/java-keywords.html"/>
    <id>https://www.notex.top/2019/04/java-keywords.html</id>
    <published>2019-04-25T05:44:31.000Z</published>
    <updated>2019-12-23T10:59:48.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>instanceof</code> 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。<br><code>instanceof</code> 是 Java 的保留关键字。用于测试对象是否是指定类型（类或子类或接口）的实例，返回Boolean类型。<br>eg:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(arrayList <span class="keyword">instanceof</span> List); <span class="comment">// output: true</span></span><br><span class="line">        System.out.println(arrayList <span class="keyword">instanceof</span> ArrayList); <span class="comment">//output:  true</span></span><br><span class="line">        System.out.println(arrayList <span class="keyword">instanceof</span> LinkedList); <span class="comment">//output:  false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><p>Java中的transient关键字用于指示字段不应该是序列化（这意味着保存，比如文件）过程的一部分。<br><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3</a></p><blockquote><p>变量可以标记为瞬态，以指示它们不是对象的持久状态的一部分。<br>比如下面的列子，不需要将密码保存起来。<br>eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"luffy"</span>);</span><br><span class="line">        <span class="comment">// password 字段为 transient</span></span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        writeFile(user);</span><br><span class="line">        readFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(User user)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/luffy/work/temp/user.txt"</span>);</span><br><span class="line">        FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/luffy/work/temp/user.txt"</span>);</span><br><span class="line">        FileInputStream os = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(os);</span><br><span class="line">        User user = (User) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + user.getName()); <span class="comment">// output name:wayne</span></span><br><span class="line">        System.out.println(<span class="string">"password:"</span> + user.getPassword()); <span class="comment">// output password:null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8855687778988171741L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line">    <span class="comment">// getter setter 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final是一个非访问修饰符，仅适用于变量，方法或类。</p><blockquote><p>final Variable: 创建常量变量<br>final Method: 禁止方法被覆盖<br>final Class: 禁止类被继承</p></blockquote><p>如果一个变量是用final关键字声明的，那么它的值不能被修改，本质上是一个常量。这也意味着必须初始化最终变量。</p><ol><li>可以在声明它时初始化最终变量。这种方法是最常见的。如果在声明时未初始化，则最终变量称为空白最终变量。</li><li>空白的最终变量可以在实例初始化块或内部构造函数中初始化。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。</li><li>可以在静态块内初始化空白的最终静态变量。</li></ol><p>让我们通过一个例子看到上面初始化最终变量的不同方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个final变量, 直接初始化</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> A = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个空白变量, 后面通过初始化实例块 初始化变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> B;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        B = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个空白的 final 变量,通过构造方法初始化</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        C = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个静态类型的 final 变量, 直接初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> D = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个空白的 静态类型final 变量,通过静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        E = <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;instanceof&quot;&gt;&lt;a href=&quot;#instanceof&quot; class=&quot;headerlink&quot; title=&quot;instanceof&quot;&gt;&lt;/a&gt;instanceof&lt;/h1&gt;&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 是 Java 的一个二元操作
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDK8源码学习：HashSet</title>
    <link href="https://www.notex.top/2019/04/jdk8-source-hashset.html"/>
    <id>https://www.notex.top/2019/04/jdk8-source-hashset.html</id>
    <published>2019-04-23T09:35:01.000Z</published>
    <updated>2019-12-23T10:59:48.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>HashSet实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序，HashSet允许元素为null。并且该类不是线程安全的。它能保证元素唯一性，一般可以用于去重。<br>如果要线程安全，可以通过以下方式实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="public-HashSet"><a href="#public-HashSet" class="headerlink" title="public HashSet()"></a>public HashSet()</h2><p>默认构造方法，是新建一个空的set,由HashMap支持，默认初始容量（16）和加载因子（0.75），对加载因子的解释在<a href="https://www.waynezw.cn/archives/2da9164.html" target="_blank" rel="noopener">HashMap源码</a>这篇文章中有解释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HashSet</code> 的构造方法都是调用 <code>HashMap</code> 的构造方法完成的。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add (E e)"></a>public boolean add (E e)</h2><p>添加元素，如果指定的元素尚不存在，则将其添加到此集合中，返回true，如果不存在，返回false。实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里直接调用了<code>Map#put</code> 方法，方法有一个 <code>PRESENT</code>,它是一个虚拟的<code>object</code>值，实际上我们在添加元素的时候往 map里面put值的时候是没有value的，但是map的put方法是需要接收一个value值，这里就用到了<code>PRESENT</code>，一个默认的虚拟值。<br>因为 <code>HashSet#add</code> 方法实际上调用了<code>Map#put</code>方法，将元素 <code>e</code>当做了map的key值，这样就保证了<code>HashSet</code>元素的唯一性。该方法的具体实现可以看这篇文章<a href="https://www.waynezw.cn/archives/2da9164.html" target="_blank" rel="noopener">HashMap源码</a>。<br>我们通过下面的列子来印证。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">boolean</span> bool = set.add(<span class="string">"hash set"</span>);</span><br><span class="line">System.out.println(bool + <span class="string">""</span>); <span class="comment">//  output: true</span></span><br><span class="line"><span class="keyword">boolean</span> bool2 = set.add(<span class="string">"hash set"</span>);</span><br><span class="line">System.out.println(bool2 + <span class="string">""</span>); <span class="comment">// output: false</span></span><br><span class="line">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">// 3</span></span><br><span class="line">    System.out.println(iterator.next()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的代码我们可以清楚的看见 步骤<code>3</code> 只输出了一次 <code>hash set</code>，证实了HashSet元素的唯一性。</p><h2 id="public-boolean-contains-Object-o"><a href="#public-boolean-contains-Object-o" class="headerlink" title="public boolean contains (Object o)"></a>public boolean contains (Object o)</h2><p>如果此set包含指定的元素，则返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>contains</code>调用<code>HashMap#containsKey</code>方法，其实就是调用了<code>HashMap#getNode</code>， 该方法的具体实现可以看这篇文章<a href="https://www.waynezw.cn/archives/2da9164.html" target="_blank" rel="noopener">HashMap源码</a>。</p><h2 id="boolean-remove-Object-o"><a href="#boolean-remove-Object-o" class="headerlink" title="boolean remove(Object o)"></a>boolean remove(Object o)</h2><p>删除元素，存在元素，并且删除成功，返回true，反之false；实现也是基于HashMap的方法。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>HashSet推荐遍历的方式；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    forHashSet(set);</span><br><span class="line">    whileHashSet(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">whileHashSet</span><span class="params">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forHashSet</span><span class="params">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator iterator = set.iterator();</span><br><span class="line">         iterator.hasNext(); ) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>whileHashSet</code>和<code>forHashSet</code>本质上都是调用了 <code>iterator</code>，只是分别使用 for循环或者while来实现而已。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>基于HashMap的支持</li><li>元素唯一性</li><li>不保证元素添加的顺序</li><li>线程不安全类</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;HashSet实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序，HashSet允许元素为null。并且该
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="源码" scheme="https://www.notex.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK8源码学习： Integer 的自动装箱拆箱和缓存机制</title>
    <link href="https://www.notex.top/2019/04/jdk8-source-Integer.html"/>
    <id>https://www.notex.top/2019/04/jdk8-source-Integer.html</id>
    <published>2019-04-21T13:10:07.000Z</published>
    <updated>2019-12-23T10:59:48.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>Integer</code> 是 <code>int</code> 的包装类，<code>Integer</code> 中还有一个匿名内部类 <code>IntegerCache</code> 它是一个对 <code>Integer</code> 的对象缓存，但是它有一个范围，默认是 <code>-128——127</code>。首先来看看 <code>IntegerCache</code> 的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="comment">// 默认为127</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            <span class="comment">//获取JVM设置的参数值（+XX:AutoBoxCacheMax=？）</span></span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    <span class="comment">// 防止设置的参数大于了 Integer的最大值。</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                <span class="comment">// 将-128 到 h的值放进数组里面</span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>IntegerCache的功能就是将-128到127的整数缓存起来。并且可以通过jvm参数设置 IntegerCache的最大值，增加了灵活性。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>下面是一些Integer的基本参数介绍。</p><h2 id="MAX-VALUE-最大值"><a href="#MAX-VALUE-最大值" class="headerlink" title="MAX_VALUE 最大值"></a>MAX_VALUE 最大值</h2><p><code>MAX_VALUE</code>顾名思义，就是Integer的最大值，它是不可变的。它的值为 2^31-1 = 2147483647<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MAX_VALUE = <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure></p><h2 id="MIN-VALUE-最小值"><a href="#MIN-VALUE-最小值" class="headerlink" title="MIN_VALUE 最小值"></a>MIN_VALUE 最小值</h2><p><code>MIN_VALUE</code>对应Integer的最小值，也是不可变的。值为： -2^31 = -2147483648<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MIN_VALUE = <span class="number">0x80000000</span>;</span><br></pre></td></tr></table></figure></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>介绍一下常用方法。</p><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h2><p><code>Integer#toString</code> 其实就是将Integer类型变成了String类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">        <span class="comment">// 如果为最小值 直接返回最小值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="valueOf-int-方法"><a href="#valueOf-int-方法" class="headerlink" title="valueOf(int) 方法"></a>valueOf(int) 方法</h2><p>我们先看看下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10是 <code>int</code> 类型，为什么可以直接赋值给 <code>Integer</code> 类型呢？我们分别张歘<code>javac Demo.class</code> 和 <code>javap -c Demo.class</code>命令看看程序是怎么编译的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">     2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">     <span class="number">5</span>: astore_1</span><br><span class="line">     6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     <span class="number">9</span>: aload_1</span><br><span class="line">    10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">    <span class="number">13</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p><!-- ![bc7fca64c9f9284e995e4f618989bb02.png](evernotecid://99E24FA2-4BAA-475C-B10C-A7D31B5CD72F/appyinxiangcom/16310471/ENResource/p851) --><p>上面是部分编译结果，可以看见<code>2: invokestatic  #2</code> 自动调用了<code>Integer#valueOf</code> 方法，这里就是程序自动将 <code>int</code> 变成了 <code>Integer</code> 类型。<br>现在我们来看<code>Integer#valueOf</code>的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在文章开头已经说了一下 <code>IntegerCache</code> 类，我们可以看见 <code>valueOf</code> 的方法，首先判断i的值是否在 <code>IntegerCache</code> 的范围之内，如果在，直接从cache里面获取即可，不在范围之内，则new 一个Integer 返回。</p><h2 id="intValue-方法"><a href="#intValue-方法" class="headerlink" title="intValue() 方法"></a>intValue() 方法</h2><p>下面这段代码将 一个Integer类型的赋值给了int类型。为什么Integer可以赋值给int，这里就涉及到了Integer的自动拆箱。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = i;</span><br></pre></td></tr></table></figure></p><p>在执行 <code>int i2 = i;</code>的时候，i会先执行<code>Integer#intValue</code>再赋值给i2。下面是 <code>Integer#intValue</code>的实现代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就一行代码，直接返回了Integer的value。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>Integer的缓存机制，是面试中或者笔试中比较常见的，需要注意下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Integer&lt;/code&gt; 是 &lt;code&gt;int&lt;/code&gt; 的包装类，&lt;code&gt;Integer&lt;/code&gt; 中还有一
      
    
    </summary>
    
      <category term="java相关" scheme="https://www.notex.top/categories/java%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="源码" scheme="https://www.notex.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java8源码学习-String</title>
    <link href="https://www.notex.top/2019/04/jdk8-source-String.html"/>
    <id>https://www.notex.top/2019/04/jdk8-source-String.html</id>
    <published>2019-04-18T13:22:08.000Z</published>
    <updated>2019-12-23T10:59:48.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>String是开发中比较常用的类了。String表示字符串，比如”abc”等。String实现了序列化（Serializable）、排序（Comparable）、字符串(CharSequence)等方法。 String是不可变的，String在定义的时候使用了final，也就是说一旦创建，就不可更改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>它使用字符存储，私有变量，并且为不可变的char类型，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>缓存String的hash code值，默认为0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure></p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>下面介绍几个常用的构造方法</p><h2 id="空初始化"><a href="#空初始化" class="headerlink" title="空初始化"></a>空初始化</h2><p>创建一个<code>&quot;&quot;</code>字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="String类型初始化"><a href="#String类型初始化" class="headerlink" title="String类型初始化"></a>String类型初始化</h2><p>在使用使用<code>new</code>关键字的时候，我们一般会使用 <code>new String(&quot;str&quot;)</code>来新建一个String。调用构造方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符型（char）类型初始化"><a href="#字符型（char）类型初始化" class="headerlink" title="字符型（char）类型初始化"></a>字符型（char）类型初始化</h2><p>通过<code>Arrays.copyOf</code>方法（底层实现调用了 <code>System.arraycopy()</code>）得到一个char[]赋值给value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String(char value[]) &#123;</span><br><span class="line">    this.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用String的使用中，<code>public String(char value[], int offset, int count)</code>方法在内部调用会常用到，比如：<code>subString</code>方法等。下面注意分析一下该方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// offset：可以理解为偏移量，从什么位置开始。</span></span><br><span class="line"><span class="comment">// count：字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面就是常规判断参数合法性</span></span><br><span class="line">        <span class="comment">// 到这里，说明count=0； 返回一个空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 Arrays.copyOfRange方法 下面会说明</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyOfRange方法底层是调用了 `native`方法， `native`是一个原生函数，是由c++实现的。具体实现就不说了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] copyOfRange(<span class="keyword">char</span>[] original, <span class="keyword">int</span> from, <span class="keyword">int</span> to) &#123;</span><br><span class="line">    <span class="comment">// 新字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> newLength = to - from;</span><br><span class="line">    <span class="keyword">if</span> (newLength &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(from + <span class="string">" &gt; "</span> + to);</span><br><span class="line">    <span class="comment">// 新建一个char数组</span></span><br><span class="line">    <span class="keyword">char</span>[] copy = <span class="keyword">new</span> <span class="keyword">char</span>[newLength];</span><br><span class="line">    <span class="comment">// System.arraycopy 是一个native方法</span></span><br><span class="line">    <span class="comment">// original： 原来的字符串， from： 复制的开始位置 </span></span><br><span class="line">    <span class="comment">// copy：新的存储字符串数组， 0：表示从索引0位置开始， Math.min(original.length - from, newLength)： 复制的元素数量</span></span><br><span class="line">    System.arraycopy(original, from, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length - from, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的 int、byte类型初始化不常用，就不说了。</p><h2 id="StringBuffer、StringBuilder类型初始化"><a href="#StringBuffer、StringBuilder类型初始化" class="headerlink" title="StringBuffer、StringBuilder类型初始化"></a>StringBuffer、StringBuilder类型初始化</h2><p>一般不使用，需要注意一下，StringBuffer是线程安全的，如果在不考虑线程安全的情况下，拼接字符串不使用StringBuffer，原因是线程同步所带来的开销太大。不考虑线程安全，推荐使用StringBuilder。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h2><p>String的equals方法是重写了Object的equals方法。<br>相关注释，写在代码之中，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断地址相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// instanceof 关键字，用来判断传入参数类型</span></span><br><span class="line">    <span class="comment">// 判断如果不为String类型，直接返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断anObject的长度和自身的长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 接着一个一个字符比较</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结一下，上面的大概流程。</p><ul><li>判断比较参数的地址是否相等，如果相等，直接返回true。</li><li>判断anObject的长度和自身的长度是否相等，如果相等，循环遍历两个char[], 一个个比较char字符是否相等。<br>使用例子：<code>&quot;abc&quot;.equals(&quot;abc&quot;)</code></li></ul><h2 id="hashcode-方法"><a href="#hashcode-方法" class="headerlink" title="hashcode 方法"></a>hashcode 方法</h2><p>通过hashcode方法会返回一个int类型的数值。<br>实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="comment">// val[i] 是获取 ASCII 码 比如 a -&gt;97 , b -&gt;98</span></span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hashcode方法比较简单，首先获取value的长度，然后根据长度遍历，反复计算h的值。比如：<code>&quot;abc&quot;.hashCode()</code>的返回值为：96354，<br>h默认为0。字符对应的ASCII码，可以自行Google。<br>第一次遍历： h = 31 <em> 0 + 97 ，所以 h = 97<br>第二次遍历： h = 31 </em> 97 + 98, h = 3105<br>第三次遍历： h = 31 * 3105 + 99, h = 96,354<br>还是比较容易理解的。</p><h2 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf 方法"></a>indexOf 方法</h2><p><code>indexOf</code>可以接收<code>int</code>、<code>String</code>、<code>char</code>类型的参数, 该方法的作用是判断字符串是否包含传入参数。下面只介绍String的使用。<br><code>indexOf(Strinf str)</code> 方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">            str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主要实现逻辑在这里。</span></span><br><span class="line"><span class="comment">// source: 字符串本身 、 sourceOffset：字符串从什么位置比较,、 target: 待比较的字符串、 targetOffset: 待比较的字符串比较起始位置、 fromIndex： 从什么位置开始，默认为0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        <span class="comment">// 开始比较的位置大于等于了本身字符串的长度</span></span><br><span class="line">        <span class="comment">// 待比较值为空，直接返回本身字符串长度，反之返回-1</span></span><br><span class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 防止设置参数错误</span></span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于传递了一个空字符串， 直接返回 fromIndex</span></span><br><span class="line">        <span class="keyword">return</span> fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取第一个待比较值的value , 比如 ”abc“, first = 'a'</span></span><br><span class="line">    <span class="keyword">char</span> first = target[targetOffset];</span><br><span class="line">    <span class="comment">// 计算循环结束的位置 比如： "abc".indexOf("b") max为 0+(3-1) = 2;</span></span><br><span class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">/* Look for first character. */</span></span><br><span class="line">        <span class="comment">// 找出第一个值与本身值相等的位置 i</span></span><br><span class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">        <span class="comment">// 前面主要是找出了第一个相等字符的位置，接着需要匹配后面的字符</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="comment">// j: 待比较第二个后面字符的开始位置</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// end：待比较字符的最后一个位置+1</span></span><br><span class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 依次比较后面字符 是否相等</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line">            <span class="comment">// 如果j 不等于 end ，说明 target 的其中一个字符不在source中。</span></span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">/* Found whole string. */</span></span><br><span class="line">                <span class="comment">// 返回第一个字符相等的位置</span></span><br><span class="line">                <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>indexOf方法，相对而言长一点，但是整体来说，还是不难理解。相应的注释已经写得差不多了，这里大概总结一下。</p><ul><li>首先比较第一个字符，如果第一个字符都不等，直接返回-1，表示没有找到。</li><li>接着比较后面的字符，如果依次全等。返回第一个字符相等的位置。</li></ul><h2 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring 方法"></a>substring 方法</h2><p><code>substring</code>的功能是截取字符串，使用方式是指定一个起始位置<code>beginIndex</code>和结束位置<code>endIndex</code>(endIndex 可以不指定，默认为字符串最后一位)，代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 传入参数不合格，抛出字符串索引越界异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要截取的长度</span></span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于0，说明传入beginIndex大于了字符串本身的长度，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为String是不可变的，所以返回一个新的字符串, new String()的具体实现，在构造方法里面已经说过了。</span></span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h2><p><code>replace()</code>方法的功能是替换字符串，比如 <code>&quot;hello world !&quot;.replace(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world-!</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target：被替换的字符，replacement：替换的字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class="line">            <span class="keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>replaceFirst()</code>方法功能是替换第一个匹配的字符串，比如 <code>&quot;hello world !&quot;.replaceFrist(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world !</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>replaceAll()</code>方法功能是替换第一个匹配的字符串，比如 <code>&quot;hello world !&quot;.replaceAll(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world-!</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三个方法主要区别是 <code>replaceFirst()</code>调用了<code>Matcher#replaceFirst</code>， <code>replace()</code>和<code>replaceAll()</code>调用了<code>Matcher#replaceAll</code>方法。<br>Matcher的<code>replaceAll()</code>和<code>replaceFirst()</code>方法区别在对于<code>appendReplacement(sb, replacement);</code>的调用次数，<code>replaceFirst()</code>只调用一次，表示只替换第一个匹配的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String replacement)</span> </span>&#123;</span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">boolean</span> result = find();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 实现太复杂，不讨论了。</span></span><br><span class="line">            appendReplacement(sb, replacement);</span><br><span class="line">            result = find();</span><br><span class="line">        &#125; <span class="keyword">while</span> (result);</span><br><span class="line">        appendTail(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h2><p><code>join()</code>是1.8之后才有的新方法。功能是：将多个字符或者集合元素连接起来。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join(<span class="string">"-"</span>, <span class="string">"Java"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>);</span><br><span class="line"><span class="comment">// message returned is: "Java-is-cool"</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strings = List.of(<span class="string">"Java"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>);</span><br><span class="line">String message = String.join(<span class="string">" "</span>, strings);</span><br><span class="line"><span class="comment">//message returned is: "Java is cool"</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; strings =</span><br><span class="line"> <span class="keyword">new</span> LinkedHashSet&lt;&gt;(List.of(<span class="string">"Java"</span>, <span class="string">"is"</span>, <span class="string">"very"</span>, <span class="string">"cool"</span>));</span><br><span class="line">String message = String.join(<span class="string">"-"</span>, strings);</span><br><span class="line"><span class="comment">//message returned is: "Java-is-very-cool"</span></span><br></pre></td></tr></table></figure></p><p>上面的例子表明了<code>String#join</code>方法可以接收 可变数组格式的字符、List、Set格式参数。下面来看看join的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空验证</span></span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    <span class="comment">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class="line">    StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">    <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法我们会看见有一个新的class出现了，<code>StringJoiner</code>也是1.8之后的才有的。主要参数有：<code>delimiter</code>：分隔符，<code>value</code>：定义类型是<code>StringBuilder</code>，由此可以看出来具体拼接还是通过<code>StringBuilder</code>实现的，另外还有<code>prefix</code>、<code>suffix</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringJoiner <span class="title">add</span><span class="params">(CharSequence newElement)</span> </span>&#123;</span><br><span class="line">    prepareBuilder().append(newElement);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主要实现在prepareBuilder()这里</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">prepareBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 添加 连接字符</span></span><br><span class="line">        value.append(delimiter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新建一个StringBulider, 如果有前缀也加上。</span></span><br><span class="line">        value = <span class="keyword">new</span> StringBuilder().append(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>prepareBuilder()</code>执行完之后，才会去添加新的元素。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到了这里也差不多了， <code>String</code>中还有很多方法，就不去一一解析了，当然我们需要知道怎么使用，具体功能是什么，下面做个功能总结：</p><ul><li><code>trim</code> 去掉首尾的空格</li><li><code>toLowerCase</code> 将字符串大写字母转为小写</li><li><code>toUpperCase</code> 将字符串小写字母转为大写</li><li><code>split</code> 根据特定字符拆分成一个数组</li><li><code>toString</code> 这个方法使用频率很高，需要注意它和<code>String#valueOf</code>的区别。如果<code>null</code>调用了<code>toString</code>会抛出<code>NullException</code>，而<code>null</code>调用了<code>valueOf</code>,会返回<code>&quot;null&quot;</code>字符。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;String是开发中比较常用的类了。String表示字符串，比如”abc”等。String实现了序列化（Serializable）、排序（C
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="源码" scheme="https://www.notex.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK8源码学习：LinkedList</title>
    <link href="https://www.notex.top/2018/11/java-linkedlist.html"/>
    <id>https://www.notex.top/2018/11/java-linkedlist.html</id>
    <published>2018-11-14T02:29:02.000Z</published>
    <updated>2019-12-23T10:59:48.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>LinkedList是允许元素为null的<strong>双向链表</strong>，LinkedList是<strong>线程不安全</strong>的，底层是基于链表的实现。<br>因为底层是链表的原因，说明，插入、删除比较方便，只需要移动对应的指针即可。但是在处理随机访问的数据，就会要比ArrayList慢了。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>LinkedList的属性相对比较少，只有下面的三个属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合元素的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 链表的第一个指针元素</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 链表最后一个元素</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>LinkedList只有两个构造方法，一个时默认的构造方法，另一个是将集合初始化到LinkedList。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化一个空的LinkedList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化一个包含集合元素的LinkedList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();  <span class="comment">// 调用默认构造方法</span></span><br><span class="line">    addAll(c); <span class="comment">// 将元素全部添加到LinkedList</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在看 <code>addAll()</code>方法前，先看看Node节点结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">// 节点值</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看完了Node的结构，随便把<code>node(int)</code>方法给看了，该方法在文中会多次遇到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// size &gt;&gt; 1 等价于 size/2 。通过将LinkedList折半，增加查询效率。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first; <span class="comment">// 保存第一个节点，因为需要从第一个节点开始循环查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>node(int index)</code>的实现是一个一个循环遍历得到的值，虽然说用到了缩小范围的折半方式优化查询。但是还是不可避免的导致获取效率低下。</p><p>在初始化有集合元素的构造方法是会调用到 <code>addAll()</code> 方法，跟着 <code>addAll()</code> 方法一直看下去，核心实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验index是否在范围内 [0, size]</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length; <span class="comment">// 记录传递过来的集合元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ; <span class="comment">// pred: index前置节点, index的后置节点</span></span><br><span class="line">    <span class="comment">// 在链表尾部添加数据</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index); <span class="comment">// 获取index节点的值，赋值给succ</span></span><br><span class="line">        pred = succ.prev; <span class="comment">// succ的前置节点赋值给 pred</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">         <span class="comment">// 根据前置节点和当前元素之构建 node节点</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>) <span class="comment">// 没有前置节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断添加元素是否在队尾添加</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred; <span class="comment">// 设置队尾节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在链表中间添加的元素</span></span><br><span class="line">        pred.next = succ; <span class="comment">// 设置前置节点的下一个值</span></span><br><span class="line">        succ.prev = pred; <span class="comment">// 设置后置节点的前一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew; <span class="comment">// 重新设置LinkedList的元素数量</span></span><br><span class="line">    modCount++; <span class="comment">// 记录一次结构更改的次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>addAll()</code>方法的实现过程还是容易看懂的。首先检查插入的位置是否在范围之内，接着判断是在链表中间插入数据，还是在链表尾部插入数据，设置根据succ和pred。然后循环遍历添加节点到LinkedList中。整个过程大致就是这样</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p>接下来看看LinkedList中的常用方法</p><h2 id="add-添加"><a href="#add-添加" class="headerlink" title="add 添加"></a>add 添加</h2><p>LinkedList的添加方法，主要是 <code>add(E)</code>、 <code>add(int, E)</code>，首先来看看默认的<code>add(E)</code>方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码没有具体逻辑，具体实现在<code>linkLast(e)</code>中，接着进入该方法中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last; <span class="comment">// 将末尾节点设置给l节点</span></span><br><span class="line">    <span class="comment">// 根据末尾节点做前置节点，得到一个新的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode; <span class="comment">// 更新末尾节点为新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>linkLast</code>方法实现过程是，首先得到末尾节点<code>l</code>，根据<code>l</code>做前置节点得到一个新的节点，最后对末尾节点重新赋值。我们可以看出，整个<code>add</code>方法在不指定添加位置的情况下，默认将值添加到末尾的。<br>看了默认的add方法实现，接着看看在规定位置添加节点的实现<br><code>add(int, E)</code>方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验添加节点的位置是否在 [0, size] 之间</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 如果添加的位置刚好尾部节点，直接调用默认添加方法的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着进入<code>linkBefore</code>方法看看是怎么实现的。e: 待添加元素值，succ: 带添加位置的节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev; <span class="comment">// 保存待添加位置的前置节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ); <span class="comment">// 根据前置节点、当前值、后置节点 得到一个新的节点</span></span><br><span class="line">    succ.prev = newNode; <span class="comment">// 设置添加位置的前置节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode; <span class="comment">// 如果前置节点为空，直接设置 第一个节点 （first代表第一个节点）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode; <span class="comment">// 将前面保存的前置节点的下一节点设置为新的节点</span></span><br><span class="line">    size++; <span class="comment">// 将LinkedList的容量加一</span></span><br><span class="line">    modCount++; <span class="comment">// 记录一下更改的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个过程通过代码中的注释，大致都能看的明白。<br>在添加方法中还有<code>addLast</code>、<code>addFrist</code>方法。首先看看<code>addLast</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现过程和默认的add方法一样，唯一的区别就是默认<code>add</code>方法有返回值，<code>addLast</code>方法没有返回值。<br>接下来看看<code>addFrist(E)</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first; <span class="comment">// 保存原来的第一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f); <span class="comment">// 得到一个新的节点，新节点的下一个节点就是原来的第一个节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode; <span class="comment">// 说明之前为空的LinkedList，直接设置末尾节点为新节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode; <span class="comment">// 设置原来第一个节点的前置节点为新节点</span></span><br><span class="line">    size++; <span class="comment">// 容量+1</span></span><br><span class="line">    modCount++; <span class="comment">// 修改次数 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="remove-删除"><a href="#remove-删除" class="headerlink" title="remove 删除"></a>remove 删除</h2><p>删除有两个实现，其一是：<code>remove()</code>不需要传入指针的位置，默认删除第一个，其二是<code>remove(int)</code>方法，该方法是传入一个需要删除的位置，如果删除成功会返回被删除的值。<br><code>remove()</code>方法的实现过程和<code>remove(int)</code>差不多，也可以理解为<code>remove()</code>默认传递了指针为0。这里就不单独介绍了。接下来就看看<code>remove(int)</code> 是怎么实现的。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验index是否在[0, size]之间</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// node(index)：待删除节点</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心实现在unlink方法中，接下来看看 unlink的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// x 为待删除节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item; <span class="comment">// 保存一下值，删除完成之后，需要返回给调用者。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">// 保存x的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev; <span class="comment">// 保存x的前一个节点</span></span><br><span class="line">    <span class="comment">// 如果前置节点为空</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接设置LinkedList的frist节点为 x的下一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置x的前置节点的下一个节点为 x的后置节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>; <span class="comment">// 将x的前置节点设置为null，方便gc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev; <span class="comment">// 如果x的后置节点为空，LinkedList的末尾节点设置为x的前置节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev; <span class="comment">// 设置x的下一个节点的前置节点为 x的前置节点</span></span><br><span class="line">        x.next = <span class="keyword">null</span>; <span class="comment">// 将x的后置节点设置为null，方便gc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>; <span class="comment">// 将x值设置为null，方便gc</span></span><br><span class="line">    size--; <span class="comment">// 容量 -1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除方法的核心就是，将待删除节点的前置节点的下一个节点设置为待删除节点的下一个节点（读起来蛮拗口的，多读几遍就能理解了）。</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p><code>get(int)</code>方法，根据位置获取值。<br>先贴上代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验index是否在[0, size]之间</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面已经有对node(index)方法做过解释了，该方法就是得到节点，返回节点的值。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set(int, E)</code>方法是一个根据index替换其原来的值，最后返回原始值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验index是否在[0, size]之间</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 根据index获取需要设置的节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 保存旧值</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    <span class="comment">// 设置新值</span></span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p><code>poll()</code>方法是获取并删除第一个元素。其实就是删除第一个元素并返回删除元素的值和<code>remove()</code>方法相同。这里也不做过多解释了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h2><p><code>peek()</code> 获取第一个节点的值。和<code>poll()</code>唯一不同的是，<code>peek</code>不需要删除第一个节点。<br>实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedList的分析到这里就结束了。<br>LinkedList是一个双向列表，在删除，添加元素方面有着比ArrayList更好的体验。但是在查询的时候需要一个一个遍历得到结果，虽说在遍历的时候将LinkedList分为了前一半和后一半遍历，但是和ArrayList的底层动态数组相比，还是差的太多。所以在项目具体使用过程中，还是得按需使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;LinkedList是允许元素为null的&lt;strong&gt;双向链表&lt;/strong&gt;，LinkedList是&lt;strong&gt;线程不安全&lt;/s
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用fish终端命令，不支持 `$`符号</title>
    <link href="https://www.notex.top/2018/10/homebrew-fish-err.html"/>
    <id>https://www.notex.top/2018/10/homebrew-fish-err.html</id>
    <published>2018-10-26T23:37:13.000Z</published>
    <updated>2019-12-23T10:59:48.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在fish命令中使用以下命令<br>eg 1:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure></p><p>eg 2:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br></pre></td></tr></table></figure></p><p>报错提示：</p><blockquote><p>fish: $(…) is not supported. In fish, please use ‘(curl)’.<br>/usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p></blockquote><p>在Mac 的fish终端中使用了 “$”报错。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>去掉<code>$</code>即可工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在fish命令中使用以下命令&lt;br&gt;eg 1:&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="MacOS" scheme="https://www.notex.top/categories/MacOS/"/>
    
    
      <category term="mac" scheme="https://www.notex.top/tags/mac/"/>
    
      <category term="fish" scheme="https://www.notex.top/tags/fish/"/>
    
  </entry>
  
  <entry>
    <title>Mac对nginx 启动、关闭、重启</title>
    <link href="https://www.notex.top/2018/10/mac-install-nginx.html"/>
    <id>https://www.notex.top/2018/10/mac-install-nginx.html</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在终端中执行：<br><code>brew install nginx</code><br>安装完成之后，nginx配置文件路径在<code>/usr/local/etc/nginx</code>下</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看nginx版本<br><code>nginx -v</code><br><img src="/images/nginx-v.jpg" alt><br>启动nginx：<code>brew services start nginx</code><br><img src="/images/nginx-start.jpg" alt><br>关闭nginx：<code>brew services stop nginx</code><br><img src="/images/nginx-stop.jpg" alt></p><p>也可以使用如下快捷指令<br>重新启动nginx：<br><code>nginx -s reload</code><br>停止nginx：<br><code>nginx -s stop</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在终端中执行：&lt;br&gt;&lt;code&gt;brew install nginx&lt;/code&gt;&lt;br&gt;安装完成之后，nginx配置文件路径在&lt;code
      
    
    </summary>
    
      <category term="MacOS" scheme="https://www.notex.top/categories/MacOS/"/>
    
    
      <category term="mac" scheme="https://www.notex.top/tags/mac/"/>
    
      <category term="nginx" scheme="https://www.notex.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer——栈的压入、弹出序列（java版本）</title>
    <link href="https://www.notex.top/2018/10/codeinterview-stack-push-pop.html"/>
    <id>https://www.notex.top/2018/10/codeinterview-stack-push-pop.html</id>
    <published>2018-10-11T08:19:28.000Z</published>
    <updated>2019-12-23T10:59:48.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈的压入、弹出序列<br><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网——栈的压入、弹出序列</a></p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用一个栈来模拟压入、弹出操作。依次将第一个数组pushA压入栈，压入之后比对第二个数组popA，判断是否需要弹出。如果pushA已经全部入栈，但是stack却没有弹出完。说明不是一个弹出序列。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = pushA.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, popIndex = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        stack.push(pushA[i]); <span class="comment">// 依次入栈</span></span><br><span class="line">        <span class="comment">// 栈顶元素和popA[popIndex]比较，判断是否需要弹出。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popA[popIndex]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;栈的压入、弹出序列&lt;br&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;amp;tqId=11174&amp;amp;tPage=1&amp;
      
    
    </summary>
    
      <category term="算法" scheme="https://www.notex.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="-剑指offer" scheme="https://www.notex.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer——最小的K个数（java版本）</title>
    <link href="https://www.notex.top/2018/10/codeinterview-minimum-k-number.html"/>
    <id>https://www.notex.top/2018/10/codeinterview-minimum-k-number.html</id>
    <published>2018-10-11T08:16:58.000Z</published>
    <updated>2019-12-23T10:59:48.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最小的K个数<br><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网——最小的K个数</a></p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="全排序"><a href="#全排序" class="headerlink" title="全排序"></a>全排序</h3><blockquote><p>先排序，接着找出最小的K个数。时间复制度为O(n*n)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.length &lt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = input.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-<span class="number">1</span>; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (input[j] &gt; input[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = input[j];</span><br><span class="line">                input[j] = input[j+<span class="number">1</span>];</span><br><span class="line">                input[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        result.add(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种解法，是可以优化的，我只需K个数，说明我可以只对K个长度排序，不全排序。对于这种解法，可以叫做局部排序，时间复杂度O(n*k)。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>先用当前K个元素生存一个大顶堆，这个堆用于存储当前最小的k个元素。接着，从第k+1个元素开始扫描，和堆中最大的元素比较，如果被扫描的元素小于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最小的k个元素。<br>时间复制度：O(n*lg(k))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; k)</span><br><span class="line">            maxHeap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最小的K个数&lt;br&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;amp;tqId=11182&amp;amp;tPage=2&amp;amp
      
    
    </summary>
    
      <category term="算法" scheme="https://www.notex.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="-剑指offer" scheme="https://www.notex.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>jdk8源码学习：ConcurrentHashMap</title>
    <link href="https://www.notex.top/2018/10/jdk8-source-ConcurrentHashMap.html"/>
    <id>https://www.notex.top/2018/10/jdk8-source-ConcurrentHashMap.html</id>
    <published>2018-10-10T02:43:50.000Z</published>
    <updated>2020-03-12T06:06:38.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的安全，但是HashTable的同步机制颗粒度太粗（实现机制是将put、size等各种方法加上‘synchronized’，导致了所有并发操作需要竞争同一把锁），导致性能低下,现在已经很少被推荐使用。<br>在jdk8中，ConcurrentHashMap底层实现使用了数组+链表+红黑树的数据结构</p><h1 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h1><h2 id="LOAD-FACTOR-加载因子"><a href="#LOAD-FACTOR-加载因子" class="headerlink" title="LOAD_FACTOR 加载因子"></a>LOAD_FACTOR 加载因子</h2><p>LOAD_FACTOR的默认大小是<code>0.75f</code>。为何是<code>0.75</code>    而不是其他的值呢？<br>首先理解一下，什么是加载因子。</p><ul><li>加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然</li><li>冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。</li><li>结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。</li></ul><h2 id="DEFAULT-CAPACITY-默认容量"><a href="#DEFAULT-CAPACITY-默认容量" class="headerlink" title="DEFAULT_CAPACITY 默认容量"></a>DEFAULT_CAPACITY 默认容量</h2><p>DEFAULT_CAPACITY的默认值为16，可以通过构造方法定义该值，但是需要注意的是，DEFAULT_CAPACITY的值是2的幂次方。结合前面的加载因子，可以得出，ConcurrentHashMap的初始化容量为:<code>0.75*16=12</code>,当size大于12的时候，就会发生扩容。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认初始化表大小（16）创建一个空的map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的空map，初始化表大小容纳指定数量的元素，不需要动态调转大小。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造方法 就是设置 sizeCtl; 首先计算<code>initialCapacity + (initialCapacity &gt;&gt;&gt; 1</code> （可以简写为： <code>1.5*initialCapacity + 1</code>）, 再调用<code>tableSizeFor</code> 方法，该方法的作用是：对<code>1.5*initialCapacity + 1</code>向上取最近的2的n次方。比如：初始化大小为：10，计算结果为16。 初始化大小为：15，计算结果为32.</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是调用了 <code>putVal()</code>,接下来是实现具体实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// key 和 value 都不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">// 计算 hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"><span class="comment">// 如果数组为空，则初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 初始化数组方法 后面单独介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"><span class="comment">// 通过hash值找到数组对应的节点f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// f节点为空，调用casTabAt方法</span></span><br><span class="line"><span class="comment">//casTabAt 具体执行过程是，底层通过sun.misc.Unsafe 调用了compareAndSwapObject。该方法是无锁算法，将值插入数组中。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// MOVED : 转换节点的hash值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line"><span class="comment">// 帮助数据迁移。并发情况下。</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">// 头结点的 hash 值大于 0，说明是链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line"><span class="comment">// 根据hash判断是否有相等的key， 如果有匹配成功，通过onlyIfAbsent 判断是否需要覆盖该key对应的值。然后break。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line"><span class="comment">// 到了这儿，说明没有匹配的key，如果该节点的下一个节点为空，说明已经到了链表的末端，将值给放在该链表的最末端即可，然后break。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">// 判断是否为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 调用红黑树的put方法，根据onlyIfAbsent判断是否覆盖该值。</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果 binCount不等于0，则在进行链表操作。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// TREEIFY_THRESHOLD 默认为8</span></span><br><span class="line"><span class="comment">// 如果binCount的值大于等于8，则调用treeifyBin方法</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line"><span class="comment">// 后面单独介绍该方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法的主要流程就是这样，接下来看看，put流程中遗留的几个问题。</p><h2 id="初始化数组-initTable"><a href="#初始化数组-initTable" class="headerlink" title="初始化数组 initTable"></a>初始化数组 initTable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">* 使用sizeCtl中记录的大小初始化表。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">      <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化‘线程’竞争失败。等待。</span></span><br><span class="line">          <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">              Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"><span class="comment">// 利用CAS操作， 并设置sizeCtl的值。</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 三目运算，DEFAULT_CAPACITY默认为16</span></span><br><span class="line">                      <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                      Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                      table = tab = nt;</span><br><span class="line"><span class="comment">// 如果n的值为16，则sc计算结果为12</span></span><br><span class="line">                      sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 设置sizeCtl值</span></span><br><span class="line">                  sizeCtl = sc;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树 treeifyBin"></a>链表转红黑树 treeifyBin</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">     <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果数组的长度小于 MIN_TREEIFY_CAPACITY（64），对数组进行扩容</span></span><br><span class="line">         <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line"><span class="comment">// n值翻倍之后传入</span></span><br><span class="line">             tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (b) &#123; <span class="comment">// 加锁</span></span><br><span class="line">                 <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                     TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 遍历链表，建立红黑树。</span></span><br><span class="line">                     <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                         TreeNode&lt;K,V&gt; p =</span><br><span class="line">                             <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                               <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                         <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                             hd = p;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                             tl.next = p;</span><br><span class="line">                         tl = p;</span><br><span class="line">                     &#125;</span><br><span class="line"><span class="comment">// 将红黑树设置到数组的相应位置</span></span><br><span class="line">                     setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>链表转红黑树方法，在开始的时候回校验数组的长度，如果小于64，会进行扩容，反之，进行转红黑树过程。</p><h2 id="扩容-tryPresize"><a href="#扩容-tryPresize" class="headerlink" title="扩容 tryPresize"></a>扩容 tryPresize</h2><p>将ConcurrentHashMap的容量扩展为原来的两倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">// size 在传递过来的时候，已经翻倍了。 如果size大于等于 最大容量的二分之一，c的值就是默认最大容量</span></span><br><span class="line"><span class="comment">// 反之，调用tableSizeFor方法，该方法就是对(size*1.5+1),在向上取2的n次方。</span></span><br><span class="line"><span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sc;</span><br><span class="line"><span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">n = (sc &gt; c) ? sc : c;</span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">table = nt;</span><br><span class="line">sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">sizeCtl = sc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line"><span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] nt;</span><br><span class="line"><span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">transfer(tab, nt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line"> (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-Object-kye-取值"><a href="#get-Object-kye-取值" class="headerlink" title="get(Object kye) 取值"></a>get(Object kye) 取值</h2><p>接下来看看获取value的方法，get(key)规定了key不能为null，如果为null，则会抛出NPE。实现过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 类似与HashMap中的hash方法</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// table为当前对象中存储所有元素的数组，不能为空</span></span><br><span class="line">    <span class="comment">// tabAt是根据hash值，从table中找到hash为h的这个元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断元素的hash是否相等，接着判断key是否相等，如相等直接返回value</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历链表，直到找到对应的值为止。</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法比较简单，没有加锁，只需要根据key直接取值就可以。类似<code>containsKey(Object key)</code>方法，其实就是调用了<code>get</code>方法，在判断get的返回值是否为空而已。</p><h2 id="remove-Object-key-删除"><a href="#remove-Object-key-删除" class="headerlink" title="remove(Object key) 删除"></a>remove(Object key) 删除</h2><p>remove方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现在<code>replaceNode</code>方法中，接来下是该方法的具体实现。<code>replaceNode</code>是对<code>remove/replace</code>公共方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key的hashCode计算出hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 循环table</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果tab为空或者通过tabAt得到的node节点为空，直接跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果链表头节点的hash值为-1，说明table可能正在进行扩容，调用helpTransfer方法帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 对链表头节点加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表查找key值</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123; <span class="comment">// 判断节点e的key是否相等</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123; <span class="comment">// 如果给定的value为null，或者value与cv相等</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>) <span class="comment">// 如果给定你的value不为null，替换节点e的value</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) <span class="comment">// 如果链表的前一个节点不为null，将节点e的下一个节点指向前一个节点的下一个节点。相当于删除当前节点</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next); <span class="comment">// 前一个节点为null，说明是链表头节点，插入头节点，next指向原头节点的next</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) <span class="comment">// 没有找到匹配的key，返回</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果节点为树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="comment">// 调用findTreeNode方法根据key查找节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="comment">//调用树节点removeTreeNode方法删除节点，返回true说明节点太少，转化为链表结构</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在JDK8中使用了CAS方法保证操作的原子性</li><li>与JDK7不同的是，在JDK8中，当链表长度到达一定值时，会自动转为红黑树存储。</li><li>与JDK7不同的是，在JDK8中，ConcurrentHashMap不再使用segment结构，而是使用synchronized关键字对table中的链表头节点进行加锁，粒度更小，从而使同时操作的线程数量更多，效率更高。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java并发编程实战》</p><p><a href="https://juejin.im/post/5a7844556fb9a06351725263" target="_blank" rel="noopener">https://juejin.im/post/5a7844556fb9a06351725263</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="源码" scheme="https://www.notex.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK8源码学习:TreeMap</title>
    <link href="https://www.notex.top/2018/09/jdk8-source-treemap.html"/>
    <id>https://www.notex.top/2018/09/jdk8-source-treemap.html</id>
    <published>2018-09-06T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。<br>前面介绍了<a href="2da9164.html" title="HashMap">HashMap</a>，因为HashMap是一种无序的存储集合，当某些时候需要特定的存储顺序的时候，就只能另寻他法了，在jdk中为我们提供了LinkedHashmap和TreeMap以供我们使用，本文先介绍TreeMap。<br>TreeMap和HashMap一样都是继承至AbstractMap，并且实现了NavigableMap()，TreeMap是在NavigableMap基础上基于红黑树的实现，他是一种顺序的存储结构。<br>TreeMap数据结构为Entry，Entry简单实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K key;</span><br><span class="line">V value;</span><br><span class="line">Entry&lt;K,V&gt; left; <span class="comment">// 左节点</span></span><br><span class="line">Entry&lt;K,V&gt; right; <span class="comment">// 右节点</span></span><br><span class="line">Entry&lt;K,V&gt; parent; <span class="comment">// 父节点</span></span><br><span class="line"><span class="keyword">boolean</span> color = BLACK;</span><br><span class="line"><span class="comment">// ... 其他代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h1><ul><li>root<br>root的定义为：<code>private transient Entry&lt;K,V&gt; root</code>，可以理解为一个短暂的 Entry</li><li>size<br>size的定义为：<code>private transient int size = 0</code>， 记录树中的数量</li><li>modCount<br>modCount的定义为：<code>private transient int modCount = 0</code>，记录结构性发生变化的次数，比如删除节点。</li><li>comparator<br>comparator的定义为：<code>private final Comparator&lt;? super K&gt; comparator</code>,用于维护此树形图中的顺序，如果使用其键的自然顺序，则comparator为空。</li></ul><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="无参"><a href="#无参" class="headerlink" title="无参"></a>无参</h2><ul><li>public TreeMap()<br>代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>构造方法，没有指定comparator，所以使用它的自然顺序排序。</p><h2 id="有参"><a href="#有参" class="headerlink" title="有参"></a>有参</h2><ul><li><strong>public TreeMap(Comparator&lt;? super K&gt; comparator)</strong><br>代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>构造方法，使用给定的comparator规则排序</p><ul><li><strong>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</strong><br>代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">comparator = <span class="keyword">null</span>;</span><br><span class="line">putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>构造一个新的 tree map，其中包含给定map的相同的映射，根据key的自然顺序进行排序，插入的新map的所有key必须实现 Comparable接口</p><ul><li><strong>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</strong><br>实现代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将SoretdMap的排序方法赋给comparator</span></span><br><span class="line">comparator = m.comparator();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 构建 tree map</span></span><br><span class="line">buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>构造一个新的 tree map，其中包含给定map的相同的映射，并且使用给定的 sorted map 的排序方式进行排序</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="put-插入"><a href="#put-插入" class="headerlink" title="put() 插入"></a>put() 插入</h2><p>插入方法是我们开发常用的方法，接下来看看，TreeMap的put方法具体是怎么实现的，为了方便阅读部分注释直接写在了代码中，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">Entry&lt;K,V&gt; t = root;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 比较两个key值，使用此时正确的compare方法。</span></span><br><span class="line">compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"><span class="comment">// new 一个 entry节点</span></span><br><span class="line">root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">size = <span class="number">1</span>;</span><br><span class="line">modCount++; <span class="comment">// 增加结构变化的次数</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line"><span class="comment">// split comparator and comparable paths</span></span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 设置value到特定的位置</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">parent = t;</span><br><span class="line">cmp = cpr.compare(key, t.key); <span class="comment">// 比较 key 和 t.key</span></span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">t = t.left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">t = t.right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> t.setValue(value); <span class="comment">// cmp=0，设置value</span></span><br><span class="line">&#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="comment">// 不允许key为null</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line"><span class="comment">// 设置value到特定的位置</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">parent = t;</span><br><span class="line">cmp = k.compareTo(t.key);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">t = t.left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">t = t.right;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> t.setValue(value);</span><br><span class="line">&#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 走到了这里， 说明了，cmp != 0，没有找到对应的key值，新建一个entry e，并将e放在相应的parent左右节点下面</span></span><br><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">parent.left = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">parent.right = e;</span><br><span class="line">fixAfterInsertion(e);</span><br><span class="line">size++;</span><br><span class="line">modCount++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put方法还是比较容易能理解的，首先判断root是否为空，如果没空，直接new Entry即可。不为空，根据comparator的值，查找要设置value的位置。如果没有找到匹配的key，则新建一个Entry e，再根据cmp的值，将Entry e设置到对应的位置即可。</p><h2 id="get-获取值"><a href="#get-获取值" class="headerlink" title="get 获取值"></a>get 获取值</h2><p>根据key获取一个Entry，具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line"><span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// 如果默认comparator不为空，调用getEntryUsingComparator方法</span></span><br><span class="line"><span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="comment">// key不允许为null</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">// 走到了这里，说明comparator为空，使用默认排序方法。</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line"><span class="comment">// 将当前root赋值给p</span></span><br><span class="line">Entry&lt;K,V&gt; p = root;</span><br><span class="line"><span class="comment">// 循环遍历p</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 通过compareTo方法比较key与p的key</span></span><br><span class="line"><span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">p = p.left; <span class="comment">// 将p.left赋值给p</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">p = p.right; <span class="comment">// 将p.right赋值给p</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">// 说明key与p.key相等，返回当前p节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果p节点中，没有找到对应的key，返回null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取Entry的方法的过程大致为：根据comparator获取Entry，其实就是遍历root，查找比较key，有匹配的返回对应的entry即可。注意key值不允许为空，会抛出空指针异常。<br>在获取Entry的方法中，如果comparator不为空，则使用getEntryUsingComparator方法获取。实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">K k = (K) key;</span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">Entry&lt;K,V&gt; p = root;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 通过自定义的compare方法比较key与p的key</span></span><br><span class="line"><span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">p = p.left; <span class="comment">// 将p.left赋值给p</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">p = p.right; <span class="comment">// 将p.right赋值给p</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">// 说明key与p.key相等，返回当前p节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果p节点中，没有找到对应的key，返回null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现过程和上面差不多，只是比较key值的方法换了而已。</p><h2 id="firstKey"><a href="#firstKey" class="headerlink" title="firstKey"></a>firstKey</h2><p>获取第一个key<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">firstKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// getFirstEntry得到第一个Entry，调用key(),得到key值。</span></span><br><span class="line"><span class="keyword">return</span> key(getFirstEntry());</span><br><span class="line">&#125;</span><br><span class="line">该方法比较简单，就不细说了。</span><br></pre></td></tr></table></figure></p><h2 id="lastKey"><a href="#lastKey" class="headerlink" title="lastKey"></a>lastKey</h2><p>获取最后一个key<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lastKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// getLastEntry得到最后一个Entry，调用key(),得到key值。</span></span><br><span class="line"><span class="keyword">return</span> key(getLastEntry());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>lastKey的具体实现过程在getLastEntry中，实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Entry&lt;K,V&gt; p = root;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">p = p.right;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现方法和firstKey差不多。一直找到最右节点为止。</p><h2 id="remove-删除"><a href="#remove-删除" class="headerlink" title="remove 删除"></a>remove 删除</h2><p>具体代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据key删除entry节点，返回value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根据key得到对应entry节点</span></span><br><span class="line">Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">V oldValue = p.value;</span><br><span class="line"><span class="comment">// 删除entity，后面会介绍</span></span><br><span class="line">deleteEntry(p);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先根据key查找Entry，如果不为空，则调用deleteEntry方法删除。<br>deleteEntry方法是实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete node p, and then rebalance the tree.</span></span><br><span class="line"><span class="comment"> * 删除节点p，从新平衡树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 增加一次结构发生变化的次数</span></span><br><span class="line">modCount++;</span><br><span class="line"><span class="comment">// 此TreeMap节点数量减一</span></span><br><span class="line">size--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line"><span class="comment">// point to successor.</span></span><br><span class="line"><span class="comment">// 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span></span><br><span class="line"><span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// successor: 得到p后面的节点</span></span><br><span class="line">Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">p.key = s.key;</span><br><span class="line">p.value = s.value;</span><br><span class="line">p = s;</span><br><span class="line">&#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line"><span class="comment">// replacement为替代节点，如果p的左节点不为空，则为p的左节点，反之为p的右节点</span></span><br><span class="line">Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"><span class="comment">// 如果replacement不为空</span></span><br><span class="line"><span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Link replacement to parent</span></span><br><span class="line">replacement.parent = p.parent;</span><br><span class="line"><span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) </span><br><span class="line"><span class="comment">// 如p没有父节点，则根root直接变为替代节点</span></span><br><span class="line">root = replacement;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left) <span class="comment">//如果P为左节点，则用replacement来替代为左节点</span></span><br><span class="line">p.parent.left  = replacement;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p.parent.right = replacement; <span class="comment">//如果P为右节点，则用replacement来替代为右节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">p.left = p.right = p.parent = <span class="keyword">null</span>; <span class="comment">//去除p节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix replacement</span></span><br><span class="line"><span class="comment">// 根据节点的颜色，来删除。红色：直接删除，黑色：删除之后，需要平衡树，调整位置。</span></span><br><span class="line"><span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">fixAfterDeletion(replacement);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line"><span class="comment">// 说明是唯一的节点，当前root直接返回 null 即可</span></span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line"><span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">fixAfterDeletion(p);</span><br><span class="line"><span class="comment">// 删除p节点</span></span><br><span class="line"><span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">p.parent.left = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">p.parent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文是对TreeMap做了一个简单的介绍，没有对删除节点之后，红黑树怎么自动平衡做讲解，后面会专门写一篇文章对红黑树做一个学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。&lt;br&gt;前面介绍了&lt;a href=&quot;2da9164.html&quot; title=&quot;Ha
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="源码" scheme="https://www.notex.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK8源码学习:HashMap</title>
    <link href="https://www.notex.top/2018/09/jdk8-source-hashmap.html"/>
    <id>https://www.notex.top/2018/09/jdk8-source-hashmap.html</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2020-03-30T11:07:21.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量–&gt;构造方法–&gt;常用方法。<br>在JDK7中，HashMap的底层数据结构为：数组+链表的形式。<br>在JDK8中，HashMap的底层数据结构为：数组+链表+红黑树（TreeNode），增加红黑树的结构。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>loadFactor 加载因子<br>默认加载因子为<code>0.75f</code>,为何是<code>0.75</code> 而不是其他的值呢？<br>首先理解一下，什么是加载因子。<br>加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然<br>冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。<br>结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。<br>加载因子的值是可以大于1的。</li><li>threshold<br>threshold表示当HashMap的size大于threshold时会执行resize操作。</li><li>size<br>记录数组的长度</li><li>modCount<br>modCount是记录HashMap发送结构性变化的次数，比如扩容、rehash。</li></ul><p>另外大概了解一下HashMap的最大容量 <code>1&lt;&lt;30</code>也就是2的30次方，初始化容量为16。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ul><li><p>HashMap(int, float)<br>为了方便阅读，注释直接写在了代码里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">   initialCapacity);</span><br><span class="line"><span class="comment">// 初始化容量必须在 1&lt;&lt;30 以内</span></span><br><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">   loadFactor);</span><br><span class="line"><span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 调用了tableSizeFor方法，该方法是返回给定的`initialCapacity`值的向上取最近的2的幂。比如传递的值为12，返回16。</span></span><br><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap(int)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">该构造方法，只是指定了初始化容量，使用默认的加载因子，调用`HashMap(<span class="keyword">int</span>, <span class="keyword">float</span>)`方法。</span><br></pre></td></tr></table></figure></li></ul><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="put-插入"><a href="#put-插入" class="headerlink" title="put 插入"></a>put 插入</h2><p>put方法主要的实现过程如下，为了方便阅读，将注释写在了代码中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 如果table为空，调用resize()方法，初始化一个table。</span></span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// 该节点不存在，新建节点</span></span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果是p节点是红黑树节点，调用红黑树的put方法。</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 找到链表的最后一个节点，插入新的节点</span></span><br><span class="line">p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 如果binCount的大小大于等于TREEIFY_THRESHOLD-1（TREEIFY_THRESHOLD默认为8），调用treeifyBin方法，后面单独介绍该方法。</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表中存在该节点，跳出循环。</span></span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">p = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">V oldValue = e.value;</span><br><span class="line"><span class="comment">// 根据oblyIfAbsent是否更新值</span></span><br><span class="line"><span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">e.value = value;</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改 modCount</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="comment">// 如果table大小大于了阈值，则需要扩容。</span></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面已经介绍了put方法的主流程，接下来分析一下该方法中留下的几个问题。</p><ul><li>treeifyBin方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">// 判断是否需要扩容，MIN_TREEIFY_CAPACITY的值：64,也就是说在大小为16、 32 的时候，不要进行结构转换</span></span><br><span class="line">     <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">         resize();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 将节点转为树节点</span></span><br><span class="line">             TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">             <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                 hd = p; <span class="comment">// 将p树节点指向hd树节点</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 p.prev = tl; <span class="comment">// 当前p树节点指向 p树节点的前一树节点</span></span><br><span class="line">                 tl.next = p;</span><br><span class="line">             &#125;</span><br><span class="line">             tl = p;</span><br><span class="line">         &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">             hd.treeify(tab);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>treeifyBin方法主要是把容器里的元素变成树结构。当HashMap的内部元素数组中某个位置上存在多个hash值相同的键值对，这些Node已经形成了一个链表，当该链表的长度大于等于7的时候，会调用该方法来进行一个特殊处理。</p><h2 id="get-取值"><a href="#get-取值" class="headerlink" title="get 取值"></a>get 取值</h2><p>源码中get方法代码如下，为了方便阅读，在代码中会写上相应的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较简单，调用了getNode()方法，并传入<code>hash(key)</code>和<code>key</code>，所以说取值的过程在<code>getNode</code>中，下面看看该方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义一个新的table数组、首节点</span></span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="comment">// 判断table数组是否为空，并且根据hash值算出 tab[(n - 1) &amp; hash]是否为空，其中一个条件为空，说明key没有对应的value值。</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 判断首节点的hash和key是否都相等，如果都等，直接返回首节点</span></span><br><span class="line"><span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line"><span class="comment">// 走到这儿，说明是一个链表了或者红黑树了</span></span><br><span class="line"><span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 判断是否为红黑树</span></span><br><span class="line"><span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="comment">// 调用 红黑树的getTreeNode方法</span></span><br><span class="line"><span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"><span class="comment">// 遍历链表一直找到匹配的值为止</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getNode</code>方法的过程相对而言是比较简单的，上面注释基本上比较易懂的，在整个流程中，红黑树的取值方法，没有说到，接下来看看<code>getTreeNode</code>方法中主要流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getTreeNode</code>方法的实现过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// ph: p节点的hash值，pk:p节点的key值</span></span><br><span class="line"><span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line"><span class="comment">// pl: p节点的左节点， pr：p节点的右节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line"><span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line"><span class="comment">// p节点的hash值大于了 h（h是待get值的hash值），将左节点赋值给p节点</span></span><br><span class="line">p = pl;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line"><span class="comment">// p节点的hash值小于了 h（h是待get值的hash值），将右节点赋值给p节点</span></span><br><span class="line">p = pr;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line"><span class="comment">// 走到了这儿，说明p.hash==h,只需要匹配key是否相等就好了。</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// 左节点为空，将右节点赋值给p节点</span></span><br><span class="line">p = pr;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// 右节点为空，将左节点赋值给p节点</span></span><br><span class="line">p = pl;</span><br><span class="line"><span class="comment">// kc参数在首次使用比较键时缓存equivalentClassFor（key）。</span></span><br><span class="line"><span class="comment">// comparableClassFor方法：只有当传入对象的运行时类型符合“class C implements Cormparable &lt;C&gt;”，则返回k的Class，否则返回null。</span></span><br><span class="line"><span class="comment">// compareComparables方法: 如果pk匹配kc（k的筛选可比类），则返回k.compareTo（pk），否则返回0。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line"> (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p = pl;</span><br><span class="line">&#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在本文中，主要是对常用的方法get、put做了一个学习了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;HashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量–&amp;gt;构造方法
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="源码" scheme="https://www.notex.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java 短链接项目</title>
    <link href="https://www.notex.top/2018/07/shorturl-project-java.html"/>
    <id>https://www.notex.top/2018/07/shorturl-project-java.html</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>将很长的http请求的地址，转为短链接。如下所示：<br><img src="http://www.myluffy.com/wp-content/uploads/2018/07/112a80391435658790d15308b377aba3.png" alt><br>为什么要转短链，短链接可以转发给第三方的时候，能轻易识别，我在开发中有遇到过一次，别人分享给我的地址里面包含了一些特殊字符（$、&amp;）等，我在我的微信里面，直接点击地址，只识别到特殊字符的前半部分，没有整个链接识别完成。</p><h2 id="短链服务的作用："><a href="#短链服务的作用：" class="headerlink" title="短链服务的作用："></a>短链服务的作用：</h2><ul><li>将长链接变为短链接，当然是越短越好</li><li>用户点击短链接的时候，实现自动跳转到原来的长链接</li></ul><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><ul><li>在游览器地址栏输入短链接地址：如 <a href="http://domain/shUESS" target="_blank" rel="noopener">http://domain/shUESS</a></li><li>游览器会将domain解析为ip地址，得到IP地址之后，会向这个IP发送请求。</li><li>后台接收到shUESS字符之后，去对应的存储中查询出原网址。</li><li>通过重定向调转到原网址。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>demo使用springboot完成，相关依赖如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- MD5加密 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.5&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h2 id="长链接转短链接"><a href="#长链接转短链接" class="headerlink" title="长链接转短链接"></a>长链接转短链接</h2><p>将一长串的链接，转为4至6个字符，我是使用MySQL做存储，用来存储，转换之后的字符 short_key和原来的链接originalUrl；<br>表结构简单版本如下：</p><ul><li>id: 主键ID，自动递增</li><li>short_key: 转换之后的字符，正式环境数据量很大，可以建立索引</li><li>originalUrl: 原来的网址</li></ul><p>本文采用MD5加密算法<br>对传入网址进行MD5加密，并且将加密之后的字符串，分为4部分分别于0x3FFFFFFF 进行位与运算，生成4个字符串，4个字符串都可以使用。<br>加密核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] shortUrl(String url) &#123;</span><br><span class="line">        <span class="comment">// 可以自定义生成 MD5 加密字符传前的混合 KEY</span></span><br><span class="line">        String key = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 要使用生成 URL 的字符</span></span><br><span class="line">        String[] chars = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>,</span><br><span class="line">                <span class="string">"i"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>,</span><br><span class="line">                <span class="string">"u"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,</span><br><span class="line">                <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>,</span><br><span class="line">                <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>, <span class="string">"P"</span>, <span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>,</span><br><span class="line">                <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对传入网址进行 MD5 加密</span></span><br><span class="line">        String sMD5EncryptResult = DigestUtils.md5Hex(key + url);</span><br><span class="line">        String hex = sMD5EncryptResult;</span><br><span class="line">        String[] resUrl = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算</span></span><br><span class="line">            String sTempSubString = hex.substring(i * <span class="number">8</span>, i * <span class="number">8</span> + <span class="number">8</span>);</span><br><span class="line">            <span class="comment">// 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用</span></span><br><span class="line">            <span class="comment">// long ，则会越界</span></span><br><span class="line">            <span class="keyword">long</span> lHexLong = <span class="number">0x3FFFFFFF</span> &amp; Long.parseLong(sTempSubString, <span class="number">16</span>);</span><br><span class="line">            String outChars = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引</span></span><br><span class="line">                <span class="keyword">long</span> index = <span class="number">0x0000003D</span> &amp; lHexLong;</span><br><span class="line">                <span class="comment">// 把取得的字符相加</span></span><br><span class="line">                outChars += chars[(<span class="keyword">int</span>) index];</span><br><span class="line">                <span class="comment">// 每次循环按位右移 5 位</span></span><br><span class="line">                lHexLong = lHexLong &gt;&gt; <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把字符串存入对应索引的输出数组</span></span><br><span class="line">            resUrl[i] = outChars;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resUrl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="短链接转长链接"><a href="#短链接转长链接" class="headerlink" title="短链接转长链接"></a>短链接转长链接</h2><p>有了长链接转短链接之后，这一步就简单多了。<br>通过请求的地址，得到short_key,去查询出对应的原网址，再重定向到原网址即可。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/&#123;key&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(@PathVariable String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(key)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br><span class="line">ShortUrl byShortKey = repository.getByShortKey(key);</span><br><span class="line"><span class="keyword">if</span> (byShortKey == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:"</span> + byShortKey.getOriginalUrl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整项目已上传到<a href="https://github.com/waynecoder/springboot-example/tree/master/short-url" title="short_url" target="_blank" rel="noopener">github</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/yushouling/article/details/55096992" title="https://blog.csdn.net/yushouling/article/details/55096992" target="_blank" rel="noopener">https://blog.csdn.net/yushouling/article/details/55096992</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;将很长的http请求的地址，转为短链接。如下所示：&lt;br&gt;&lt;img src=&quot;http://www.myluffy.com/wp-conte
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
      <category term="springboot" scheme="https://www.notex.top/tags/springboot/"/>
    
      <category term="spring" scheme="https://www.notex.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>利用Python3 连接mysql 导出数据为excel格式</title>
    <link href="https://www.notex.top/2018/07/python3-link-mysql-export.html"/>
    <id>https://www.notex.top/2018/07/python3-link-mysql-export.html</id>
    <published>2018-07-08T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。<br>才开始觉得sql每次都是固定不变，总量也不多，就通过 MySQL workbench 一条一条查询导出为 <em>.csv文件，但是发现 </em>.csv文件直接打开会出现中文乱码，就需要转码，我就通过Notepad++ 打开csv文件，设置文件格式 utf-8 bom 编码。这一系列步骤下来。人都不好了。<br>后面自己受不了了，就想通过脚本来解决这个重复性工作。我是一个Java开发者，就准备用Java来实现这个工作，但是后面发现Java来解决这个问题，有点太麻烦了，需要连接MySQL，查询数据，通过poi遍历做成poi对应excel的hssfworkbook对象（或者xssfworkbook），然后通过io流输出成excel文件。想到这些，就直接放弃了用Java来实现这个工作了。<br>后面想到了Python，我对Python不熟。就在网上查找了一些资料，发现还是满简单的了。就这样决定用Python来实现了。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面是Python的具体实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="comment">#import MySQLdb</span></span><br><span class="line"><span class="keyword">import</span> pymysql <span class="keyword">as</span> MySQLdb</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conn_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    conn = MySQLdb.connect(host=<span class="string">'localhost'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'root'</span>, db=<span class="string">'test'</span>, charset=<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_data</span><span class="params">(cur, sql, args)</span>:</span></span><br><span class="line">    cur.execute(sql, args)</span><br><span class="line">    <span class="keyword">return</span> cur.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># out_path 保存的路径， sql： 需要执行的语句</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_mysql_to_excel</span><span class="params">(out_path, sql)</span>:</span></span><br><span class="line">    conn = get_conn_mysql()</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    count = cursor.execute(sql)</span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">        print(count)</span><br><span class="line">        cursor.scroll(<span class="number">0</span>, mode=<span class="string">'absolute'</span>)</span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        fields = cursor.description</span><br><span class="line">        workbook = xlwt.Workbook()</span><br><span class="line">        sheet = workbook.add_sheet(<span class="string">'building'</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> range(<span class="number">0</span>, len(fields)):</span><br><span class="line">            sheet.write(<span class="number">0</span>, field, fields[field][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        row = <span class="number">1</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, len(results)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">0</span>, len(fields)):</span><br><span class="line">                <span class="keyword">if</span> results[row<span class="number">-1</span>][col] != <span class="keyword">None</span>:</span><br><span class="line">                    sheet.write(row, col, <span class="string">u'%s'</span>%results[row<span class="number">-1</span>][col])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    val = <span class="string">''</span></span><br><span class="line">                    sheet.write(row, col, <span class="string">u'%s'</span>%val)</span><br><span class="line">        workbook.save(out_path)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># 执行的sql语句</span></span><br><span class="line">sql = <span class="string">'select * from sys_user'</span></span><br><span class="line">read_mysql_to_excel(<span class="string">'1.xls'</span>, sql)</span><br></pre></td></tr></table></figure><ul><li>就这样一个简单的 导出数据为excel格式的demo就完成了。</li><li>如果有多个sql语句，只需要 hard code，在分别调用那个 <code>read_mysql_to_excel</code> 方法就好了。</li></ul><p>参考资料：<a href="https://blog.csdn.net/tingzuhuitou/article/details/78749185" title="https://blog.csdn.net/tingzuhuitou/article/details/78749185" target="_blank" rel="noopener">https://blog.csdn.net/tingzuhuitou/article/details/78749185</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。&lt;b
      
    
    </summary>
    
      <category term="python" scheme="https://www.notex.top/categories/python/"/>
    
    
      <category term="mysql" scheme="https://www.notex.top/tags/mysql/"/>
    
      <category term="python" scheme="https://www.notex.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>java 字符串位数不足自动补全</title>
    <link href="https://www.notex.top/2018/04/java-string-autocompile.html"/>
    <id>https://www.notex.top/2018/04/java-string-autocompile.html</id>
    <published>2018-04-26T16:00:00.000Z</published>
    <updated>2020-03-30T11:07:26.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-字符串位数不足自动补全"><a href="#java-字符串位数不足自动补全" class="headerlink" title="java 字符串位数不足自动补全"></a>java 字符串位数不足自动补全</h2><ul><li>使用<code>org.apache.commons.lang</code>包下的<code>StringUtils</code>的leftPad函数，可以直接得到想要的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//第一个参数：补位之前的值，第二个参数：总共的位数，第三个参数：补位用什么字符来填充。</span></span><br><span class="line"><span class="keyword">final</span> String s = org.apache.commons.lang.StringUtils.leftPad(<span class="string">"10110"</span>, <span class="number">8</span>, <span class="string">"0"</span>);</span><br><span class="line">System.out.println(s); <span class="comment">// output: 00010110</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-字符串位数不足自动补全&quot;&gt;&lt;a href=&quot;#java-字符串位数不足自动补全&quot; class=&quot;headerlink&quot; title=&quot;java 字符串位数不足自动补全&quot;&gt;&lt;/a&gt;java 字符串位数不足自动补全&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java源码学习：Object</title>
    <link href="https://www.notex.top/2018/04/java-object-source.html"/>
    <id>https://www.notex.top/2018/04/java-object-source.html</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Object类是所有类根，即所有的类都隐式继承了Object.</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode方法返回对象的散列码，相等对象必须返回相等的hashCode，不同对象的hashCode尽可能不相等；Obejct中定义的hashCode方法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure></p><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>Object中定义的equals()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>equals()方法，顾名思义就是判断是否相等，可以看见Object中equals()方法是用 ‘==’来判断地址;由此可见，我们常用String类的肯定是重写了该方法的，查看String的源码；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们重写equals时总要重写hashCode：</p><ul><li>重写equals不重写hashCode，会导致“不相等对象拥有相同的hashCode”，导致集合类HashMap，HashSet和Hashtable无法工作；极端情况下，在散列表中使所有对象的hashCode都相等，所有对象都被映射到同一个桶中，散列表退化成链表；</li><li>当两个对象调用equal返回true，则两个对象各自调用hashCode()返回相同hashCode；</li><li>当两个对象调用equal返回false， 两个对象各自调用hashCode()返回的hashCode可以相同（散列冲突不能完全避免）</li></ul><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>Object类中toString方法，输出对象的“对象类名@散列码”；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h2><p>Obejct类中finalize()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>finalize()会在对象被垃圾回收时由垃圾回收器调用，垃圾对象是指没有引用指向的对象</p><ul><li>JVM的垃圾回收是”最少回收”方式，只有当内存不够的时候才会进行垃圾回收</li><li>如果调用System.gc() 这个方法，只是告诉JVM 希望这里进行垃圾回收，但是具体什么时候回收还需要看JVM的运行状态，且System.gc()对资源还是有一定消耗，如果盲目的运用System.gc()这个方法，反而效率还会下降，看场景适用；</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/xu511739113/article/details/52328727" target="_blank" rel="noopener">https://blog.csdn.net/xu511739113/article/details/52328727</a><br><a href="https://segmentfault.com/a/1190000009057426" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009057426</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Object类是所有类根，即所有的类都隐式继承了Object.&lt;/p&gt;
&lt;h1 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; clas
      
    
    </summary>
    
      <category term="Java" scheme="https://www.notex.top/categories/Java/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.0 新特性</title>
    <link href="https://www.notex.top/2018/03/springboot2-new-featrues.html"/>
    <id>https://www.notex.top/2018/03/springboot2-new-featrues.html</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-2-0-新特性"><a href="#SpringBoot-2-0-新特性" class="headerlink" title="SpringBoot 2.0 新特性"></a>SpringBoot 2.0 新特性</h2><p>在 2018 年 3 月 1 日早上，Spring Boot 2.0 发布，在Spring Boot的官网中，2.0.0已经是最新的Spring Boot推荐版本，并提供了 Maven 中央仓库地址。</p><p>官方表示，这个版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。该版本是自 4 年前发布 Spring Boot 1.0 以来的第一次重大修订，也是首个提供对 Spring Framework 5.0 支持的 GA 稳定版本。</p><p>Spring Boot 2.0 主要有以下特性（详见：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes" target="_blank" rel="noopener">Spring Boot 2.0 Release Notes</a>）。</p><h2 id="支持Java-8和Java-9"><a href="#支持Java-8和Java-9" class="headerlink" title="支持Java 8和Java 9"></a>支持Java 8和Java 9</h2><p>SpringBooot 2.0最低支持Java 8 版本，许多现有的API更新，以利用Java 8 的特性，例如：接口的默认方法，函数回调和新的APIs,如：javax.time。如果你当前使用的是Java 7或者更早的版本，在你开发Springboot 2.0程序之前，你需要升级你的Java版本</p><p><br>Spring Boot 2.0也可以很好地工作，并且已经通过JDK 9进行了测试。</p><h2 id="第三方库的升级"><a href="#第三方库的升级" class="headerlink" title="第三方库的升级"></a>第三方库的升级</h2><p>Spring Boot 2.0建立在Spring Framework 5之上，并且需要Spring Framework 5</p><p>Spring Boot 2.0已尽可能升级到其他第三方游戏机的最新稳定版本。本版本中一些值得注意的依赖性升级包括<br><br>Tomcat 8.5<br><br>Flyway 5<br><br>Hibernate 5.2<br><br>Thymeleaf 3</p><h2 id="更好的响应式支持"><a href="#更好的响应式支持" class="headerlink" title="更好的响应式支持"></a>更好的响应式支持</h2><p>SpringBoot 2.0通过auto-configuration 和 starter-POMs更好的支持响应式应用。Spring Boot的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是嵌入式服务器支持）</p><p>使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持<br>Spring Data还为响应式应用程序提供支持。目前Cassandra，MongoDB，Couchbase和Redis都有反应式API支持</p><h2 id="支持-HTTP-2"><a href="#支持-HTTP-2" class="headerlink" title="支持 HTTP/2"></a>支持 HTTP/2</h2><p>为Tomcat，Undertow和Jetty提供HTTP / 2支持。是否支持取决于所选的Web服务器和应用程序环境（因为JDK 8不支持该协议）</p><h2 id="Gradle-插件"><a href="#Gradle-插件" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h2><p>Spring Boot的Gradle插件在很大程度上已被重写，以实现许多重大改进。需要注意：SpringBoot 2.0 现在需要Gradle 4.x 的版本</p><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p>SpringBoot 2.0对Kotlin 1.2.x 版本的支持，并提供了一个runApplication函数，该函数提供了一种使用惯用Kotlin运行Spring Boot应用程序的方法。</p><h2 id="对Quartz调度支持"><a href="#对Quartz调度支持" class="headerlink" title="对Quartz调度支持"></a>对Quartz调度支持</h2><p>SpringBoot 2.0 对Quartz的支持，我们只需要加入 <code>spring-boot-starter-quartz</code> starter POM.</p><p>支持JobStores或者基于JDBC的存储。 Spring应用程序上下文中的所有JobDetail，Calendar和Trigger bean将自动注册到Scheduler中</p><h2 id="Testing-测试"><a href="#Testing-测试" class="headerlink" title="Testing 测试"></a>Testing 测试</h2><p>新版本对测试做了一些改变。</p><ul><li>一个新的<code>@WebFluxTest</code>注解，以支持WebFlux应用程序的“slice”测试。</li><li>现在使用<code>@WebMvcTest</code>和<code>@WebFluxTest</code>自动扫描Converter和GenericConverter bean<h2 id="动画ASCII艺术"><a href="#动画ASCII艺术" class="headerlink" title="动画ASCII艺术"></a>动画ASCII艺术</h2>最后，为了好玩，Spring Boot 2.0现在支持动画GIF横幅。<br><a href="http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif" target="_blank" rel="noopener"><img src="http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif" alt></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringBoot-2-0-新特性&quot;&gt;&lt;a href=&quot;#SpringBoot-2-0-新特性&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 2.0 新特性&quot;&gt;&lt;/a&gt;SpringBoot 2.0 新特性&lt;/h2&gt;&lt;p&gt;在 2018
      
    
    </summary>
    
      <category term="Spring" scheme="https://www.notex.top/categories/Spring/"/>
    
    
      <category term="springboot" scheme="https://www.notex.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>exchange邮箱类型使用Java发送邮件</title>
    <link href="https://www.notex.top/2018/02/exchange-send-mail-java.html"/>
    <id>https://www.notex.top/2018/02/exchange-send-mail-java.html</id>
    <published>2018-02-10T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。</p><h1 id="添加dependencie"><a href="#添加dependencie" class="headerlink" title="添加dependencie"></a>添加dependencie</h1><p>使用gradle，代码如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.microsoft.ews-java-api:ews-java-api:2.0'</span></span><br></pre></td></tr></table></figure></p><p>使用maven，代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.microsoft.ews-java-api<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ews-java-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者直接导入<code>ews-java-api-2.0.jar</code>包</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myluffy.springboot.chapter33;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.core.ExchangeService;</span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.core.enumeration.misc.ExchangeVersion;</span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.core.enumeration.property.BodyType;</span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.core.service.item.EmailMessage;</span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.credential.ExchangeCredentials;</span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.credential.WebCredentials;</span><br><span class="line"><span class="keyword">import</span> microsoft.exchange.webservices.data.property.complex.MessageBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeSendMail</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExchangeService service = <span class="keyword">new</span> ExchangeService(ExchangeVersion.Exchange2010_SP1);</span><br><span class="line">        ExchangeCredentials credentials = <span class="keyword">new</span> WebCredentials(<span class="string">"username"</span>, <span class="string">"password"</span>);</span><br><span class="line">        service.setCredentials(credentials);</span><br><span class="line">        <span class="comment">// outlook.com 改为自己的邮箱服务器地址</span></span><br><span class="line">        service.setUrl(<span class="keyword">new</span> URI(<span class="string">"https://outlook.com/EWS/Exchange.asmx"</span>));</span><br><span class="line">        EmailMessage msg = <span class="keyword">new</span> EmailMessage(service);</span><br><span class="line">        <span class="comment">// 主题</span></span><br><span class="line">        msg.setSubject(<span class="string">"subject"</span>);</span><br><span class="line">        <span class="comment">// 内容</span></span><br><span class="line">        <span class="comment">// MessageBody 默认是发送html格式的内容</span></span><br><span class="line">        MessageBody content = <span class="keyword">new</span> MessageBody(BodyType.Text, <span class="string">"content"</span>);</span><br><span class="line">        msg.setBody(content);</span><br><span class="line"><span class="comment">//        msg.setBody(MessageBody.getMessageBodyFromText("content")); // 内容为html格式</span></span><br><span class="line">        <span class="comment">// 收件人</span></span><br><span class="line">        msg.getToRecipients().add(<span class="string">"xx@gmail.com"</span>);</span><br><span class="line">        <span class="comment">// 抄送人</span></span><br><span class="line">        msg.getCcRecipients().add(<span class="string">"xx2@gmail.com"</span>);</span><br><span class="line">        <span class="comment">// 暗送</span></span><br><span class="line">        msg.getBccRecipients().add(<span class="string">"xx3@gmail.com"</span>);</span><br><span class="line">        <span class="comment">// 附件</span></span><br><span class="line">        msg.getAttachments().addFileAttachment(<span class="string">"/Users/xx/Downloads/demo.text"</span>);</span><br><span class="line">        msg.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有问题，可联系我。</p><p>参考文档<br><a href="https://github.com/OfficeDev/ews-java-api/wiki/Getting-Started-Guide" title="ews-java-api" target="_blank" rel="noopener">ews-java-api</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。&lt;/p&gt;
&lt;h1 id=&quot;添加dependencie&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="技术" scheme="https://www.notex.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JDK8源码学习：ArrayList 源码解析</title>
    <link href="https://www.notex.top/2018/02/arraylist-source.html"/>
    <id>https://www.notex.top/2018/02/arraylist-source.html</id>
    <published>2018-02-10T16:00:00.000Z</published>
    <updated>2019-12-23T10:59:48.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</li><li><p>按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。</p></li><li><p>如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。</p></li><li><p>越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。</p></li></ul><h1 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h1><p>ArrayList是Java集合框架List接口的实现类，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过代码我们看出，ArrayList继承AbstractList方法，并且在实现了List方法的同时，还实现了RandomAccess、Cloneable（克隆）、Serializable（序列化）；<br>ArrayList类图如下所示：<br><img src="http://qxu1146470209.my3w.com/wordpress/wp-content/uploads/2018/02/49feecd1bc989fa98b6aad419ea8db21.png" alt></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认初始化容量大小为10</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 共用的数组实例用于空的实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认大小的空实例所用的共用的数组实例。我们判断当一个元素被加入时数组实例该怎样扩大</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * elementData存储ArrayList内的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储在ArrayList内的容量大小</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个空的集合，并规定初始化容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity  该集合需要初始化的容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 新建一个规定大小容量的集合赋值给 elementData</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 空的集合赋给 elementData</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 传入变量 非法，抛出异常。</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  构造一个空的集合并初始化容量为10</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造一个包含指定元素的集合，按集合的顺序返回使用迭代器。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">           <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// replace with empty array. 替换为空</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法-add"><a href="#添加方法-add" class="headerlink" title="添加方法 add()"></a>添加方法 add()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加规定的根元素到集合的最后</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在add之前会调用ensureCapacityInternal()方法，判断是否需要扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果elementData 为空 ，指定elementData的最小默认容量。如果为第一次添加，默认容量为10</span></span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// overflow-conscious code 如容量不足，进行扩容。</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 增加容量，确保至少可以支持最小规定元素的数量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li>从grow方法中可以看出，ArrayList的elementData数组如遇到容量不足时，将会把新容量newCapacity设置为 oldCapacity + (oldCapacity &gt;&gt; 1)。二进制位操作&gt;&gt; 1等同于/2的效果，扩容导致的newCapacity也就设置为原先的1.5倍。</li><li>如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity。不过这种情况一般不会用到，很少会用到这么大的ArrayList。</li><li>在确保有容量的情况下，会将元素添加至elementData数组中。</li></ul><h3 id="移除方法-remove"><a href="#移除方法-remove" class="headerlink" title="移除方法 remove()"></a>移除方法 remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除列表中指定的元素 并将index 后面的元素移动位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断index 是否在 list大小范围之内</span></span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line"><span class="comment">// 根据index 取出需要移除的数据 赋值oldValue</span></span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line"><span class="comment">// 需要移动的大小</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>该方法是根据元素位置移除列表数据，首先判断index是否在列表元素的范围之内，将需要移除的数据，赋值给oldvalue存储，计算出该元素之后的列表数量，使用System.arraycopy()方法，该方法的作用是：从指定的源数组中复制一个数组，从指定的位置，到目标数组的指定位置。返回oldValue;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最
      
    
    </summary>
    
      <category term="Java相关" scheme="https://www.notex.top/categories/Java%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="java" scheme="https://www.notex.top/tags/java/"/>
    
  </entry>
  
</feed>
