<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK8源码学习：LinkedList]]></title>
    <url>%2F2018%2F11%2Fjava-linkedlist.html</url>
    <content type="text"><![CDATA[概述LinkedList是允许元素为null的双向链表，LinkedList是线程不安全的，底层是基于链表的实现。因为底层是链表的原因，说明，插入、删除比较方便，只需要移动对应的指针即可。但是在处理随机访问的数据，就会要比ArrayList慢了。 属性LinkedList的属性相对比较少，只有下面的三个属性。123456// 集合元素的数量transient int size = 0;// 链表的第一个指针元素transient Node&lt;E&gt; first;// 链表最后一个元素transient Node&lt;E&gt; last; 构造方法LinkedList只有两个构造方法，一个时默认的构造方法，另一个是将集合初始化到LinkedList。12345678910111213/** * 初始化一个空的LinkedList */public LinkedList() &#123;&#125;/** * 初始化一个包含集合元素的LinkedList */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); // 调用默认构造方法 addAll(c); // 将元素全部添加到LinkedList&#125; 在看 addAll()方法前，先看看Node节点结构1234567891011private static class Node&lt;E&gt; &#123; E item; // 节点值 Node&lt;E&gt; next; // 下一个节点 Node&lt;E&gt; prev; // 前一个节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 看完了Node的结构，随便把node(int)方法给看了，该方法在文中会多次遇到。123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // size &gt;&gt; 1 等价于 size/2 。通过将LinkedList折半，增加查询效率。 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; // 保存第一个节点，因为需要从第一个节点开始循环查找 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; node(int index)的实现是一个一个循环遍历得到的值，虽然说用到了缩小范围的折半方式优化查询。但是还是不可避免的导致获取效率低下。 在初始化有集合元素的构造方法是会调用到 addAll() 方法，跟着 addAll() 方法一直看下去，核心实现如下：12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检验index是否在范围内 [0, size] checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; // 记录传递过来的集合元素个数 if (numNew == 0) return false; Node&lt;E&gt; pred, succ; // pred: index前置节点, index的后置节点 // 在链表尾部添加数据 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); // 获取index节点的值，赋值给succ pred = succ.prev; // succ的前置节点赋值给 pred &#125; // 遍历添加元素 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; // 根据前置节点和当前元素之构建 node节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) // 没有前置节点 first = newNode; else pred.next = newNode; pred = newNode; &#125; // 判断添加元素是否在队尾添加 if (succ == null) &#123; last = pred; // 设置队尾节点 &#125; else &#123; // 在链表中间添加的元素 pred.next = succ; // 设置前置节点的下一个值 succ.prev = pred; // 设置后置节点的前一个值 &#125; size += numNew; // 重新设置LinkedList的元素数量 modCount++; // 记录一次结构更改的次数 return true;&#125; addAll()方法的实现过程还是容易看懂的。首先检查插入的位置是否在范围之内，接着判断是在链表中间插入数据，还是在链表尾部插入数据，设置根据succ和pred。然后循环遍历添加节点到LinkedList中。整个过程大致就是这样 常用方法接下来看看LinkedList中的常用方法 add 添加LinkedList的添加方法，主要是 add(E)、 add(int, E)，首先来看看默认的add(E)方法的代码：1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 上面代码没有具体逻辑，具体实现在linkLast(e)中，接着进入该方法中。123456789101112void linkLast(E e) &#123; final Node&lt;E&gt; l = last; // 将末尾节点设置给l节点 // 根据末尾节点做前置节点，得到一个新的节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; // 更新末尾节点为新的节点 if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; linkLast方法实现过程是，首先得到末尾节点l，根据l做前置节点得到一个新的节点，最后对末尾节点重新赋值。我们可以看出，整个add方法在不指定添加位置的情况下，默认将值添加到末尾的。看了默认的add方法实现，接着看看在规定位置添加节点的实现add(int, E)方法的实现123456789public void add(int index, E element) &#123; // 校验添加节点的位置是否在 [0, size] 之间 checkPositionIndex(index); // 如果添加的位置刚好尾部节点，直接调用默认添加方法的实现。 if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 接着进入linkBefore方法看看是怎么实现的。e: 待添加元素值，succ: 带添加位置的节点123456789101112void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; // 保存待添加位置的前置节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 根据前置节点、当前值、后置节点 得到一个新的节点 succ.prev = newNode; // 设置添加位置的前置节点 if (pred == null) first = newNode; // 如果前置节点为空，直接设置 第一个节点 （first代表第一个节点） else pred.next = newNode; // 将前面保存的前置节点的下一节点设置为新的节点 size++; // 将LinkedList的容量加一 modCount++; // 记录一下更改的次数&#125; 整个过程通过代码中的注释，大致都能看的明白。在添加方法中还有addLast、addFrist方法。首先看看addLast方法123public void addLast(E e) &#123; linkLast(e);&#125; 实现过程和默认的add方法一样，唯一的区别就是默认add方法有返回值，addLast方法没有返回值。接下来看看addFrist(E)方法。123456789101112131415public void addFirst(E e) &#123; linkFirst(e);&#125;// 具体实现private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; // 保存原来的第一个节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 得到一个新的节点，新节点的下一个节点就是原来的第一个节点 first = newNode; if (f == null) last = newNode; // 说明之前为空的LinkedList，直接设置末尾节点为新节点 else f.prev = newNode; // 设置原来第一个节点的前置节点为新节点 size++; // 容量+1 modCount++; // 修改次数 +1&#125; remove 删除删除有两个实现，其一是：remove()不需要传入指针的位置，默认删除第一个，其二是remove(int)方法，该方法是传入一个需要删除的位置，如果删除成功会返回被删除的值。remove()方法的实现过程和remove(int)差不多，也可以理解为remove()默认传递了指针为0。这里就不单独介绍了。接下来就看看remove(int) 是怎么实现的。代码如下：123456public E remove(int index) &#123; // 检验index是否在[0, size]之间 checkElementIndex(index); // node(index)：待删除节点 return unlink(node(index));&#125; 核心实现在unlink方法中，接下来看看 unlink的实现12345678910111213141516171819202122232425262728E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // x 为待删除节点 final E element = x.item; // 保存一下值，删除完成之后，需要返回给调用者。 final Node&lt;E&gt; next = x.next; // 保存x的下一个节点 final Node&lt;E&gt; prev = x.prev; // 保存x的前一个节点 // 如果前置节点为空 if (prev == null) &#123; // 直接设置LinkedList的frist节点为 x的下一个节点 first = next; &#125; else &#123; // 设置x的前置节点的下一个节点为 x的后置节点 prev.next = next; x.prev = null; // 将x的前置节点设置为null，方便gc &#125; if (next == null) &#123; last = prev; // 如果x的后置节点为空，LinkedList的末尾节点设置为x的前置节点 &#125; else &#123; next.prev = prev; // 设置x的下一个节点的前置节点为 x的前置节点 x.next = null; // 将x的后置节点设置为null，方便gc &#125; x.item = null; // 将x值设置为null，方便gc size--; // 容量 -1 modCount++; return element;&#125; 删除方法的核心就是，将待删除节点的前置节点的下一个节点设置为待删除节点的下一个节点（读起来蛮拗口的，多读几遍就能理解了）。 getget(int)方法，根据位置获取值。先贴上代码12345public E get(int index) &#123; // 检验index是否在[0, size]之间 checkElementIndex(index); return node(index).item;&#125; 上面已经有对node(index)方法做过解释了，该方法就是得到节点，返回节点的值。 setset(int, E)方法是一个根据index替换其原来的值，最后返回原始值。123456789101112public E set(int index, E element) &#123; // 检验index是否在[0, size]之间 checkElementIndex(index); // 根据index获取需要设置的节点 Node&lt;E&gt; x = node(index); // 保存旧值 E oldVal = x.item; // 设置新值 x.item = element; // 返回旧值 return oldVal;&#125; pollpoll()方法是获取并删除第一个元素。其实就是删除第一个元素并返回删除元素的值和remove()方法相同。这里也不做过多解释了。1234public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; peekpeek() 获取第一个节点的值。和poll()唯一不同的是，peek不需要删除第一个节点。实现如下：1234public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; 总结LinkedList的分析到这里就结束了。LinkedList是一个双向列表，在删除，添加元素方面有着比ArrayList更好的体验。但是在查询的时候需要一个一个遍历得到结果，虽说在遍历的时候将LinkedList分为了前一半和后一半遍历，但是和ArrayList的底层动态数组相比，还是差的太多。所以在项目具体使用过程中，还是得按需使用。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用fish终端命令，不支持 `$`符号]]></title>
    <url>%2F2018%2F10%2Fhomebrew-fish-err.html</url>
    <content type="text"><![CDATA[问题在fish命令中使用以下命令eg 1:1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" eg 2:1cd "$(brew --repo)" 报错提示： fish: $(…) is not supported. In fish, please use ‘(curl)’./usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 在Mac 的fish终端中使用了 “$”报错。 解决方法去掉$即可工作 1/usr/bin/ruby -e (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac对nginx 启动、关闭、重启]]></title>
    <url>%2F2018%2F10%2Fmac-install-nginx.html</url>
    <content type="text"><![CDATA[问题在终端中执行：brew install nginx安装完成之后，nginx配置文件路径在/usr/local/etc/nginx下 常用命令查看nginx版本nginx -v启动nginx：brew services start nginx关闭nginx：brew services stop nginx 也可以使用如下快捷指令重新启动nginx：nginx -s reload停止nginx：nginx -s stop]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——栈的压入、弹出序列（java版本）]]></title>
    <url>%2F2018%2F10%2Fcodeinterview-stack-push-pop.html</url>
    <content type="text"><![CDATA[栈的压入、弹出序列牛客网——栈的压入、弹出序列 题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路使用一个栈来模拟压入、弹出操作。依次将第一个数组pushA压入栈，压入之后比对第二个数组popA，判断是否需要弹出。如果pushA已经全部入栈，但是stack却没有弹出完。说明不是一个弹出序列。 实现12345678910111213141516public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if (pushA == null || pushA.length == 0) &#123; return true; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int len = pushA.length; for (int i = 0, popIndex = 0; i &lt; len; i++) &#123; stack.push(pushA[i]); // 依次入栈 // 栈顶元素和popA[popIndex]比较，判断是否需要弹出。 while (i &lt; len &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popA[popIndex]) &#123; stack.pop(); popIndex++; &#125; &#125; return stack.isEmpty();&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——最小的K个数（java版本）]]></title>
    <url>%2F2018%2F10%2Fcodeinterview-minimum-k-number.html</url>
    <content type="text"><![CDATA[最小的K个数牛客网——最小的K个数 题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。 解题思路全排序 先排序，接着找出最小的K个数。时间复制度为O(n*n)。 12345678910111213141516171819public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if (input.length &lt; k) return new ArrayList&lt;&gt;(); int len = input.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-1; j ++)&#123; if (input[j] &gt; input[j+1]) &#123; int temp = input[j]; input[j] = input[j+1]; input[j+1] = temp; &#125; &#125; &#125; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) &#123; result.add(input[i]); &#125; return result;&#125; 对于这种解法，是可以优化的，我只需K个数，说明我可以只对K个长度排序，不全排序。对于这种解法，可以叫做局部排序，时间复杂度O(n*k)。 堆 先用当前K个元素生存一个大顶堆，这个堆用于存储当前最小的k个元素。接着，从第k+1个元素开始扫描，和堆中最大的元素比较，如果被扫描的元素小于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最小的k个元素。时间复制度：O(n*lg(k)) 1234567891011public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) &#123; if (k &gt; nums.length || k &lt;= 0) return new ArrayList&lt;&gt;(); PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1); for (int num : nums) &#123; maxHeap.add(num); if (maxHeap.size() &gt; k) maxHeap.poll(); &#125; return new ArrayList&lt;&gt;(maxHeap);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk8源码学习：ConcurrentHashMap]]></title>
    <url>%2F2018%2F10%2Fjdk8-ConcurrentHashMap.html</url>
    <content type="text"><![CDATA[概述ConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的安全，但是HashTable的同步机制颗粒度太粗（实现机制是将put、size等各种方法加上‘synchronized’，导致了所有并发操作需要竞争同一把锁），导致性能低下,现在已经很少被推荐使用。在jdk8中，ConcurrentHashMap底层实现使用了数组+链表+红黑树的数据结构 常用变量LOAD_FACTOR 加载因子LOAD_FACTOR的默认大小是0.75f。为何是0.75 而不是其他的值呢？首先理解一下，什么是加载因子。 加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然 冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。 结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。 DEFAULT_CAPACITY 默认容量DEFAULT_CAPACITY的默认值为16，可以通过构造方法定义该值，但是需要注意的是，DEFAULT_CAPACITY的值是2的幂次方。结合前面的加载因子，可以得出，ConcurrentHashMap的初始化容量为:0.75*16=12,当size大于12的时候，就会发生扩容。 构造方法123// 使用默认初始化表大小（16）创建一个空的mappublic ConcurrentHashMap() &#123;&#125; 123456789// 创建一个新的空map，初始化表大小容纳指定数量的元素，不需要动态调转大小。public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;&#125; 该构造方法 就是设置 sizeCtl; 首先计算initialCapacity + (initialCapacity &gt;&gt;&gt; 1 （可以简写为： 1.5*initialCapacity + 1）, 再调用tableSizeFor 方法，该方法的作用是：对1.5*initialCapacity + 1向上取最近的2的n次方。比如：初始化大小为：10，计算结果为16。 初始化大小为：15，计算结果为32. 常用方法put 方法123public V put(K key, V value) &#123; return putVal(key, value, false);&#125; 该方法主要是调用了 putVal(),接下来是实现具体实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final V putVal(K key, V value, boolean onlyIfAbsent) &#123; // key 和 value 都不能为空 if (key == null || value == null) throw new NullPointerException(); // 计算 hash int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 如果数组为空，则初始化数组 if (tab == null || (n = tab.length) == 0) // 初始化数组方法 后面单独介绍 tab = initTable(); // 通过hash值找到数组对应的节点f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // f节点为空，调用casTabAt方法 //casTabAt 具体执行过程是，底层通过sun.misc.Unsafe 调用了compareAndSwapObject。该方法是无锁算法，将值插入数组中。 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // MOVED : 转换节点的hash值 else if ((fh = f.hash) == MOVED) // 帮助数据迁移。并发情况下。 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; // 头结点的 hash 值大于 0，说明是链表。 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; // 根据hash判断是否有相等的key， 如果有匹配成功，通过onlyIfAbsent 判断是否需要覆盖该key对应的值。然后break。 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; // 到了这儿，说明没有匹配的key，如果该节点的下一个节点为空，说明已经到了链表的末端，将值给放在该链表的最末端即可，然后break。 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 判断是否为红黑树 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; // 调用红黑树的put方法，根据onlyIfAbsent判断是否覆盖该值。 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // 如果 binCount不等于0，则在进行链表操作。 if (binCount != 0) &#123; // TREEIFY_THRESHOLD 默认为8 // 如果binCount的值大于等于8，则调用treeifyBin方法 if (binCount &gt;= TREEIFY_THRESHOLD) // 后面单独介绍该方法 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; put方法的主要流程就是这样，接下来看看，put流程中遗留的几个问题。 初始化数组 initTable12345678910111213141516171819202122232425262728293031 /** * Initializes table, using the size recorded in sizeCtl.* 使用sizeCtl中记录的大小初始化表。 */ private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; // 初始化‘线程’竞争失败。等待。 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin // 利用CAS操作， 并设置sizeCtl的值。 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; // 三目运算，DEFAULT_CAPACITY默认为16 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; // 如果n的值为16，则sc计算结果为12 sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 设置sizeCtl值 sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; 链表转红黑树 treeifyBin1234567891011121314151617181920212223242526272829 private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123;// 如果数组的长度小于 MIN_TREEIFY_CAPACITY（64），对数组进行扩容 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // n值翻倍之后传入 tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; // 加锁 if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; // 遍历链表，建立红黑树。 for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; // 将红黑树设置到数组的相应位置 setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); &#125; &#125; &#125; &#125; &#125; 链表转红黑树方法，在开始的时候回校验数组的长度，如果小于64，会进行扩容，反之，进行转红黑树过程。 扩容 tryPresize将ConcurrentHashMap的容量扩展为原来的两倍。 123456789101112131415161718192021222324252627282930313233343536373839404142private final void tryPresize(int size) &#123; // size 在传递过来的时候，已经翻倍了。 如果size大于等于 最大容量的二分之一，c的值就是默认最大容量 // 反之，调用tableSizeFor方法，该方法就是对(size*1.5+1),在向上取2的n次方。 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); int sc; while ((sc = sizeCtl) &gt;= 0) &#123; Node&lt;K,V&gt;[] tab = table; int n; if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if (table == tab) &#123; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; &#125; &#125; else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) break; else if (tab == table) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; Node&lt;K,V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); &#125; &#125;&#125; get(Object kye) 取值接下来看看获取value的方法，get(key)规定了key不能为null，如果为null，则会抛出NPE。实现过程如下： 123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; // 类似与HashMap中的hash方法 int h = spread(key.hashCode()); // table为当前对象中存储所有元素的数组，不能为空 // tabAt是根据hash值，从table中找到hash为h的这个元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; // 判断元素的hash是否相等，接着判断key是否相等，如相等直接返回value if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; // 遍历链表，直到找到对应的值为止。 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; get方法比较简单，没有加锁，只需要根据key直接取值就可以。类似containsKey(Object key)方法，其实就是调用了get方法，在判断get的返回值是否为空而已。 remove(Object key) 删除remove方法实现如下： 123public V remove(Object key) &#123; return replaceNode(key, null, null);&#125; 具体实现在replaceNode方法中，接来下是该方法的具体实现。replaceNode是对remove/replace公共方法的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final V replaceNode(Object key, V value, Object cv) &#123; // 根据key的hashCode计算出hash值 int hash = spread(key.hashCode()); // 循环table for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 如果tab为空或者通过tabAt得到的node节点为空，直接跳出循环 if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; //如果链表头节点的hash值为-1，说明table可能正在进行扩容，调用helpTransfer方法帮助扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123; // 对链表头节点加锁 if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; validated = true; // 遍历链表查找key值 for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; // 判断节点e的key是否相等 V ev = e.val; if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; // 如果给定的value为null，或者value与cv相等 oldVal = ev; if (value != null) // 如果给定你的value不为null，替换节点e的value e.val = value; else if (pred != null) // 如果链表的前一个节点不为null，将节点e的下一个节点指向前一个节点的下一个节点。相当于删除当前节点 pred.next = e.next; else setTabAt(tab, i, e.next); // 前一个节点为null，说明是链表头节点，插入头节点，next指向原头节点的next &#125; break; &#125; pred = e; if ((e = e.next) == null) // 没有找到匹配的key，返回 break; &#125; &#125; // 如果节点为树结构 else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; // 调用findTreeNode方法根据key查找节点 if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; //调用树节点removeTreeNode方法删除节点，返回true说明节点太少，转化为链表结构 else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null;&#125; 总结 在JDK8中使用了CAS方法保证操作的原子性 与JDK7不同的是，在JDK8中，当链表长度到达一定值时，会自动转为红黑树存储。 与JDK7不同的是，在JDK8中，ConcurrentHashMap不再使用segment结构，而是使用synchronized关键字对table中的链表头节点进行加锁，粒度更小，从而使同时操作的线程数量更多，效率更高。 参考《Java并发编程实战》 https://juejin.im/post/5a7844556fb9a06351725263]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8源码学习:TreeMap]]></title>
    <url>%2F2018%2F09%2Fjdk8-source-treemap.html</url>
    <content type="text"><![CDATA[概述本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。前面介绍了HashMap，因为HashMap是一种无序的存储集合，当某些时候需要特定的存储顺序的时候，就只能另寻他法了，在jdk中为我们提供了LinkedHashmap和TreeMap以供我们使用，本文先介绍TreeMap。TreeMap和HashMap一样都是继承至AbstractMap，并且实现了NavigableMap()，TreeMap是在NavigableMap基础上基于红黑树的实现，他是一种顺序的存储结构。TreeMap数据结构为Entry，Entry简单实现如下：123456789static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; // 左节点 Entry&lt;K,V&gt; right; // 右节点 Entry&lt;K,V&gt; parent; // 父节点 boolean color = BLACK; // ... 其他代码省略&#125; 常用变量 rootroot的定义为：private transient Entry&lt;K,V&gt; root，可以理解为一个短暂的 Entry sizesize的定义为：private transient int size = 0， 记录树中的数量 modCountmodCount的定义为：private transient int modCount = 0，记录结构性发生变化的次数，比如删除节点。 comparatorcomparator的定义为：private final Comparator&lt;? super K&gt; comparator,用于维护此树形图中的顺序，如果使用其键的自然顺序，则comparator为空。 构造方法无参 public TreeMap()代码如下：123public TreeMap() &#123; comparator = null;&#125; 构造方法，没有指定comparator，所以使用它的自然顺序排序。 有参 public TreeMap(Comparator&lt;? super K&gt; comparator)代码如下：123public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125; 构造方法，使用给定的comparator规则排序 public TreeMap(Map&lt;? extends K, ? extends V&gt; m)代码如下：1234public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125; 构造一个新的 tree map，其中包含给定map的相同的映射，根据key的自然顺序进行排序，插入的新map的所有key必须实现 Comparable接口 public TreeMap(SortedMap&lt;K, ? extends V&gt; m)实现代码如下：12345678910public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; // 将SoretdMap的排序方法赋给comparator comparator = m.comparator(); try &#123; // 构建 tree map buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; 构造一个新的 tree map，其中包含给定map的相同的映射，并且使用给定的 sorted map 的排序方式进行排序 常用方法put() 插入插入方法是我们开发常用的方法，接下来看看，TreeMap的put方法具体是怎么实现的，为了方便阅读部分注释直接写在了代码中，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; // 比较连个key值，使用此时正确的compare方法。 compare(key, key); // type (and possibly null) check // new 一个 entry节点 root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; // 记录结构变化的次数 return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; // 设置value到特定的位置 do &#123; parent = t; cmp = cpr.compare(key, t.key); // 比较 key 和 t.key if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); // cmp=0，设置value &#125; while (t != null); &#125; else &#123; if (key == null) // 不允许key为null throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 设置value到特定的位置 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 走到了这里， 说明了，cmp != 0，没有找到对应的key值，新建一个entry e，并将e放在相应的parent左右节点下面 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;&#125; put方法还是比较容易能理解的，首先判断root是否为空，如果没空，直接new Entry即可。不为空，根据comparator的值，查找要设置value的位置。如果没有找到匹配的key，则新建一个Entry e，再根据cmp的值，将Entry e设置到对应的位置即可。 get 获取值根据key获取一个Entry，具体实现如下：1234567891011121314151617181920212223242526final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) // 如果默认comparator不为空，调用getEntryUsingComparator方法 return getEntryUsingComparator(key); if (key == null) // key不允许为null throw new NullPointerException(); // 走到了这里，说明comparator为空，使用默认排序方法。 @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将当前root赋值给p Entry&lt;K,V&gt; p = root; // 循环遍历p while (p != null) &#123; // 通过compareTo方法比较key与p的key int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; // 将p.left赋值给p else if (cmp &gt; 0) p = p.right; // 将p.right赋值给p else return p; // 说明key与p.key相等，返回当前p节点 &#125; // 如果p节点中，没有找到对应的key，返回null return null;&#125; 获取Entry的方法的过程大致为：根据comparator获取Entry，其实就是遍历root，查找比较key，有匹配的返回对应的entry即可。注意key值不允许为空，会抛出空指针异常。在获取Entry的方法中，如果comparator不为空，则使用getEntryUsingComparator方法获取。实现如下：1234567891011121314151617181920final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; @SuppressWarnings("unchecked") K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; // 通过自定义的compare方法比较key与p的key int cmp = cpr.compare(k, p.key); if (cmp &lt; 0) p = p.left; // 将p.left赋值给p else if (cmp &gt; 0) p = p.right; // 将p.right赋值给p else return p;// 说明key与p.key相等，返回当前p节点 &#125; &#125; // 如果p节点中，没有找到对应的key，返回null return null;&#125; 实现过程和上面差不多，只是比较key值的方法换了而已。 firstKey获取第一个key12345public K firstKey() &#123; // getFirstEntry得到第一个Entry，调用key(),得到key值。 return key(getFirstEntry());&#125;该方法比较简单，就不细说了。 lastKey获取最后一个key1234public K lastKey() &#123; // getLastEntry得到最后一个Entry，调用key(),得到key值。 return key(getLastEntry());&#125; lastKey的具体实现过程在getLastEntry中，实现如下：1234567final Entry&lt;K,V&gt; getLastEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p;&#125; 实现方法和firstKey差不多。一直找到最右节点为止。 remove 删除具体代码实现如下：123456789101112// 根据key删除entry节点，返回valuepublic V remove(Object key) &#123; // 根据key得到对应entry节点 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; // 删除entity，后面会介绍 deleteEntry(p); return oldValue;&#125; 首先根据key查找Entry，如果不为空，则调用deleteEntry方法删除。deleteEntry方法是实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Delete node p, and then rebalance the tree. * 删除节点p，从新平衡树 */private void deleteEntry(Entry&lt;K,V&gt; p) &#123; // 增加一次结构发生变化的次数 modCount++; // 此TreeMap节点数量减一 size--; // If strictly internal, copy successor's element to p and then make p // point to successor. // 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 if (p.left != null &amp;&amp; p.right != null) &#123; // successor: 得到p后面的节点 Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. // replacement为替代节点，如果p的左节点不为空，则为p的左节点，反之为p的右节点 Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); // 如果replacement不为空 if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) // 如p没有父节点，则根root直接变为替代节点 root = replacement; else if (p == p.parent.left) //如果P为左节点，则用replacement来替代为左节点 p.parent.left = replacement; else p.parent.right = replacement; //如果P为右节点，则用replacement来替代为右节点 // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; //去除p节点 // Fix replacement // 根据节点的颜色，来删除。红色：直接删除，黑色：删除之后，需要平衡树，调整位置。 if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. // 说明是唯一的节点，当前root直接返回 null 即可 root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); // 删除p节点 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 最后本文是对TreeMap做了一个简单的介绍，没有对删除节点之后，红黑树怎么自动平衡做讲解，后面会专门写一篇文章对红黑树做一个学习。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8源码学习:HashMap]]></title>
    <url>%2F2018%2F09%2Fjdk8-source-hashmap.html</url>
    <content type="text"><![CDATA[概述HashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量–&gt;构造方法–&gt;常用方法。在JDK7中，HashMap的底层数据结构为：数组+链表的形式。在JDK8中，HashMap的底层数据结构为：数组+链表+红黑树（TreeNode），增加红黑树的结构。 变量 loadFactor 加载因子默认加载因子为0.75f,为何是0.75 而不是其他的值呢？首先理解一下，什么是加载因子。加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。加载因子的值是可以大于1的。 thresholdthreshold表示当HashMap的size大于threshold时会执行resize操作。 size记录数组的长度 modCountmodCount是记录HashMap发送结构性变化的次数，比如扩容、rehash。 另外大概了解一下HashMap的最大容量 1&lt;&lt;30也就是2的30次方，初始化容量为16。 构造方法 HashMap(int, float)为了方便阅读，注释直接写在了代码里面。 1234567891011121314public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // 初始化容量必须在 1&lt;&lt;30 以内 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; // 调用了tableSizeFor方法，该方法是返回给定的`initialCapacity`值的向上取最近的2的幂。比如传递的值为12，返回16。 this.threshold = tableSizeFor(initialCapacity);&#125; HashMap(int) 1234public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;该构造方法，只是指定了初始化容量，使用默认的加载因子，调用`HashMap(int, float)`方法。 常用方法put 插入put方法主要的实现过程如下，为了方便阅读，将注释写在了代码中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) // 如果table为空，调用resize()方法，初始化一个table。 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // 该节点不存在，新建节点 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) // 如果是p节点是红黑树节点，调用红黑树的put方法。 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // 找到链表的最后一个节点，插入新的节点 p.next = newNode(hash, key, value, null); // 如果binCount的大小大于等于TREEIFY_THRESHOLD-1（TREEIFY_THRESHOLD默认为8），调用treeifyBin方法，后面单独介绍该方法。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 链表中存在该节点，跳出循环。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 根据oblyIfAbsent是否更新值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; // 修改 modCount ++modCount; // 如果table大小大于了阈值，则需要扩容。 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 上面已经介绍了put方法的主流程，接下来分析一下该方法中留下的几个问题。 treeifyBin方法 12345678910111213141516171819202122 final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e;// 判断是否需要扩容，MIN_TREEIFY_CAPACITY的值：64,也就是说在大小为16、 32 的时候，不要进行结构转换 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; // 将节点转为树节点 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; // 将p树节点指向hd树节点 else &#123; p.prev = tl; // 当前p树节点指向 p树节点的前一树节点 tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; treeifyBin方法主要是把容器里的元素变成树结构。当HashMap的内部元素数组中某个位置上存在多个hash值相同的键值对，这些Node已经形成了一个链表，当该链表的长度大于等于7的时候，会调用该方法来进行一个特殊处理。 get 取值源码中get方法代码如下，为了方便阅读，在代码中会写上相应的注释。 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 这段代码比较简单，调用了getNode()方法，并传入hash(key)和key，所以说取值的过程在getNode中，下面看看该方法的具体实现：1234567891011121314151617181920212223242526final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; // 定义一个新的table数组、首节点 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 判断table数组是否为空，并且根据hash值算出 tab[(n - 1) &amp; hash]是否为空，其中一个条件为空，说明key没有对应的value值。 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断首节点的hash和key是否都相等，如果都等，直接返回首节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 走到这儿，说明是一个链表了或者红黑树了 if ((e = first.next) != null) &#123; // 判断是否为红黑树 if (first instanceof TreeNode) // 调用 红黑树的getTreeNode方法 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表一直找到匹配的值为止 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; getNode方法的过程相对而言是比较简单的，上面注释基本上比较易懂的，在整个流程中，红黑树的取值方法，没有说到，接下来看看getTreeNode方法中主要流程。123final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null);&#125; getTreeNode方法的实现过程如下：123456789101112131415161718192021222324252627282930313233343536final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; // ph: p节点的hash值，pk:p节点的key值 int ph, dir; K pk; // pl: p节点的左节点， pr：p节点的右节点 TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) // p节点的hash值大于了 h（h是待get值的hash值），将左节点赋值给p节点 p = pl; else if (ph &lt; h) // p节点的hash值小于了 h（h是待get值的hash值），将右节点赋值给p节点 p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) // 走到了这儿，说明p.hash==h,只需要匹配key是否相等就好了。 return p; else if (pl == null) // 左节点为空，将右节点赋值给p节点 p = pr; else if (pr == null) // 右节点为空，将左节点赋值给p节点 p = pl; // kc参数在首次使用比较键时缓存equivalentClassFor（key）。 // comparableClassFor方法：只有当传入对象的运行时类型符合“class C implements Cormparable &lt;C&gt;”，则返回k的Class，否则返回null。 // compareComparables方法: 如果pk匹配kc（k的筛选可比类），则返回k.compareTo（pk），否则返回0。 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null;&#125; 在本文中，主要是对常用的方法get、put做了一个学习了解。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 短链接项目]]></title>
    <url>%2F2018%2F07%2Fshorturl-project-java.html</url>
    <content type="text"><![CDATA[需求将很长的http请求的地址，转为短链接。如下所示：为什么要转短链，短链接可以转发给第三方的时候，能轻易识别，我在开发中有遇到过一次，别人分享给我的地址里面包含了一些特殊字符（$、&amp;）等，我在我的微信里面，直接点击地址，只识别到特殊字符的前半部分，没有整个链接识别完成。 短链服务的作用： 将长链接变为短链接，当然是越短越好 用户点击短链接的时候，实现自动跳转到原来的长链接 原理解析 在游览器地址栏输入短链接地址：如 http://domain/shUESS 游览器会将domain解析为ip地址，得到IP地址之后，会向这个IP发送请求。 后台接收到shUESS字符之后，去对应的存储中查询出原网址。 通过重定向调转到原网址。 实现demo使用springboot完成，相关依赖如下：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- MD5加密 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;/dependency&gt; 长链接转短链接将一长串的链接，转为4至6个字符，我是使用MySQL做存储，用来存储，转换之后的字符 short_key和原来的链接originalUrl；表结构简单版本如下： id: 主键ID，自动递增 short_key: 转换之后的字符，正式环境数据量很大，可以建立索引 originalUrl: 原来的网址 本文采用MD5加密算法对传入网址进行MD5加密，并且将加密之后的字符串，分为4部分分别于0x3FFFFFFF 进行位与运算，生成4个字符串，4个字符串都可以使用。加密核心代码如下：123456789101112131415161718192021222324252627282930313233343536public static String[] shortUrl(String url) &#123; // 可以自定义生成 MD5 加密字符传前的混合 KEY String key = ""; // 要使用生成 URL 的字符 String[] chars = new String[]&#123;"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"&#125;; // 对传入网址进行 MD5 加密 String sMD5EncryptResult = DigestUtils.md5Hex(key + url); String hex = sMD5EncryptResult; String[] resUrl = new String[4]; for (int i = 0; i &lt; 4; i++) &#123; // 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算 String sTempSubString = hex.substring(i * 8, i * 8 + 8); // 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用 // long ，则会越界 long lHexLong = 0x3FFFFFFF &amp; Long.parseLong(sTempSubString, 16); String outChars = ""; for (int j = 0; j &lt; 6; j++) &#123; // 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引 long index = 0x0000003D &amp; lHexLong; // 把取得的字符相加 outChars += chars[(int) index]; // 每次循环按位右移 5 位 lHexLong = lHexLong &gt;&gt; 5; &#125; // 把字符串存入对应索引的输出数组 resUrl[i] = outChars; &#125; return resUrl; &#125; 短链接转长链接有了长链接转短链接之后，这一步就简单多了。通过请求的地址，得到short_key,去查询出对应的原网址，再重定向到原网址即可。代码如下：123456789101112@RequestMapping("/&#123;key&#125;")public String find(@PathVariable String key) &#123; if (StringUtils.isEmpty(key)) &#123; return "error"; &#125; ShortUrl byShortKey = repository.getByShortKey(key); if (byShortKey == null) &#123; return "error"; &#125; return "redirect:" + byShortKey.getOriginalUrl();&#125; 完整项目已上传到github 参考https://blog.csdn.net/yushouling/article/details/55096992]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python3 连接mysql 导出数据为excel格式]]></title>
    <url>%2F2018%2F07%2Fpython3-link-mysql-export.html</url>
    <content type="text"><![CDATA[背景最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。才开始觉得sql每次都是固定不变，总量也不多，就通过 MySQL workbench 一条一条查询导出为 .csv文件，但是发现 .csv文件直接打开会出现中文乱码，就需要转码，我就通过Notepad++ 打开csv文件，设置文件格式 utf-8 bom 编码。这一系列步骤下来。人都不好了。后面自己受不了了，就想通过脚本来解决这个重复性工作。我是一个Java开发者，就准备用Java来实现这个工作，但是后面发现Java来解决这个问题，有点太麻烦了，需要连接MySQL，查询数据，通过poi遍历做成poi对应excel的hssfworkbook对象（或者xssfworkbook），然后通过io流输出成excel文件。想到这些，就直接放弃了用Java来实现这个工作了。后面想到了Python，我对Python不熟。就在网上查找了一些资料，发现还是满简单的了。就这样决定用Python来实现了。 具体实现下面是Python的具体实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding:utf8import sysimport xlwt#import MySQLdbimport pymysql as MySQLdbimport datetimedef get_conn_mysql(): conn = MySQLdb.connect(host='localhost', port=3306, user='root', passwd='root', db='test', charset='utf8') return conndef query_data(cur, sql, args): cur.execute(sql, args) return cur.fetchall()# out_path 保存的路径， sql： 需要执行的语句def read_mysql_to_excel(out_path, sql): conn = get_conn_mysql() cursor = conn.cursor() count = cursor.execute(sql) if count != 0: print(count) cursor.scroll(0, mode='absolute') results = cursor.fetchall() fields = cursor.description workbook = xlwt.Workbook() sheet = workbook.add_sheet('building', cell_overwrite_ok=True) for field in range(0, len(fields)): sheet.write(0, field, fields[field][0]) row = 1 col = 0 for row in range(1, len(results)+1): for col in range(0, len(fields)): if results[row-1][col] != None: sheet.write(row, col, u'%s'%results[row-1][col]) else: val = '' sheet.write(row, col, u'%s'%val) workbook.save(out_path)if __name__ == '__main__': # 执行的sql语句 sql = 'select * from sys_user' read_mysql_to_excel('1.xls', sql) 就这样一个简单的 导出数据为excel格式的demo就完成了。 如果有多个sql语句，只需要 hard code，在分别调用那个 read_mysql_to_excel 方法就好了。 参考资料：https://blog.csdn.net/tingzuhuitou/article/details/78749185]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 字符串位数不足自动补全]]></title>
    <url>%2F2018%2F04%2Fjava-string-autocompile.html</url>
    <content type="text"><![CDATA[java 字符串位数不足自动补全 使用org.apache.commons.lang包下的StringUtils的leftPad函数，可以直接得到想要的结果。 1234567public class Demo&#123; public static void main(String[] args) &#123; //第一个参数：补位之前的值，第二个参数：总共的位数，第三个参数：补位用什么字符来填充。 final String s = org.apache.commons.lang.StringUtils.leftPad("10110", 8, "0"); System.out.println(s); // output: 00010110 &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java源码学习：Object]]></title>
    <url>%2F2018%2F04%2Fjava-object-source.html</url>
    <content type="text"><![CDATA[简介Object类是所有类根，即所有的类都隐式继承了Object. 常用方法hashCode()hashCode方法返回对象的散列码，相等对象必须返回相等的hashCode，不同对象的hashCode尽可能不相等；Obejct中定义的hashCode方法为：1public native int hashCode(); equals()Object中定义的equals()方法：123public boolean equals(Object obj) &#123; return (this == obj);&#125; equals()方法，顾名思义就是判断是否相等，可以看见Object中equals()方法是用 ‘==’来判断地址;由此可见，我们常用String类的肯定是重写了该方法的，查看String的源码；123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 当我们重写equals时总要重写hashCode： 重写equals不重写hashCode，会导致“不相等对象拥有相同的hashCode”，导致集合类HashMap，HashSet和Hashtable无法工作；极端情况下，在散列表中使所有对象的hashCode都相等，所有对象都被映射到同一个桶中，散列表退化成链表； 当两个对象调用equal返回true，则两个对象各自调用hashCode()返回相同hashCode； 当两个对象调用equal返回false， 两个对象各自调用hashCode()返回的hashCode可以相同（散列冲突不能完全避免） toString()Object类中toString方法，输出对象的“对象类名@散列码”；123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode());&#125; finalize()Obejct类中finalize()方法1protected void finalize() throws Throwable &#123; &#125; finalize()会在对象被垃圾回收时由垃圾回收器调用，垃圾对象是指没有引用指向的对象 JVM的垃圾回收是”最少回收”方式，只有当内存不够的时候才会进行垃圾回收 如果调用System.gc() 这个方法，只是告诉JVM 希望这里进行垃圾回收，但是具体什么时候回收还需要看JVM的运行状态，且System.gc()对资源还是有一定消耗，如果盲目的运用System.gc()这个方法，反而效率还会下降，看场景适用； Referencehttps://blog.csdn.net/xu511739113/article/details/52328727https://segmentfault.com/a/1190000009057426]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.0 新特性]]></title>
    <url>%2F2018%2F03%2Fspringboot2-new-featrues.html</url>
    <content type="text"><![CDATA[SpringBoot 2.0 新特性在 2018 年 3 月 1 日早上，Spring Boot 2.0 发布，在Spring Boot的官网中，2.0.0已经是最新的Spring Boot推荐版本，并提供了 Maven 中央仓库地址。 官方表示，这个版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。该版本是自 4 年前发布 Spring Boot 1.0 以来的第一次重大修订，也是首个提供对 Spring Framework 5.0 支持的 GA 稳定版本。 Spring Boot 2.0 主要有以下特性（详见：Spring Boot 2.0 Release Notes）。 支持Java 8和Java 9SpringBooot 2.0最低支持Java 8 版本，许多现有的API更新，以利用Java 8 的特性，例如：接口的默认方法，函数回调和新的APIs,如：javax.time。如果你当前使用的是Java 7或者更早的版本，在你开发Springboot 2.0程序之前，你需要升级你的Java版本 Spring Boot 2.0也可以很好地工作，并且已经通过JDK 9进行了测试。 第三方库的升级Spring Boot 2.0建立在Spring Framework 5之上，并且需要Spring Framework 5 Spring Boot 2.0已尽可能升级到其他第三方游戏机的最新稳定版本。本版本中一些值得注意的依赖性升级包括Tomcat 8.5Flyway 5Hibernate 5.2Thymeleaf 3 更好的响应式支持SpringBoot 2.0通过auto-configuration 和 starter-POMs更好的支持响应式应用。Spring Boot的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是嵌入式服务器支持） 使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持Spring Data还为响应式应用程序提供支持。目前Cassandra，MongoDB，Couchbase和Redis都有反应式API支持 支持 HTTP/2为Tomcat，Undertow和Jetty提供HTTP / 2支持。是否支持取决于所选的Web服务器和应用程序环境（因为JDK 8不支持该协议） Gradle 插件Spring Boot的Gradle插件在很大程度上已被重写，以实现许多重大改进。需要注意：SpringBoot 2.0 现在需要Gradle 4.x 的版本 KotlinSpringBoot 2.0对Kotlin 1.2.x 版本的支持，并提供了一个runApplication函数，该函数提供了一种使用惯用Kotlin运行Spring Boot应用程序的方法。 对Quartz调度支持SpringBoot 2.0 对Quartz的支持，我们只需要加入 spring-boot-starter-quartz starter POM. 支持JobStores或者基于JDBC的存储。 Spring应用程序上下文中的所有JobDetail，Calendar和Trigger bean将自动注册到Scheduler中 Testing 测试新版本对测试做了一些改变。 一个新的@WebFluxTest注解，以支持WebFlux应用程序的“slice”测试。 现在使用@WebMvcTest和@WebFluxTest自动扫描Converter和GenericConverter bean动画ASCII艺术最后，为了好玩，Spring Boot 2.0现在支持动画GIF横幅。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码解析]]></title>
    <url>%2F2018%2F02%2Farraylist-source.html</url>
    <content type="text"><![CDATA[概述 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。 如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。 越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。 类结构ArrayList是Java集合框架List接口的实现类，12345public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 省略&#125; 通过代码我们看出，ArrayList继承AbstractList方法，并且在实现了List方法的同时，还实现了RandomAccess、Cloneable（克隆）、Serializable（序列化）；ArrayList类图如下所示： 源码分析变量定义12345678910111213141516171819202122232425/*** 默认初始化容量大小为10 */ private static final int DEFAULT_CAPACITY = 10; /** * 共用的数组实例用于空的实例 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认大小的空实例所用的共用的数组实例。我们判断当一个元素被加入时数组实例该怎样扩大 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * elementData存储ArrayList内的元素 */ transient Object[] elementData; // non-private to simplify nested class access /** * 存储在ArrayList内的容量大小 * * @serial */ private int size; 构造方法123456789101112131415161718192021222324252627282930313233343536373839/** * 构造一个空的集合，并规定初始化容量 * @param initialCapacity 该集合需要初始化的容量 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 新建一个规定大小容量的集合赋值给 elementData this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 空的集合赋给 elementData this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 传入变量 非法，抛出异常。 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * 构造一个空的集合并初始化容量为10 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定元素的集合，按集合的顺序返回使用迭代器。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. 替换为空 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 添加方法 add()12345678/** * 添加规定的根元素到集合的最后 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 在add之前会调用ensureCapacityInternal()方法，判断是否需要扩容123456789101112131415161718192021222324252627private void ensureCapacityInternal(int minCapacity) &#123; // 如果elementData 为空 ，指定elementData的最小默认容量。如果为第一次添加，默认容量为10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code 如容量不足，进行扩容。 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 增加容量，确保至少可以支持最小规定元素的数量 */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 从grow方法中可以看出，ArrayList的elementData数组如遇到容量不足时，将会把新容量newCapacity设置为 oldCapacity + (oldCapacity &gt;&gt; 1)。二进制位操作&gt;&gt; 1等同于/2的效果，扩容导致的newCapacity也就设置为原先的1.5倍。 如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity。不过这种情况一般不会用到，很少会用到这么大的ArrayList。 在确保有容量的情况下，会将元素添加至elementData数组中。 移除方法 remove()12345678910111213141516171819/** * 删除列表中指定的元素 并将index 后面的元素移动位置 */ public E remove(int index) &#123;//判断index 是否在 list大小范围之内 rangeCheck(index); modCount++; // 根据index 取出需要移除的数据 赋值oldValue E oldValue = elementData(index); // 需要移动的大小 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 该方法是根据元素位置移除列表数据，首先判断index是否在列表元素的范围之内，将需要移除的数据，赋值给oldvalue存储，计算出该元素之后的列表数量，使用System.arraycopy()方法，该方法的作用是：从指定的源数组中复制一个数组，从指定的位置，到目标数组的指定位置。返回oldValue;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exchange邮箱类型使用Java发送邮件]]></title>
    <url>%2F2018%2F02%2Fexchange-send-mail-java.html</url>
    <content type="text"><![CDATA[需求使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。 添加dependencie使用gradle，代码如下：1compile 'com.microsoft.ews-java-api:ews-java-api:2.0' 使用maven，代码如下：12345&lt;dependency&gt; &lt;groupId&gt;com.microsoft.ews-java-api&lt;/groupId&gt; &lt;artifactId&gt;ews-java-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; 或者直接导入ews-java-api-2.0.jar包 实现123456789101112131415161718192021222324252627282930313233343536373839package com.myluffy.springboot.chapter33;import microsoft.exchange.webservices.data.core.ExchangeService;import microsoft.exchange.webservices.data.core.enumeration.misc.ExchangeVersion;import microsoft.exchange.webservices.data.core.enumeration.property.BodyType;import microsoft.exchange.webservices.data.core.service.item.EmailMessage;import microsoft.exchange.webservices.data.credential.ExchangeCredentials;import microsoft.exchange.webservices.data.credential.WebCredentials;import microsoft.exchange.webservices.data.property.complex.MessageBody;import java.net.URI;public class ExchangeSendMail &#123; public void sendMail() throws Exception&#123; ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2010_SP1); ExchangeCredentials credentials = new WebCredentials("username", "password"); service.setCredentials(credentials); // outlook.com 改为自己的邮箱服务器地址 service.setUrl(new URI("https://outlook.com/EWS/Exchange.asmx")); EmailMessage msg = new EmailMessage(service); // 主题 msg.setSubject("subject"); // 内容 // MessageBody 默认是发送html格式的内容 MessageBody content = new MessageBody(BodyType.Text, "content"); msg.setBody(content);// msg.setBody(MessageBody.getMessageBodyFromText("content")); // 内容为html格式 // 收件人 msg.getToRecipients().add("xx@gmail.com"); // 抄送人 msg.getCcRecipients().add("xx2@gmail.com"); // 暗送 msg.getBccRecipients().add("xx3@gmail.com"); // 附件 msg.getAttachments().addFileAttachment("/Users/xx/Downloads/demo.text"); msg.send(); &#125;&#125; 如有问题，可联系我。 参考文档ews-java-api]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用JavaMailSender发送邮件]]></title>
    <url>%2F2018%2F01%2FSpring%20Boot%E4%B8%AD%E4%BD%BF%E7%94%A8JavaMailSender%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.html</url>
    <content type="text"><![CDATA[SpringBoot中使用JavaMailSender发送邮件导入依赖在Spring Boot的工程中的 .gradle 中引入spring-boot-starter-mail依赖： 使用gradle1compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-mail&apos;, version: &apos;1.5.9.RELEASE&apos; 配置文件 resource ，使用QQ邮箱为例。123456spring.mail.host: smtp.qq.com spring.mail.username: 用户名spring.mail.password: 密码 该密码是QQ邮箱的授权码，spring.mail.properties.mail.smtp.auth: truespring.mail.properties.mail.smtp.starttls.enable: truespring.mail.properties.mail.smtp.starttls.required: true]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mail</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ajax传递参数，后台使用对象接收。报400错误。]]></title>
    <url>%2F2017%2F11%2Fajax%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%E5%90%8E%E5%8F%B0%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6.html</url>
    <content type="text"><![CDATA[在ajax的传递Json格式的数据到后台，后台使用SpringBoot。 前台Json格式如下: 12345678[&#123; "age": 1, "name": "test", "gender": null, "order": 1&#125;] 后台接收对象格式如下: 1234567 public class User&#123; private Integer age; private String name; private Gender gender; // Gender 为枚举类型 private Integer order;&#125; 因为gender为枚举类型，所以有个Gender Enum 类: 1234public Enum Gender&#123; MALE, FEMALE;&#125; 注意： 前台Json格式中 ‘gender’ 为 null，后台使用对象接收，因为 接收对象中属性Gender为枚举类型。所以前台会报‘400’ 错误，后台因为看见枚举值为 null，或者枚举值不存在，就会报错。 所以在使用有枚举类型对象接收Json格式参数的时候，应该保证传输的值和枚举中对应的属性值一样。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用split 按照'|'（竖线）拆分字符串]]></title>
    <url>%2F2017%2F11%2FJava%E4%BD%BF%E7%94%A8split%E6%96%B9%E6%B3%95%E6%8C%89%E7%85%A7'%7C'%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[在使用String类中的split方法时候，才开始使用了 1"ab|cd".split("|"); 发现得到的结果是错误的，结果如下： 12345ab|cd 很显然，这不是我所需要的结果。原因是竖线 | 在正则中是特殊字符，需要转义，也就是 1split(&quot;\|&quot;); 但实际在java中使用时，\又是java的特殊字符，需要转义，最终变成了 1split(&quot;\\|&quot;); 正确使用如下： 1"ab|cd".split("\\|"); 结果如下： 12abcd]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coderbyte练习题--匹配字符串的特殊字符]]></title>
    <url>%2F2017%2F10%2Fcoderbyte%20.html</url>
    <content type="text"><![CDATA[字符串中两个数字之间 有三个‘？’返回 true1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.*;import java.io.*;class Main &#123; public static String QuestionsMarks(String str) &#123; // code goes here /* Note: In Java the return type of a function and the parameter types being passed are defined, so this return call must match the return type of the function. You are free to modify the return type. */ int len =str.length(); boolean isFlag=false; for(int i=0;i&lt;len;++i)&#123; char c = str.charAt(i); int n =(int)c; if(n &gt;= 48 &amp;&amp; n&lt;=57)&#123; int s = n-48; for(int j=i+1;j&lt;len;++j)&#123; char c1= str.charAt(j); int n1 = (int)c1; if(n1&gt;=48 &amp;&amp; n1&lt;=57)&#123; int s1 = n1-48; if(s1 + s == 10)&#123; String v = str.substring(i+1,j); // System.out.print(v+&quot; &quot;); int count =0 ; for(int k=0;k&lt;v.length();++k)&#123; if(v.charAt(k) == &apos;?&apos;)&#123; count++; &#125; &#125; if(count==3)&#123; // System.out.print(&quot; &amp;&amp; &quot;); isFlag=true; &#125;else &#123; // System.out.print(&quot; @@ &quot;); isFlag=false; return &quot;false&quot;; &#125; j=len; &#125; &#125; &#125; &#125; &#125; if(isFlag) return &quot;true&quot;; return &quot;false&quot;; &#125; public static void main (String[] args) &#123; // keep this function call here Scanner s = new Scanner(System.in); System.out.print(QuestionsMarks(s.nextLine())); &#125; &#125;]]></content>
      <categories>
        <category>coderbyte</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>coderbyte</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo 同步code到GitHub]]></title>
    <url>%2F2017%2F09%2F%E4%BD%BF%E7%94%A8hexo%20%E5%90%8C%E6%AD%A5code%E5%88%B0GitHub.html</url>
    <content type="text"><![CDATA[因为 我们第一次同步的代码到master分支，只属于编译之后的代码（md文件解析成了HTML文件）。当我们需要更换电脑的时候，同步master分支的代码就无法自由更新hexo blog。所以我们就需要把本地的code也同步上传到GitHub上面。步骤如下： 1234567$ git init //初始化本地仓库$ git add source //将必要的文件依次添加，有些文件夹如npm $install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示$ git commit -m "code commit"$ git branch hexo //新建hexo分支$ git checkout hexo //切换到hexo分支上$ git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接$ git push origin hexo //push到Github项目的hexo分支上]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Spring发送邮件]]></title>
    <url>%2F2017%2F09%2Fspring-sendmail.html</url>
    <content type="text"><![CDATA[记录一次在工作使用Spring框架，发送邮件的demo。 依赖注意一下，我使用的是gradle，使用maven的需要通过maven的方式引入jar包依赖。123compile group: 'com.sun.mail', name: 'javax.mail', version: '1.6.0'compile group: 'org.apache.velocity', name: 'velocity', version: '1.7'compile 'org.springframework:spring-context-support' 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445@Servicepublic class MailServiceImpl implements MailService &#123; @Autowired private JavaMailSender mailSender; public VelocityEngine getVelocityEngine() &#123; VelocityEngine velocityEngine = new VelocityEngine(); velocityEngine.setProperty("resource.loader", "class"); velocityEngine.setProperty("class.resource.loader.class", "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"); velocityEngine.setProperty("input.encoding", "UTF-8"); velocityEngine.setProperty("output.encoding", "UTF-8"); velocityEngine.init(); return velocityEngine; &#125; private static MimeMessageHelper helper(MimeMessage mimeMessage)throws Exception&#123; MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); List&lt;String&gt; tos = new ArrayList&lt;&gt;(); // 接收邮件的地址 集合 可以为多个// tos.add("service@*.com"); tos.add("service2@*.com"); helper.setFrom("service@*.com"); String[] strings = (String[])tos.toArray(new String[tos.size()]); helper.setTo(strings); return helper; &#125; @Override public void sendMail(Map&lt;String, Object&gt; map) throws Exception &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = helper(mimeMessage); // 设置邮件主题 helper.setSubject("overdue"); // 需要填充到模板中的内容 Map&lt;String, Object&gt; model = new HashedMap(); model.put("hospital", map.get("hospital")); String template = (String) map.get("template"); // 得到模板 并填充内容，模板地址根据自己的实际情况所定 String text = VelocityEngineUtils.mergeTemplateIntoString( getVelocityEngine(), "template/" + template, "UTF-8", model); helper.setText(text, true); // 发送邮件 mailSender.send(mimeMessage); &#125;&#125; 模板实例在resources目录下，新建一个template文件夹，新建一个 *.vm 文件，注意文件后缀为 .vm如图所示： 模板中内容为：12345678&lt;html&gt;&lt;body&gt;&lt;div&gt; test &lt;p&gt;hospital: $&#123;hospital&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ** 注意 ${hospital} 和service中model字段相对应。 配置发送邮件的密码基本代码写好之后，我们需要在 application.yml 中配置一下邮件的用户名密码等；123456spring: mail: default-encoding: utf-8 host: smtp.exmail.qq.com # 邮箱host，不同的邮箱host是不一样的，这个列子是腾讯企业邮的，具体可以google。 username: service@*.com # 发送邮箱的用户名， 替换为自己的 password: 123456 # 填写自己邮箱的密码，如果是QQ邮箱，应该是需要填写授权码 测试用例现在基本代码洗好了，我们接着写一个测试用例我的项目所用的是springboot，具体情况视自己项目的情况而定。 12345678910111213141516171819202122232425@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@SpringBootTest(classes = OverdueApplication.class)@ActiveProfiles("ubuntu")@Ignorepublic class MailTest &#123; @Autowired private MailService mailService; @Test public void testSendMail() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 模板中的变量 map.put("hospital", "test hospital"); // 对应的邮件模板 文件名 map.put("template", "overdueMail.vm"); try &#123; mailService.sendMail(map); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果 这样，一件简单的邮件模板发送就成功了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装nodejs]]></title>
    <url>%2F2017%2F09%2FMac%20%E5%AE%89%E8%A3%85node%20js.html</url>
    <content type="text"><![CDATA[Mac 安装node jssetp 1: 访问nodejs官网，下载稳定版 https://nodejs.org/en/ 也可以使用 homebrew 安装，执行命令： 1$ brew install node setp 2: 测试是否安装成功 ，执行 : 1$ node -v]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装MySQL]]></title>
    <url>%2F2017%2F09%2FMac%20%E5%AE%89%E8%A3%85mysql%20.html</url>
    <content type="text"><![CDATA[Mac 安装mysql 下载dmg文件 双击安装 点击安装完成之后会出现一个提示，上面默认是root用户 和密码。千万要记住。不要一下手快给关掉了。 如果不小心关掉了。就需要用终端。 1$ cd /usr/local/mysql/bin 切换到root权限 ，需要输入密码。 1$ sudo su 输入之后会看见如下信息： 1sh-3.2# 使用如下命令以安全模式运行mysql 1mysql&gt; ./mysqld_safe --skip-grant-tables &amp; 现在从开一个终端:输入: 1$ mysql -uroot 就可以进入mysql 修改root密码，执行下面的命令。 1mysql&gt; FLUSH PRIVILEGES; 继续执行一下名利修改密码： 1mysql&gt; SET PASSWORD FOR root@'localhost' = PASSWORD('new password'); 到此为止。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
