{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/Thumbs.db","path":"images/Thumbs.db","modified":0,"renderable":0},{"_id":"source/images/nginx-start.jpg","path":"images/nginx-start.jpg","modified":0,"renderable":0},{"_id":"source/images/nginx-v.jpg","path":"images/nginx-v.jpg","modified":0,"renderable":0},{"_id":"source/images/nginx-stop.jpg","path":"images/nginx-stop.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"source/images/sanjin.jpg","path":"images/sanjin.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"c7ae41ad27d54391df4dfd34e1ef3bb9a1177978","modified":1577098788710},{"_id":"source/CNAME","hash":"e1185a05a4661d75ecc21faeb6ac29b9ebdc6630","modified":1577098788710},{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1583923653702},{"_id":"source/google5ed91a6a3b831634.html","hash":"761ae291306aac6a98b4e12e7166c21f1929f820","modified":1577098788719},{"_id":"source/baidu_verify_jzRSTEiebm.html","hash":"81d24a80781148b24741e162dea5fdf6ce825d9b","modified":1577098788719},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1585562292287},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1585562292287},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1585562292288},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1585562292291},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1585562292291},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1585562292291},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1585562292291},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1585562292291},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1585562292292},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1585562292296},{"_id":"themes/next/_config.yml","hash":"2bb8872bb26ae898f0eef31795a00388fb495155","modified":1585566941624},{"_id":"themes/next/package.json","hash":"6be512ba52a3f9edb27f4db15c8cc166741af3e9","modified":1585562292319},{"_id":"source/_drafts/mybatis-source-one.md","hash":"3c400070b2e6d5ba40a3836d20afdb31f99b79b6","modified":1577098788711},{"_id":"source/_data/variables.styl","hash":"5055a41682b3067237108ed93995c48a98f1a0b2","modified":1585564749074},{"_id":"source/about/index.md","hash":"97dfab5c99bd151159e9c2fc13923528bba732d2","modified":1585566008098},{"_id":"source/_posts/Mac-install-mysql .md","hash":"b8cd6d7c0ccd364c5d9b05d690c2ce87d3bc2b54","modified":1583993065667},{"_id":"source/_posts/Mac-installnode js.md","hash":"6bd90ef1acbbf9de029dbe3e04faeddbec488583","modified":1583993073759},{"_id":"source/_posts/Spring Boot-JavaMailSender.md","hash":"62d053d09dfead1d9a0064ad7437fc5341e5485d","modified":1583993086634},{"_id":"source/_posts/arraylist-source.md","hash":"7bf0cc8b8fca03e90128ac5b9ba52c4b3ebc7dc4","modified":1577098788713},{"_id":"source/_posts/codeinterview-minimum-k-number.md","hash":"8aac6127b018b919c3ae464818100c538e1c459c","modified":1577098788713},{"_id":"source/_posts/codeinterview-stack-push-pop.md","hash":"b1acb0a39dc40c9587f87eb4300b1c34db12bdbf","modified":1577098788714},{"_id":"source/_posts/exchange-send-mail-java.md","hash":"0590be9fc3ca8a918b8bc7e05a591961634ebbe3","modified":1577098788714},{"_id":"source/_posts/coderbyte .md","hash":"39d7b0d77f6e74681e6e363316aa6d713c5a2766","modified":1577098788714},{"_id":"source/_posts/homebrew-fish-err.md","hash":"47b2a3c3000c95941842296301d8271adb6f3337","modified":1577098788714},{"_id":"source/_posts/hexo-github.md","hash":"f8b1965a7258d8319f6bd2feb72f4d3d376b0d61","modified":1583992962230},{"_id":"source/_posts/java-keywords.md","hash":"27f7de2118145e7cda302e0db0a3fece328feb19","modified":1577098788715},{"_id":"source/_posts/java-object-source.md","hash":"f4719c9728111bc8aceb6dc0f6d9f0ac31b45473","modified":1577098788715},{"_id":"source/_posts/java-lru.md","hash":"df63f2c6df8fad8bf0ef0b7ea02f77d9b4ff85fc","modified":1577098788715},{"_id":"source/_posts/java-string-autocompile.md","hash":"53b3fc91ab73e0e7420e1ae571f8cb3cb6539453","modified":1585566446777},{"_id":"source/_posts/java-linkedlist.md","hash":"cf0dc4a19c51eeff7f43290d29d8d34630e8729b","modified":1577098788715},{"_id":"source/_posts/java-split-method.md","hash":"93267575d9dd27c0ef6c8c80af86abe5ba43cc65","modified":1583993057717},{"_id":"source/_posts/jdk8-source-ConcurrentHashMap.md","hash":"a8882fd568ec51e639c5c8b0e06efbabfe5673f0","modified":1583993198270},{"_id":"source/_posts/jdk8-source-Integer.md","hash":"6772ae9cd0736fa8954b00d7aabc8063dc79dae3","modified":1577098788716},{"_id":"source/_posts/jdk8-source-String.md","hash":"e06e166ccc527e3beee4c7f7943b74ae52ab2306","modified":1577098788716},{"_id":"source/_posts/jdk8-source-hashmap.md","hash":"c8bb4a2772a77fbfdf3257a6f2b475e496b57296","modified":1585566441422},{"_id":"source/_posts/jdk8-source-hashset.md","hash":"0fe80a413b54c2897f9cf59f2821013608f97002","modified":1577098788717},{"_id":"source/_posts/jdk8-source-treemap.md","hash":"d16725c5646c96a784aa279c0713474a3dc6ae60","modified":1577098788717},{"_id":"source/_posts/mac-install-nginx.md","hash":"65d93dd037371b51ff41b2643e8d70d4d5ba593a","modified":1577098788717},{"_id":"source/_posts/python3-link-mysql-export.md","hash":"f1c1af45b17a9c2ee607a4fedb666fd0aad77121","modified":1577098788718},{"_id":"source/_posts/shorturl-project-java.md","hash":"5f1e056ea435c65c5b0684518442b268be75e365","modified":1577098788718},{"_id":"source/_posts/spring-sendmail.md","hash":"688d16cdefd89fc02491734cb89f1b7d53b911c8","modified":1577098788718},{"_id":"source/_posts/springboot2-new-featrues.md","hash":"152c1cf66e8a95588530dcda4b6ea277d8220465","modified":1577098788718},{"_id":"source/_posts/use-ajax-question.md","hash":"352f9732e927579ead0dbb7c9f70198494c6aa30","modified":1583993183625},{"_id":"source/categories/index.md","hash":"bef391281ac875ee047a3c5b2a274260fcf569bc","modified":1577098788719},{"_id":"source/tags/index.md","hash":"5660bd7c180022fe96b2ad223b6fb8b51d635407","modified":1577098788724},{"_id":"source/images/Thumbs.db","hash":"9bba068598ee583508a6d4ca95f462d184d9247e","modified":1577098788720},{"_id":"source/images/nginx-start.jpg","hash":"1bdaf9f772827137e4b44c1711ca3ba526814857","modified":1577098788720},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1585562292281},{"_id":"source/images/nginx-v.jpg","hash":"be02b4b2fa0cbc4e9ee0201f20532d5e782a1bf0","modified":1577098788721},{"_id":"source/images/nginx-stop.jpg","hash":"8c7bf4ce7df87d796bcd3e4d8ece760bff15a38c","modified":1577098788721},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1585562284209},{"_id":"themes/next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1585562292282},{"_id":"themes/next/.git/index","hash":"b4045cf1a03b42e8b02e474f66b0150d6d03ab99","modified":1585562292371},{"_id":"themes/next/.git/packed-refs","hash":"ee29ebaacb516c7f87603915988b935cae7b1f89","modified":1585562292279},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1585562292288},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1585562292288},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1585562292289},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1585562292289},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1585562292290},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1585562292290},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1585562292290},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1585562292290},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1585562292290},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1585562292290},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1585562292290},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1585562292292},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1585562292293},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1585562292292},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1585562292292},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1585562292293},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1585562292293},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1585562292293},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1585562292293},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1585562292293},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1585562292296},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1585562292296},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1585562292296},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1585562292296},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1585562292297},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1585562292297},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1585562292297},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1585562292297},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1585562292297},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1585562292297},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1585562292298},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1585562292298},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1585562292297},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1585562292298},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1585562292298},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1585562292299},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1585562292298},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1585562292298},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1585562292299},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1585562292299},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1585562292299},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1585562292299},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1585562292299},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1585562292317},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1585562292317},{"_id":"themes/next/layout/index.swig","hash":"342761ef3b5965f489ad7bc279f3ff6d67e9a1f4","modified":1585562292317},{"_id":"themes/next/layout/page.swig","hash":"bf5489a86cb553a68183e0163e64acbcead77c21","modified":1585562292318},{"_id":"themes/next/layout/post.swig","hash":"9ad0ee47ea1279ea84a9a0ee32b425e6d33ce969","modified":1585562292318},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1585562292318},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1585562292323},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1585562284210},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1585562284210},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1585562284209},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1585562284210},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1585562284211},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1585562284210},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1585562284211},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1585562284211},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1585562284210},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1585562284210},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1585562284212},{"_id":"themes/next/.git/logs/HEAD","hash":"de50757f32598c90c25a24536e94e62c2408e1ea","modified":1585562292282},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1585562284211},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1585562292289},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1585562292288},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1585562292289},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1585562292289},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1585562292294},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1585562292294},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1585562292294},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1585562292294},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1585562292294},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1585562292295},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1585562292294},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1585562292295},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1585562292295},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1585562292295},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1585562292295},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1585562292295},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1585562292296},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1585562292306},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c4ec5822d644ddcedf2401837e6f6e6d3b63fbcd","modified":1585562292300},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1585562292306},{"_id":"themes/next/layout/_macro/post.swig","hash":"71e4dc5a56cbc403d9785526f7719d824f4c8911","modified":1585562292300},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1585562292300},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"263178dcdf7b72f5c44d5559e28ef36f4968a251","modified":1585562292307},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1585562292308},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1585562292308},{"_id":"themes/next/layout/_partials/footer.swig","hash":"af2d688f688923080aaf8f20be33cfda629797ea","modified":1585562292301},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1585562292301},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1585562292303},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1585562292303},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1585562292305},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1585562292309},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1585562292311},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1585562292312},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1585562292312},{"_id":"themes/next/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1585562292319},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1585562292321},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1585562292321},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1585562292322},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1585562292322},{"_id":"themes/next/scripts/filters/post.js","hash":"d86849559ae54a4098aef4e2ab9dc8f99a1d186c","modified":1585562292322},{"_id":"themes/next/scripts/tags/button.js","hash":"946dd7beede408d1f090d5e9774d74763828b97c","modified":1585562292324},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1585562292324},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"0f133f27b61e8351cfd0959ba8a1b8551a9a8cc6","modified":1585562292324},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1585562292324},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1585562292325},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1585562292325},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1585562292325},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1585562292325},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1585562292326},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1585562292326},{"_id":"themes/next/scripts/helpers/engine.js","hash":"22d77bd511fc7c1bbd12339d65004ed5bfb0713c","modified":1585562292322},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1585562292323},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1585562292323},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1585562292323},{"_id":"themes/next/source/css/_mixins.styl","hash":"b79ff3debd5709397b122292fc7e551ae9d40782","modified":1585562292344},{"_id":"themes/next/source/css/_colors.styl","hash":"6a5ae9c02d12ee56a5b5222d676ac0a71d7aaa56","modified":1585562292326},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1585562292351},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1585562292351},{"_id":"themes/next/source/images/avatar.jpg","hash":"ec51a69796def3fea0336441fe6916cb044fad94","modified":1585563979979},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1585562292352},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1585562292352},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1585562292352},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1585562292353},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1585562292354},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1585562292353},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1585562292355},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1585562292354},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1585562292354},{"_id":"themes/next/source/images/favicon.png","hash":"d817b456ef60582852ee0d3a65e51a38a6779d30","modified":1585563997191},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1585562292355},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1585562292356},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1585562292355},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1585562292356},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1585562292356},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1585562292360},{"_id":"themes/next/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1585562292357},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1585562292357},{"_id":"themes/next/source/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1585562292357},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1585562292358},{"_id":"themes/next/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1585562292358},{"_id":"themes/next/source/js/utils.js","hash":"95c5d37aa06521675afcf8619cfc5dbba3d2e18a","modified":1585562292359},{"_id":"themes/next/.git/refs/heads/master","hash":"bda16c1e4b8d1a8efdf904d1c7631352b3127cb4","modified":1585562292281},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1585562292307},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1585562292307},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1585562292307},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1585562292307},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1585562292308},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1585562292301},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1585562292301},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1585562292302},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1585562292302},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"12aeb9ee0d1d49d347f82a91e6bab568e1b59037","modified":1585562292302},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1585562292303},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1585562292303},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"958e097790551c9520426a1233add03515034f35","modified":1585562292302},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1585562292303},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1585562292304},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1585562292304},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1585562292304},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"12cd9adb0c33adc484201f9e8a4e64ccf3011bae","modified":1585562292304},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1585562292304},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1585562292305},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"ec20ff43845723e0ac2a245047c7a7e5aead6e88","modified":1585562292305},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1585562292305},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1585562292305},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1585562292308},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1585562292309},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1585562292309},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1585562292310},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1585562292310},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1585562292310},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1585562292309},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1585562292310},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1585562292311},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1585562292309},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1585562292310},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1585562292311},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1585562292309},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1585562292311},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1585562292312},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1585562292313},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1585562292312},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1585562292312},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1585562292315},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1585562292315},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1585562292315},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1585562292315},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1585562292316},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1585562292319},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1585562292316},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1585562292316},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1585562292319},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1585562292320},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1585562292320},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1585562292320},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1585562292320},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1585562292321},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1585562292321},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1585562292321},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1585562292321},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1585562292321},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1585562292350},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"9840998e1a1fbcd419c52a1e38fa54a003eac963","modified":1585562292350},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1585562292350},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"38597817ede20418e73ae4afc50047ea5088c73e","modified":1585562292350},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f43e0ad83d675ae541babfc2d84a1ad3cc1a370","modified":1585562292351},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1585562292361},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1585562292361},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1585562292362},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1585562292363},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1585562292363},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1585562292370},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1585562292370},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1585562292359},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1585562292359},{"_id":"source/images/sanjin.jpg","hash":"330d29ebca56f8baaf1ca51e689f40339b23d75b","modified":1577098788724},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1585562292280},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"de50757f32598c90c25a24536e94e62c2408e1ea","modified":1585562292282},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1585562292326},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1585562292327},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1585562292327},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1585562292332},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"09370b07e158bb0cd305c44002ccd4d2ab9abc1b","modified":1585562292336},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1585562292336},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"8b9156ae47f4c58cf6cf7505cdd22bae7022481f","modified":1585562292339},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"00d73105cb7b872e12d82d1dacbb15d5c2b58291","modified":1585562292340},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1585562292340},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1585562292342},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1585562292342},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1585562292342},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1585562292341},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"4794bd45d5e32ea005c805bcbc65b871e9927d02","modified":1585562292345},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1585562292344},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"3a2ecb6e32374a56f0ef059a6d3e3701339cf47b","modified":1585562292345},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1585562292345},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1585562292346},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1585562292346},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"a49d3c821eb5e4e9661c8fbe548678f93a0ad0a6","modified":1585562292346},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1585562292346},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1585562292347},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1585562292347},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"bb392700f04d956bb5f606efb052453efeade53d","modified":1585562292347},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1585562292348},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1585562292347},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1585562292348},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1585562292347},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1585562292349},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"ccb71d732b12acd02ac26ed6bbda4861d027857d","modified":1585562292348},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e4f958677a75de87ee1caf7e22ba46a0602f22dd","modified":1585562292349},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"82025c3ad7af12e532e2e81be98deb0a74ff23ac","modified":1585562292349},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1585562292365},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1585562292364},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1585562292365},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1585562292369},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"de50757f32598c90c25a24536e94e62c2408e1ea","modified":1585562292280},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1585562292327},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1585562292327},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1585562292328},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"c1daeb60c23945f745703ac2c3f4bf99d0ea3d95","modified":1585562292328},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1585562292328},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1585562292328},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"b480fbde7013f5647b42454d8189d2d45a886b5c","modified":1585562292328},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1585562292329},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"66211794e4ed47e779ca81150cef588e0b4f2fc5","modified":1585562292331},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1585562292330},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"5d5c022aa3b2f89c2f2a178212338bb64804dd75","modified":1585562292329},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1585562292330},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1585562292331},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1585562292332},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"796eb941ba0ca03fd5ca6d15a1f6a56afd9aa174","modified":1585562292331},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1585562292332},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1585562292333},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1585562292332},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1585562292333},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1585562292332},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1585562292334},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1585562292334},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1585562292334},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1585562292333},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1585562292334},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1585562292335},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1585562292335},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1585562292335},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"555762730f1f31451113e8fdc84ec438ea738d90","modified":1585562292335},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1585562292336},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1585562292336},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1585562292337},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1585562292337},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1585562292337},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1585562292337},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1585562292338},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1585562292338},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1585562292338},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1585562292338},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1585562292338},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1585562292339},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1585562292340},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1585562292341},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1585562292341},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1585562292341},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1585562292343},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1585562292343},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1585562292342},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9b3cce30c58e57b59e45d3f668a71a4129d3a8e4","modified":1585562292343},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1585562292344},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"5ac97054b302fe3ce47822a03a3b56aa3d582005","modified":1585562292343},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1585562292343},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1585562292369},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1585562292368},{"_id":"themes/next/.git/objects/pack/pack-3096ee16317aa1964c82711253b57e4701964185.idx","hash":"9c199e3f93cad4441bfb1cb034138e4210cc8437","modified":1585562292269},{"_id":"themes/next/.git/objects/pack/pack-3096ee16317aa1964c82711253b57e4701964185.pack","hash":"66a548065c3a76d717627eb019198e66b11e3faf","modified":1585562292263},{"_id":"public/google5ed91a6a3b831634.html","hash":"a5f756116a30bcc3639276c505265fa7cf98fb6b","modified":1585566730020},{"_id":"public/baidusitemap.xml","hash":"6df90b460dd430366aa94625abc3cd9d80aa1e53","modified":1585566730020},{"_id":"public/atom.xml","hash":"163e0eb6a24cfac8937dfaff2b45687c058bd893","modified":1585566730034},{"_id":"public/search.xml","hash":"5c1e631142a989b2b1d4c96769d679989a750704","modified":1585566730034},{"_id":"public/sitemap.xml","hash":"e135a85b0858fb75849915583fc9bea835072138","modified":1585566730035},{"_id":"public/404.html","hash":"e588feb2935135075440382c186befc485914808","modified":1585566730042},{"_id":"public/baidu_verify_jzRSTEiebm.html","hash":"3cb76488b1ada0d2d43ea7de3fbe6ba46c00ad3c","modified":1585566730042},{"_id":"public/about/index.html","hash":"ad293c1b02c99cf651a7703b2a2661d92ef0c21f","modified":1585566730042},{"_id":"public/categories/index.html","hash":"666c52ec51be25058ee57082e14b31ee7f072dd0","modified":1585566730042},{"_id":"public/tags/index.html","hash":"fa33819e660c26c8f5f9ec1795ccd16f5cb2bae5","modified":1585566730042},{"_id":"public/categories/Mac/index.html","hash":"715b43cb7fa24899269ce0f5ed449bad432114dd","modified":1585566730042},{"_id":"public/categories/Web/index.html","hash":"3e3c8e9bd495b23ff2671e5a1a8a27c91e718c9d","modified":1585566730042},{"_id":"public/categories/Java相关/index.html","hash":"dafc5ac142f52498b47d0edad1f63ff739917dc0","modified":1585566730042},{"_id":"public/categories/算法/index.html","hash":"c4dad7a97f896e3bc224971057c7bf2f1ff3075b","modified":1585566730042},{"_id":"public/categories/技术/index.html","hash":"a0f2e19731963a977bbd64a2e2149fab9c7cead9","modified":1585566730042},{"_id":"public/categories/MacOS/index.html","hash":"cbf062edf1a56bd9f54b90e5d8438ec22634c743","modified":1585566730042},{"_id":"public/categories/Hexo/index.html","hash":"99593bde30dfb77a97d5524f8fc6464221d3a5a0","modified":1585566730042},{"_id":"public/categories/java相关/index.html","hash":"be1017c8df4d54e63eb70ca856f900e99103c9b2","modified":1585566730042},{"_id":"public/categories/python/index.html","hash":"504deb5dd275f22db91585bb0a4f172c1c09835a","modified":1585566730043},{"_id":"public/categories/Spring/index.html","hash":"2ace4756d88535ac2df09488a55e65307f4190c8","modified":1585566730043},{"_id":"public/archives/2017/index.html","hash":"209154cbf9bf71b2ac6062576b220dffcdd2595e","modified":1585566730043},{"_id":"public/archives/2017/09/index.html","hash":"d1df2458c670714f8a5405797acddad43024b741","modified":1585566730043},{"_id":"public/archives/2017/10/index.html","hash":"a58cde984b4e92a3314d1614bedb759e33b07d09","modified":1585566730043},{"_id":"public/archives/2017/11/index.html","hash":"04a73083f7af910a7db7f06613623ab5cfd42c41","modified":1585566730043},{"_id":"public/archives/2018/01/index.html","hash":"4aaa3a09a8e49ee693fac60c7fa08e7835304fee","modified":1585566730043},{"_id":"public/archives/2018/02/index.html","hash":"aca2095a65f27eb55fa8b5034129cdb9541686f9","modified":1585566730043},{"_id":"public/archives/2018/03/index.html","hash":"d272b324c60eda4af1531b64a47f2f50cd4e7eda","modified":1585566730043},{"_id":"public/archives/2018/04/index.html","hash":"6dfcd484462d71feb16940d7eb337a4053fcb5a4","modified":1585566730043},{"_id":"public/archives/2018/07/index.html","hash":"fa005d9b348612d840568409d3ad67d46d9b1fbf","modified":1585566730043},{"_id":"public/archives/2018/09/index.html","hash":"213d808c368594a8dc63c2dee9cf98f486978896","modified":1585566730043},{"_id":"public/archives/2018/10/index.html","hash":"255ca3e0746a06d62c1a31a32636c5c2c8b79289","modified":1585566730043},{"_id":"public/archives/2018/11/index.html","hash":"d3a6bfa66ccc12aeb2511119b5caf608d24726fd","modified":1585566730043},{"_id":"public/archives/2019/index.html","hash":"18c8a226d0b3cf55d1ecffab3efef234512b98fb","modified":1585566730043},{"_id":"public/archives/2019/04/index.html","hash":"ab911dc2ee8169887ad124d480cb987e416a3872","modified":1585566730043},{"_id":"public/archives/2019/07/index.html","hash":"09b911ca37e2aefcf7bb324c8e4f769ea3ae0a9d","modified":1585566730043},{"_id":"public/tags/mac/index.html","hash":"de7349ecb9d2f6a6d268724923e31507d7a70921","modified":1585566730043},{"_id":"public/tags/mysql/index.html","hash":"c599722442a37bfaa58c7eb3328d8484bf7ad4dd","modified":1585566730043},{"_id":"public/tags/mail/index.html","hash":"669d244a5c679fbf44b0d02bc73819006377a3ca","modified":1585566730044},{"_id":"public/tags/springboot/index.html","hash":"867faf4ad872fae77ac666f446891af339aa302e","modified":1585566730044},{"_id":"public/tags/nodejs/index.html","hash":"fe29064d476b2198b9894de6c02dacef8fbf4eb4","modified":1585566730044},{"_id":"public/tags/剑指offer/index.html","hash":"e63ee95bb5f8bd4acfad7cdb870456a82519ffc6","modified":1585566730044},{"_id":"public/tags/coderbyte/index.html","hash":"716afa464dc1863198cbdc0990653a3426ad5cda","modified":1585566730044},{"_id":"public/tags/fish/index.html","hash":"e828bdf7f4932ab02ff8c50aebfaf307bd7329e4","modified":1585566730044},{"_id":"public/tags/hexo/index.html","hash":"5407d5b9887d73918dcceefe4839d2b25ad971f8","modified":1585566730044},{"_id":"public/tags/算法/index.html","hash":"cdd3ac9247c466c90c4a9ebf1a23e283f7a55b23","modified":1585566730044},{"_id":"public/tags/源码/index.html","hash":"4d3e3d8608dcf62ae5f029b1bdf9520335892645","modified":1585566730044},{"_id":"public/tags/nginx/index.html","hash":"58031ec44432c7ea870ee0670c0d7865e1f106fe","modified":1585566730044},{"_id":"public/tags/python/index.html","hash":"4213aa4fc3c0f9d04aea052c67e4846e9255d09a","modified":1585566730044},{"_id":"public/tags/spring/index.html","hash":"c455e610263f53426f2ef9002b6fc0e6955a04ce","modified":1585566730044},{"_id":"public/tags/ajax/index.html","hash":"34eaa7033aa325f8822f7111635156876c901dcb","modified":1585566730044},{"_id":"public/2019/07/java-lru.html","hash":"ca6f160bc563096a9523843f1199bcea6f39de4b","modified":1585566730044},{"_id":"public/2019/04/java-keywords.html","hash":"f77534900497a9ef55d389aa80979bdcf502814a","modified":1585566730044},{"_id":"public/2019/04/jdk8-source-hashset.html","hash":"cd80702a1e1cdf18c6252c38d5cc0b4f2832d362","modified":1585566730044},{"_id":"public/2019/04/jdk8-source-Integer.html","hash":"3bc40f299e0d73a50fd3902349c80df95a063cd9","modified":1585566730044},{"_id":"public/2019/04/jdk8-source-String.html","hash":"6261a494a689a487e0e9f85a7ad9e4619de4356f","modified":1585566730044},{"_id":"public/2018/11/java-linkedlist.html","hash":"6ee811bdb883440e6e9205cd263386a08c422c61","modified":1585566730044},{"_id":"public/2018/10/homebrew-fish-err.html","hash":"2f3acf7dbcf230e54e5be2e1c385d73314bfe92f","modified":1585566730044},{"_id":"public/2018/10/mac-install-nginx.html","hash":"cb5ded2c6135888520b2f1b833f8c38eac7322a6","modified":1585566730045},{"_id":"public/2018/10/codeinterview-stack-push-pop.html","hash":"98e481ada639408ad062e3f2799363f7daecf260","modified":1585566730045},{"_id":"public/2018/10/codeinterview-minimum-k-number.html","hash":"d45f294140f6e1ebdbc09eab53298065e336b4ac","modified":1585566730045},{"_id":"public/2018/10/jdk8-source-ConcurrentHashMap.html","hash":"d77b588d24f2030d762933da78fe41928e6e1e7c","modified":1585566730045},{"_id":"public/2018/09/jdk8-source-treemap.html","hash":"2c49f8e6a36469494a1402f9a51a363561ef801e","modified":1585566730045},{"_id":"public/2018/09/jdk8-source-hashmap.html","hash":"b852638aabd0effe42bcbb1b52be555a03e056d8","modified":1585566730045},{"_id":"public/2018/07/shorturl-project-java.html","hash":"ab19dd506f68b353956253875995d34c445d21af","modified":1585566730045},{"_id":"public/2018/07/python3-link-mysql-export.html","hash":"756b5748176327ea4b4a12e52544f6b81f7fc8d4","modified":1585566730045},{"_id":"public/2018/04/java-string-autocompile.html","hash":"749c43bc08269a87c1124aa6ca27bd2e43d87923","modified":1585566730045},{"_id":"public/2018/04/java-object-source.html","hash":"cb43373fa7d0757faaa756d73f12d8aa29af5c90","modified":1585566730045},{"_id":"public/2018/03/springboot2-new-featrues.html","hash":"2d88d9c4aa3f902f4773303810728b2be70ba290","modified":1585566730045},{"_id":"public/2018/02/exchange-send-mail-java.html","hash":"d7f2bdfbc5894bd8941cdff43d20f7f668025bdd","modified":1585566730045},{"_id":"public/2018/02/arraylist-source.html","hash":"036f7a53c02e900bca03ffd3e65230f3cad4b9ce","modified":1585566730045},{"_id":"public/2018/01/Spring Boot-JavaMailSender.html","hash":"bef7f577de14cdba77b53f3cd796124064f83031","modified":1585566730045},{"_id":"public/2017/11/use-ajax-question.html","hash":"a6acc0c297f1fa33df6c56a7ccae30cfed0cd1e1","modified":1585566730045},{"_id":"public/2017/11/java-split-method.html","hash":"2de48de3a116bf7cc07b8ff612842efdb810210e","modified":1585566730045},{"_id":"public/2017/10/coderbyte .html","hash":"7617fe80279d80a0c6976f84e273391acffb23dc","modified":1585566730045},{"_id":"public/2017/09/hexo-github.html","hash":"2f042ba157142e4f078c52b42f5740ea8a5caef3","modified":1585566730045},{"_id":"public/2017/09/spring-sendmail.html","hash":"c630a1b112e512cf518898d8c77c50149e169150","modified":1585566730045},{"_id":"public/2017/09/Mac-installnode js.html","hash":"97dccba5bd11cd1151d3f087ea4a18dffb52ab09","modified":1585566730046},{"_id":"public/2017/09/Mac-install-mysql .html","hash":"8b5fbecb2c9011999e64060227fb88440f4b08f2","modified":1585566730046},{"_id":"public/categories/Java/index.html","hash":"743ff120f1bd8cdf60b18478d3464202d687f4a2","modified":1585566730046},{"_id":"public/archives/index.html","hash":"f697c928a69103d483464778451ad01f1583ef26","modified":1585566730046},{"_id":"public/archives/2018/index.html","hash":"c153b6e687968f5be8f54a532c4a3c5f7abd5d94","modified":1585566730046},{"_id":"public/index.html","hash":"519630663cfcde79c3564e0ddbe1da103af62631","modified":1585566730046},{"_id":"public/page/2/index.html","hash":"93ad9931ee87916a821134e8742e8008cf8289b8","modified":1585566730046},{"_id":"public/tags/java/index.html","hash":"a2132211229aef3466b8420290815203fb399da8","modified":1585566730046},{"_id":"public/CNAME","hash":"e1185a05a4661d75ecc21faeb6ac29b9ebdc6630","modified":1585566730050},{"_id":"public/images/Thumbs.db","hash":"9bba068598ee583508a6d4ca95f462d184d9247e","modified":1585566730050},{"_id":"public/images/nginx-v.jpg","hash":"be02b4b2fa0cbc4e9ee0201f20532d5e782a1bf0","modified":1585566730050},{"_id":"public/images/nginx-start.jpg","hash":"1bdaf9f772827137e4b44c1711ca3ba526814857","modified":1585566730050},{"_id":"public/images/nginx-stop.jpg","hash":"8c7bf4ce7df87d796bcd3e4d8ece760bff15a38c","modified":1585566730051},{"_id":"public/images/avatar.jpg","hash":"ec51a69796def3fea0336441fe6916cb044fad94","modified":1585566730051},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1585566730051},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1585566730051},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1585566730051},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1585566730051},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1585566730051},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1585566730051},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1585566730052},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1585566730052},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1585566730052},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1585566730052},{"_id":"public/images/favicon.png","hash":"d817b456ef60582852ee0d3a65e51a38a6779d30","modified":1585566730052},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1585566730052},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1585566730052},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1585566730052},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1585566730052},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1585566730052},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1585566730052},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1585566730052},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"1bcf74674566a61fe954e374a231011239b8e5e9","modified":1585566730052},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1585566730367},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1585566730368},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"55eaeaf5ecda250f5bed80958a05bef13886eee6","modified":1585566730368},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"422f4c3882cf8366927333081292a9bed6000124","modified":1585566730368},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1585566730373},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1585566730373},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1585566730374},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1585566730374},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1585566730374},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1585566730374},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1585566730374},{"_id":"public/css/main.css","hash":"31d6eace1597773f4baec57490e44114c391f168","modified":1585566730374},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1585566730374},{"_id":"public/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1585566730379},{"_id":"public/js/utils.js","hash":"95c5d37aa06521675afcf8619cfc5dbba3d2e18a","modified":1585566730380},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1585566730380},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1585566730383},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1585566730388},{"_id":"public/assets/algolia/algoliasearch.js","hash":"f34e955c2112cc6a80b48e48dd240a10817069f9","modified":1585566730388},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1585566730392},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1585566730392},{"_id":"public/images/sanjin.jpg","hash":"330d29ebca56f8baaf1ca51e689f40339b23d75b","modified":1585566730392}],"Category":[{"name":"MyBatis","_id":"ck8edhph10007i3slr2he1rds"},{"name":"Mac","_id":"ck8edhph6000ci3slkleqexlu"},{"name":"Java","_id":"ck8edhph9000ii3slpkslzyzu"},{"name":"Web","_id":"ck8edhphb000ni3slkt7pgeg4"},{"name":"Java相关","_id":"ck8edhphc000ui3slzvd674s3"},{"name":"算法","_id":"ck8edhphf0011i3sltinpr4yu"},{"name":"技术","_id":"ck8edhphl001gi3slgkzb5pua"},{"name":"MacOS","_id":"ck8edhphr001wi3slpj43ny17"},{"name":"Hexo","_id":"ck8edhpht0025i3slyhdtrh5p"},{"name":"java相关","_id":"ck8edhphu002ci3sl8729hfci"},{"name":"python","_id":"ck8edhphv002li3sleq2wqv2c"},{"name":"Spring","_id":"ck8edhphw002pi3sll526wzb8"}],"Data":[{"_id":"variables","data":""}],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <meta name=\"robots\" content=\"all\" />\n    <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n<script type=\"text/javascript\"\n        src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"回到我的主页\">\n</script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <meta name=\"robots\" content=\"all\" />\n    <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n<script type=\"text/javascript\"\n        src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\"\n        charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"回到我的主页\">\n</script>\n</body>\n</html>","date":"2019-12-24T01:31:35.730Z","updated":"2019-12-23T10:59:48.710Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ck8edhpbf0000i3slc70apzqs","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"robots\" content=\"all\">\n    <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n</script>\n</body>\n</html>","site":{"data":{"variables":""}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"robots\" content=\"all\">\n    <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n</script>\n</body>\n</html>"},{"layout":"false","_content":"google-site-verification: google5ed91a6a3b831634.html","source":"google5ed91a6a3b831634.html","raw":"layout: false\n---\ngoogle-site-verification: google5ed91a6a3b831634.html","date":"2019-12-24T01:31:35.730Z","updated":"2019-12-23T10:59:48.719Z","path":"google5ed91a6a3b831634.html","title":"","comments":1,"_id":"ck8edhpbx0001i3slqm8fiflc","content":"google-site-verification: google5ed91a6a3b831634.html","site":{"data":{"variables":""}},"excerpt":"","more":"google-site-verification: google5ed91a6a3b831634.html"},{"_content":"jzRSTEiebm","source":"baidu_verify_jzRSTEiebm.html","raw":"jzRSTEiebm","date":"2019-12-24T01:31:35.733Z","updated":"2019-12-23T10:59:48.719Z","path":"baidu_verify_jzRSTEiebm.html","title":"","comments":1,"layout":"page","_id":"ck8edhpby0002i3sl233dbwp1","content":"jzRSTEiebm","site":{"data":{"variables":""}},"excerpt":"","more":"jzRSTEiebm"},{"title":"关于我","_content":"17年毕业。\n从事Java开发，在魔都工作。\n写博客主要的目的很简单，就是为了提升自己水平。\n没事的时候喜欢去看一些源码，看看大师是怎么编码的。\n我不是一个二次元迷，但是我爱 《ONE PIECE》 、 《Slam Dunk》\n喜欢篮球、科学上网。\n\n<!-- 最后来一张三井寿镇楼 -->\n\n<!-- <img src=\"/images/sanjin.jpg\" width=\"300px\" height=\"100px\"> -->","source":"about/index.md","raw":"---\ntitle: 关于我\n\n---\n17年毕业。\n从事Java开发，在魔都工作。\n写博客主要的目的很简单，就是为了提升自己水平。\n没事的时候喜欢去看一些源码，看看大师是怎么编码的。\n我不是一个二次元迷，但是我爱 《ONE PIECE》 、 《Slam Dunk》\n喜欢篮球、科学上网。\n\n<!-- 最后来一张三井寿镇楼 -->\n\n<!-- <img src=\"/images/sanjin.jpg\" width=\"300px\" height=\"100px\"> -->","date":"2020-03-30T11:00:08.098Z","updated":"2020-03-30T11:00:08.098Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck8edhpgy0004i3slzpw18zaz","content":"<p>17年毕业。<br>从事Java开发，在魔都工作。<br>写博客主要的目的很简单，就是为了提升自己水平。<br>没事的时候喜欢去看一些源码，看看大师是怎么编码的。<br>我不是一个二次元迷，但是我爱 《ONE PIECE》 、 《Slam Dunk》<br>喜欢篮球、科学上网。</p>\n<!-- 最后来一张三井寿镇楼 -->\n<!-- <img src=\"/images/sanjin.jpg\" width=\"300px\" height=\"100px\"> -->","site":{"data":{"variables":""}},"excerpt":"","more":"<p>17年毕业。<br>从事Java开发，在魔都工作。<br>写博客主要的目的很简单，就是为了提升自己水平。<br>没事的时候喜欢去看一些源码，看看大师是怎么编码的。<br>我不是一个二次元迷，但是我爱 《ONE PIECE》 、 《Slam Dunk》<br>喜欢篮球、科学上网。</p>\n<!-- 最后来一张三井寿镇楼 -->\n<!-- <img src=\"/images/sanjin.jpg\" width=\"300px\" height=\"100px\"> -->"},{"title":"分类","date":"2017-09-21T13:48:31.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-09-21 21:48:31\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-12-23T10:59:48.719Z","path":"categories/index.html","layout":"page","_id":"ck8edhph00006i3sl0137csyk","content":"","site":{"data":{"variables":""}},"excerpt":"","more":""},{"ttitle":"标签","date":"2017-09-17T04:39:04.000Z","type":"tags","comments":0,"_content":"\n","source":"tags/index.md","raw":"---\nttitle: 标签\ndate: 2017-09-17 12:39:04\ntype: \"tags\"\ncomments: false\n---\n\n","updated":"2019-12-23T10:59:48.724Z","path":"tags/index.html","title":"","layout":"page","_id":"ck8edhpj0003mi3slhx29cnzu","content":"","site":{"data":{"variables":""}},"excerpt":"","more":""}],"Post":[{"title":"Mybatis源码学习：配置文件解析","abbrlink":"e781838b","date":"2019-06-20T07:59:53.000Z","layout":"false","_content":"\n<!--![](https://ws1.sinaimg.cn/large/64202e18gy1g47obrjquaj20w40fqmzp.jpg)-->\n\n# 介绍\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n# 使用\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。\n直接看从XML中构建SqlSessionFactory的代码实现。\n```java\nString resource = \"mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n首先，通过MyBatis的Resources工具类加载配置文件得到一个输入流，其次，使用SqlSessionFactoryBuilder创建一个SqlSessionFactory对象。下面就是看SqlSessionFactoryBuilder是怎么创建SqlSessionFactory对象的。\n```java\n// SqlSessionFactoryBuilder.java #64\npublic SqlSessionFactory build(InputStream inputStream) {\n    // 调用重载方法\n    return build(inputStream, null, null);\n}\n// 这里才是SqlSessionFactory的具体创建过程\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n        // 对XML解析，底层是调用Java的Xpath工具类解析节点的。\n        // 首先，创建XMLConfigBuilder\n        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        // 创建SqlSessionFactory\n        return build(parser.parse());\n    } catch (Exception e) {\n        throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n        ErrorContext.instance().reset();\n        try {\n        inputStream.close();\n        } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n        }\n    }\n}\n```\nXMLConfigBuilder会通过构造函数设置一些参数，并且会创建一个Document对象。创建好XMLConfigBuilder之后，接着调用了 `XMLConfigBuilder#parse()`方法.\n```java\npublic Configuration parse() {\n    if (parsed) {\n      // 是否解析过该配置文件，不能重复解析\n      throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true; // 标记位，判断是否已经解析过了。\n    // parser.evalNode(\"/configuration\") 是得到一个XNode， configuration标签是MyBatis配置文件的配置入口。\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n\n}\nprivate void parseConfiguration(XNode root) {\n    try {\n      //issue #117 read properties first\n      // 解析properties配置\n      propertiesElement(root.evalNode(\"properties\"));\n      // 解析settings配置并转为Properties对象\n      Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n      loadCustomVfs(settings);\n      // 解析typeAliases标签\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      // 解析plugins配置\n      pluginElement(root.evalNode(\"plugins\"));\n      // 解析objectFactory配置\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      // 解析objectWrapperFactory配置\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      // 解析reflectorFactory配置\n      reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n      settingsElement(settings);\n      // read it after objectFactory and objectWrapperFactory issue #631\n      environmentsElement(root.evalNode(\"environments\"));\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      // 解析 mappers 标签\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n```\n上面需要解析配置的标签比较多，下面只挑选 mappers 标签的解析过程说说。\n```java\nprivate void mapperElement(XNode parent) throws Exception {\n    if (parent != null) {\n      // 循环遍历 parent 的子节点， parent的子节点就是我们配置的 具体mapper文件类似下面这样\n        /*\n        * <mappers>\n        *     <mapper resource=\"mapper/UserMapper.xml\"/>\n        *     <mapper resource=\"mapper/ClassesMapper.xml\"/>\n        * </mappers>\n        */\n      for (XNode child : parent.getChildren()) {\n        if (\"package\".equals(child.getName())) {\n            // 获取 <package> 节点中的 name 属性\n          String mapperPackage = child.getStringAttribute(\"name\");\n          // 从指定包中查找 mapper 接口，并根据 mapper 接口解析映射配置\n          configuration.addMappers(mapperPackage);\n        } else {\n          // 我们是配置文件，所以会走这里。获取 resource、url、mapperClass属性\n          String resource = child.getStringAttribute(\"resource\");\n          String url = child.getStringAttribute(\"url\");\n          String mapperClass = child.getStringAttribute(\"class\");\n          if (resource != null && url == null && mapperClass == null) {\n            ErrorContext.instance().resource(resource);\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url != null && mapperClass == null) {\n            ErrorContext.instance().resource(url);\n            InputStream inputStream = Resources.getUrlAsStream(url);\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url == null && mapperClass != null) {\n            Class<?> mapperInterface = Resources.classForName(mapperClass);\n            configuration.addMapper(mapperInterface);\n          } else {\n            throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n          }\n        }\n      }\n    }\n}\n```\n\n\n","source":"_drafts/mybatis-source-one.md","raw":"---\ntitle: Mybatis源码学习：配置文件解析\ncategory:\n  - MyBatis\ntags:\n  - MyBatis\nabbrlink: e781838b\ndate: 2019-06-20 15:59:53\nlayout: false\n---\n\n<!--![](https://ws1.sinaimg.cn/large/64202e18gy1g47obrjquaj20w40fqmzp.jpg)-->\n\n# 介绍\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n# 使用\n每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。\n直接看从XML中构建SqlSessionFactory的代码实现。\n```java\nString resource = \"mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n首先，通过MyBatis的Resources工具类加载配置文件得到一个输入流，其次，使用SqlSessionFactoryBuilder创建一个SqlSessionFactory对象。下面就是看SqlSessionFactoryBuilder是怎么创建SqlSessionFactory对象的。\n```java\n// SqlSessionFactoryBuilder.java #64\npublic SqlSessionFactory build(InputStream inputStream) {\n    // 调用重载方法\n    return build(inputStream, null, null);\n}\n// 这里才是SqlSessionFactory的具体创建过程\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n        // 对XML解析，底层是调用Java的Xpath工具类解析节点的。\n        // 首先，创建XMLConfigBuilder\n        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        // 创建SqlSessionFactory\n        return build(parser.parse());\n    } catch (Exception e) {\n        throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n        ErrorContext.instance().reset();\n        try {\n        inputStream.close();\n        } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n        }\n    }\n}\n```\nXMLConfigBuilder会通过构造函数设置一些参数，并且会创建一个Document对象。创建好XMLConfigBuilder之后，接着调用了 `XMLConfigBuilder#parse()`方法.\n```java\npublic Configuration parse() {\n    if (parsed) {\n      // 是否解析过该配置文件，不能重复解析\n      throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true; // 标记位，判断是否已经解析过了。\n    // parser.evalNode(\"/configuration\") 是得到一个XNode， configuration标签是MyBatis配置文件的配置入口。\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n\n}\nprivate void parseConfiguration(XNode root) {\n    try {\n      //issue #117 read properties first\n      // 解析properties配置\n      propertiesElement(root.evalNode(\"properties\"));\n      // 解析settings配置并转为Properties对象\n      Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n      loadCustomVfs(settings);\n      // 解析typeAliases标签\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      // 解析plugins配置\n      pluginElement(root.evalNode(\"plugins\"));\n      // 解析objectFactory配置\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      // 解析objectWrapperFactory配置\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      // 解析reflectorFactory配置\n      reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n      settingsElement(settings);\n      // read it after objectFactory and objectWrapperFactory issue #631\n      environmentsElement(root.evalNode(\"environments\"));\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      // 解析 mappers 标签\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n```\n上面需要解析配置的标签比较多，下面只挑选 mappers 标签的解析过程说说。\n```java\nprivate void mapperElement(XNode parent) throws Exception {\n    if (parent != null) {\n      // 循环遍历 parent 的子节点， parent的子节点就是我们配置的 具体mapper文件类似下面这样\n        /*\n        * <mappers>\n        *     <mapper resource=\"mapper/UserMapper.xml\"/>\n        *     <mapper resource=\"mapper/ClassesMapper.xml\"/>\n        * </mappers>\n        */\n      for (XNode child : parent.getChildren()) {\n        if (\"package\".equals(child.getName())) {\n            // 获取 <package> 节点中的 name 属性\n          String mapperPackage = child.getStringAttribute(\"name\");\n          // 从指定包中查找 mapper 接口，并根据 mapper 接口解析映射配置\n          configuration.addMappers(mapperPackage);\n        } else {\n          // 我们是配置文件，所以会走这里。获取 resource、url、mapperClass属性\n          String resource = child.getStringAttribute(\"resource\");\n          String url = child.getStringAttribute(\"url\");\n          String mapperClass = child.getStringAttribute(\"class\");\n          if (resource != null && url == null && mapperClass == null) {\n            ErrorContext.instance().resource(resource);\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url != null && mapperClass == null) {\n            ErrorContext.instance().resource(url);\n            InputStream inputStream = Resources.getUrlAsStream(url);\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url == null && mapperClass != null) {\n            Class<?> mapperInterface = Resources.classForName(mapperClass);\n            configuration.addMapper(mapperInterface);\n          } else {\n            throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n          }\n        }\n      }\n    }\n}\n```\n\n\n","slug":"mybatis-source-one","published":0,"updated":"2019-12-23T10:59:48.711Z","comments":1,"photos":[],"link":"","_id":"ck8edhpgu0003i3slkqavgx1i","content":"<!--![](https://ws1.sinaimg.cn/large/64202e18gy1g47obrjquaj20w40fqmzp.jpg)-->\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。<br>直接看从XML中构建SqlSessionFactory的代码实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String resource = <span class=\"string\">\"mybatis-config.xml\"</span>;</span><br><span class=\"line\">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=\"line\">SqlSessionFactory sqlSessionFactory = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>\n<p>首先，通过MyBatis的Resources工具类加载配置文件得到一个输入流，其次，使用SqlSessionFactoryBuilder创建一个SqlSessionFactory对象。下面就是看SqlSessionFactoryBuilder是怎么创建SqlSessionFactory对象的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SqlSessionFactoryBuilder.java #64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(InputStream inputStream)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用重载方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(inputStream, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里才是SqlSessionFactory的具体创建过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对XML解析，底层是调用Java的Xpath工具类解析节点的。</span></span><br><span class=\"line\">        <span class=\"comment\">// 首先，创建XMLConfigBuilder</span></span><br><span class=\"line\">        XMLConfigBuilder parser = <span class=\"keyword\">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class=\"line\">        <span class=\"comment\">// 创建SqlSessionFactory</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> build(parser.parse());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error building SqlSession.\"</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Intentionally ignore. Prefer previous error.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>XMLConfigBuilder会通过构造函数设置一些参数，并且会创建一个Document对象。创建好XMLConfigBuilder之后，接着调用了 <code>XMLConfigBuilder#parse()</code>方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Configuration <span class=\"title\">parse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 是否解析过该配置文件，不能重复解析</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Each XMLConfigBuilder can only be used once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parsed = <span class=\"keyword\">true</span>; <span class=\"comment\">// 标记位，判断是否已经解析过了。</span></span><br><span class=\"line\">    <span class=\"comment\">// parser.evalNode(\"/configuration\") 是得到一个XNode， configuration标签是MyBatis配置文件的配置入口。</span></span><br><span class=\"line\">    parseConfiguration(parser.evalNode(<span class=\"string\">\"/configuration\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">parseConfiguration</span><span class=\"params\">(XNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//issue #117 read properties first</span></span><br><span class=\"line\">      <span class=\"comment\">// 解析properties配置</span></span><br><span class=\"line\">      propertiesElement(root.evalNode(<span class=\"string\">\"properties\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析settings配置并转为Properties对象</span></span><br><span class=\"line\">      Properties settings = settingsAsProperties(root.evalNode(<span class=\"string\">\"settings\"</span>));</span><br><span class=\"line\">      loadCustomVfs(settings);</span><br><span class=\"line\">      <span class=\"comment\">// 解析typeAliases标签</span></span><br><span class=\"line\">      typeAliasesElement(root.evalNode(<span class=\"string\">\"typeAliases\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析plugins配置</span></span><br><span class=\"line\">      pluginElement(root.evalNode(<span class=\"string\">\"plugins\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析objectFactory配置</span></span><br><span class=\"line\">      objectFactoryElement(root.evalNode(<span class=\"string\">\"objectFactory\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析objectWrapperFactory配置</span></span><br><span class=\"line\">      objectWrapperFactoryElement(root.evalNode(<span class=\"string\">\"objectWrapperFactory\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析reflectorFactory配置</span></span><br><span class=\"line\">      reflectorFactoryElement(root.evalNode(<span class=\"string\">\"reflectorFactory\"</span>));</span><br><span class=\"line\">      settingsElement(settings);</span><br><span class=\"line\">      <span class=\"comment\">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class=\"line\">      environmentsElement(root.evalNode(<span class=\"string\">\"environments\"</span>));</span><br><span class=\"line\">      databaseIdProviderElement(root.evalNode(<span class=\"string\">\"databaseIdProvider\"</span>));</span><br><span class=\"line\">      typeHandlerElement(root.evalNode(<span class=\"string\">\"typeHandlers\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析 mappers 标签</span></span><br><span class=\"line\">      mapperElement(root.evalNode(<span class=\"string\">\"mappers\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Error parsing SQL Mapper Configuration. Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面需要解析配置的标签比较多，下面只挑选 mappers 标签的解析过程说说。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mapperElement</span><span class=\"params\">(XNode parent)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 循环遍历 parent 的子节点， parent的子节点就是我们配置的 具体mapper文件类似下面这样</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * &lt;mappers&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        *     &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        *     &lt;mapper resource=\"mapper/ClassesMapper.xml\"/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        * &lt;/mappers&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"package\"</span>.equals(child.getName())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取 &lt;package&gt; 节点中的 name 属性</span></span><br><span class=\"line\">          String mapperPackage = child.getStringAttribute(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 从指定包中查找 mapper 接口，并根据 mapper 接口解析映射配置</span></span><br><span class=\"line\">          configuration.addMappers(mapperPackage);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 我们是配置文件，所以会走这里。获取 resource、url、mapperClass属性</span></span><br><span class=\"line\">          String resource = child.getStringAttribute(<span class=\"string\">\"resource\"</span>);</span><br><span class=\"line\">          String url = child.getStringAttribute(<span class=\"string\">\"url\"</span>);</span><br><span class=\"line\">          String mapperClass = child.getStringAttribute(<span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (resource != <span class=\"keyword\">null</span> &amp;&amp; url == <span class=\"keyword\">null</span> &amp;&amp; mapperClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ErrorContext.instance().resource(resource);</span><br><span class=\"line\">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=\"line\">            XMLMapperBuilder mapperParser = <span class=\"keyword\">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class=\"line\">            mapperParser.parse();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span> &amp;&amp; url != <span class=\"keyword\">null</span> &amp;&amp; mapperClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ErrorContext.instance().resource(url);</span><br><span class=\"line\">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class=\"line\">            XMLMapperBuilder mapperParser = <span class=\"keyword\">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class=\"line\">            mapperParser.parse();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span> &amp;&amp; url == <span class=\"keyword\">null</span> &amp;&amp; mapperClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class=\"line\">            configuration.addMapper(mapperInterface);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"A mapper element may only specify a url, resource or class, but not more than one.\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<!--![](https://ws1.sinaimg.cn/large/64202e18gy1g47obrjquaj20w40fqmzp.jpg)-->\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。<br>直接看从XML中构建SqlSessionFactory的代码实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String resource = <span class=\"string\">\"mybatis-config.xml\"</span>;</span><br><span class=\"line\">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=\"line\">SqlSessionFactory sqlSessionFactory = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>\n<p>首先，通过MyBatis的Resources工具类加载配置文件得到一个输入流，其次，使用SqlSessionFactoryBuilder创建一个SqlSessionFactory对象。下面就是看SqlSessionFactoryBuilder是怎么创建SqlSessionFactory对象的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SqlSessionFactoryBuilder.java #64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(InputStream inputStream)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用重载方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> build(inputStream, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里才是SqlSessionFactory的具体创建过程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对XML解析，底层是调用Java的Xpath工具类解析节点的。</span></span><br><span class=\"line\">        <span class=\"comment\">// 首先，创建XMLConfigBuilder</span></span><br><span class=\"line\">        XMLConfigBuilder parser = <span class=\"keyword\">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class=\"line\">        <span class=\"comment\">// 创建SqlSessionFactory</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> build(parser.parse());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error building SqlSession.\"</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Intentionally ignore. Prefer previous error.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>XMLConfigBuilder会通过构造函数设置一些参数，并且会创建一个Document对象。创建好XMLConfigBuilder之后，接着调用了 <code>XMLConfigBuilder#parse()</code>方法.<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Configuration <span class=\"title\">parse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsed) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 是否解析过该配置文件，不能重复解析</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Each XMLConfigBuilder can only be used once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parsed = <span class=\"keyword\">true</span>; <span class=\"comment\">// 标记位，判断是否已经解析过了。</span></span><br><span class=\"line\">    <span class=\"comment\">// parser.evalNode(\"/configuration\") 是得到一个XNode， configuration标签是MyBatis配置文件的配置入口。</span></span><br><span class=\"line\">    parseConfiguration(parser.evalNode(<span class=\"string\">\"/configuration\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">parseConfiguration</span><span class=\"params\">(XNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//issue #117 read properties first</span></span><br><span class=\"line\">      <span class=\"comment\">// 解析properties配置</span></span><br><span class=\"line\">      propertiesElement(root.evalNode(<span class=\"string\">\"properties\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析settings配置并转为Properties对象</span></span><br><span class=\"line\">      Properties settings = settingsAsProperties(root.evalNode(<span class=\"string\">\"settings\"</span>));</span><br><span class=\"line\">      loadCustomVfs(settings);</span><br><span class=\"line\">      <span class=\"comment\">// 解析typeAliases标签</span></span><br><span class=\"line\">      typeAliasesElement(root.evalNode(<span class=\"string\">\"typeAliases\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析plugins配置</span></span><br><span class=\"line\">      pluginElement(root.evalNode(<span class=\"string\">\"plugins\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析objectFactory配置</span></span><br><span class=\"line\">      objectFactoryElement(root.evalNode(<span class=\"string\">\"objectFactory\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析objectWrapperFactory配置</span></span><br><span class=\"line\">      objectWrapperFactoryElement(root.evalNode(<span class=\"string\">\"objectWrapperFactory\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析reflectorFactory配置</span></span><br><span class=\"line\">      reflectorFactoryElement(root.evalNode(<span class=\"string\">\"reflectorFactory\"</span>));</span><br><span class=\"line\">      settingsElement(settings);</span><br><span class=\"line\">      <span class=\"comment\">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class=\"line\">      environmentsElement(root.evalNode(<span class=\"string\">\"environments\"</span>));</span><br><span class=\"line\">      databaseIdProviderElement(root.evalNode(<span class=\"string\">\"databaseIdProvider\"</span>));</span><br><span class=\"line\">      typeHandlerElement(root.evalNode(<span class=\"string\">\"typeHandlers\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 解析 mappers 标签</span></span><br><span class=\"line\">      mapperElement(root.evalNode(<span class=\"string\">\"mappers\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Error parsing SQL Mapper Configuration. Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面需要解析配置的标签比较多，下面只挑选 mappers 标签的解析过程说说。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mapperElement</span><span class=\"params\">(XNode parent)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 循环遍历 parent 的子节点， parent的子节点就是我们配置的 具体mapper文件类似下面这样</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * &lt;mappers&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        *     &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        *     &lt;mapper resource=\"mapper/ClassesMapper.xml\"/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        * &lt;/mappers&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"package\"</span>.equals(child.getName())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取 &lt;package&gt; 节点中的 name 属性</span></span><br><span class=\"line\">          String mapperPackage = child.getStringAttribute(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">          <span class=\"comment\">// 从指定包中查找 mapper 接口，并根据 mapper 接口解析映射配置</span></span><br><span class=\"line\">          configuration.addMappers(mapperPackage);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 我们是配置文件，所以会走这里。获取 resource、url、mapperClass属性</span></span><br><span class=\"line\">          String resource = child.getStringAttribute(<span class=\"string\">\"resource\"</span>);</span><br><span class=\"line\">          String url = child.getStringAttribute(<span class=\"string\">\"url\"</span>);</span><br><span class=\"line\">          String mapperClass = child.getStringAttribute(<span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (resource != <span class=\"keyword\">null</span> &amp;&amp; url == <span class=\"keyword\">null</span> &amp;&amp; mapperClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ErrorContext.instance().resource(resource);</span><br><span class=\"line\">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class=\"line\">            XMLMapperBuilder mapperParser = <span class=\"keyword\">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class=\"line\">            mapperParser.parse();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span> &amp;&amp; url != <span class=\"keyword\">null</span> &amp;&amp; mapperClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ErrorContext.instance().resource(url);</span><br><span class=\"line\">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class=\"line\">            XMLMapperBuilder mapperParser = <span class=\"keyword\">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class=\"line\">            mapperParser.parse();</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span> &amp;&amp; url == <span class=\"keyword\">null</span> &amp;&amp; mapperClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class=\"line\">            configuration.addMapper(mapperInterface);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"A mapper element may only specify a url, resource or class, but not more than one.\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Mac安装MySQL","abbrlink":"ec3b3038","date":"2017-09-16T16:00:00.000Z","_content":"# Mac 安装mysql\n1. 下载dmg文件\n* 双击安装\n* 点击安装完成之后会出现一个提示，上面默认是root用户 和密码。千万要记住。不要一下手快给关掉了。\n\n* 如果不小心关掉了。就需要用终端。\n  ```bash\n  $ cd /usr/local/mysql/bin\n  ```\n* 切换到root权限 ，需要输入密码。\n\n  ```bash\n  $ sudo su\n  ```\n* 输入之后会看见如下信息：\n\n  ```bash\n  sh-3.2#\n  ```\n* 使用如下命令以安全模式运行mysql\n\n  ```bash\n  mysql> ./mysqld_safe --skip-grant-tables &\n  ```\n* 现在从开一个终端:输入:\n\n\t```bash\n    $ mysql -uroot\n   ```\n就可以进入mysql\n* 修改root密码，执行下面的命令。\n\n\t```bash\n    mysql> FLUSH PRIVILEGES;\n   ```\n* 继续执行一下名利修改密码：\n\n\t```bash\n\tmysql> SET PASSWORD FOR root@'localhost' = PASSWORD('new password');\n\t```\n* 到此为止。\n","source":"_posts/Mac-install-mysql .md","raw":"---\ntitle: Mac安装MySQL\ncategory: Mac\ntags:\n  - mac\n  - mysql\nabbrlink: ec3b3038\ndate: 2017-09-17 00:00:00\n---\n# Mac 安装mysql\n1. 下载dmg文件\n* 双击安装\n* 点击安装完成之后会出现一个提示，上面默认是root用户 和密码。千万要记住。不要一下手快给关掉了。\n\n* 如果不小心关掉了。就需要用终端。\n  ```bash\n  $ cd /usr/local/mysql/bin\n  ```\n* 切换到root权限 ，需要输入密码。\n\n  ```bash\n  $ sudo su\n  ```\n* 输入之后会看见如下信息：\n\n  ```bash\n  sh-3.2#\n  ```\n* 使用如下命令以安全模式运行mysql\n\n  ```bash\n  mysql> ./mysqld_safe --skip-grant-tables &\n  ```\n* 现在从开一个终端:输入:\n\n\t```bash\n    $ mysql -uroot\n   ```\n就可以进入mysql\n* 修改root密码，执行下面的命令。\n\n\t```bash\n    mysql> FLUSH PRIVILEGES;\n   ```\n* 继续执行一下名利修改密码：\n\n\t```bash\n\tmysql> SET PASSWORD FOR root@'localhost' = PASSWORD('new password');\n\t```\n* 到此为止。\n","slug":"Mac-install-mysql ","published":1,"updated":"2020-03-12T06:04:25.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpgy0005i3sltdt9iixm","content":"<h1 id=\"Mac-安装mysql\"><a href=\"#Mac-安装mysql\" class=\"headerlink\" title=\"Mac 安装mysql\"></a>Mac 安装mysql</h1><ol>\n<li>下载dmg文件</li>\n</ol>\n<ul>\n<li>双击安装</li>\n<li><p>点击安装完成之后会出现一个提示，上面默认是root用户 和密码。千万要记住。不要一下手快给关掉了。</p>\n</li>\n<li><p>如果不小心关掉了。就需要用终端。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mysql/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换到root权限 ，需要输入密码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo su</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入之后会看见如下信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-3.2<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用如下命令以安全模式运行mysql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; ./mysqld_safe --skip-grant-tables &amp;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在从开一个终端:输入:</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mysql -uroot</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>就可以进入mysql</p>\n<ul>\n<li><p>修改root密码，执行下面的命令。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>继续执行一下名利修改密码：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET PASSWORD FOR root@<span class=\"string\">'localhost'</span> = PASSWORD(<span class=\"string\">'new password'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>到此为止。</p>\n</li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"Mac-安装mysql\"><a href=\"#Mac-安装mysql\" class=\"headerlink\" title=\"Mac 安装mysql\"></a>Mac 安装mysql</h1><ol>\n<li>下载dmg文件</li>\n</ol>\n<ul>\n<li>双击安装</li>\n<li><p>点击安装完成之后会出现一个提示，上面默认是root用户 和密码。千万要记住。不要一下手快给关掉了。</p>\n</li>\n<li><p>如果不小心关掉了。就需要用终端。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mysql/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换到root权限 ，需要输入密码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo su</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入之后会看见如下信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh-3.2<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用如下命令以安全模式运行mysql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; ./mysqld_safe --skip-grant-tables &amp;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在从开一个终端:输入:</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mysql -uroot</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>就可以进入mysql</p>\n<ul>\n<li><p>修改root密码，执行下面的命令。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>继续执行一下名利修改密码：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET PASSWORD FOR root@<span class=\"string\">'localhost'</span> = PASSWORD(<span class=\"string\">'new password'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>到此为止。</p>\n</li>\n</ul>\n"},{"title":"Spring Boot中使用JavaMailSender发送邮件","abbrlink":"126154d6","date":"2018-01-16T16:00:00.000Z","_content":"\n# SpringBoot中使用JavaMailSender发送邮件\n\n## 导入依赖\n在Spring Boot的工程中的 .gradle 中引入spring-boot-starter-mail依赖： 使用gradle\n``` \ncompile group: 'org.springframework.boot', name: 'spring-boot-starter-mail', version: '1.5.9.RELEASE'\n```\n<!-- more -->\n## 配置文件 resource ，使用QQ邮箱为例。\n```\nspring.mail.host: smtp.qq.com \nspring.mail.username: 用户名\nspring.mail.password: 密码  该密码是QQ邮箱的授权码，\nspring.mail.properties.mail.smtp.auth: true\nspring.mail.properties.mail.smtp.starttls.enable: true\nspring.mail.properties.mail.smtp.starttls.required: true\n```\n\n","source":"_posts/Spring Boot-JavaMailSender.md","raw":"---\ntitle: Spring Boot中使用JavaMailSender发送邮件\ncategory: Java\ntags:\n  - java\n  - mail\n  - springboot\nabbrlink: 126154d6\ndate: 2018-01-17 00:00:00\n---\n\n# SpringBoot中使用JavaMailSender发送邮件\n\n## 导入依赖\n在Spring Boot的工程中的 .gradle 中引入spring-boot-starter-mail依赖： 使用gradle\n``` \ncompile group: 'org.springframework.boot', name: 'spring-boot-starter-mail', version: '1.5.9.RELEASE'\n```\n<!-- more -->\n## 配置文件 resource ，使用QQ邮箱为例。\n```\nspring.mail.host: smtp.qq.com \nspring.mail.username: 用户名\nspring.mail.password: 密码  该密码是QQ邮箱的授权码，\nspring.mail.properties.mail.smtp.auth: true\nspring.mail.properties.mail.smtp.starttls.enable: true\nspring.mail.properties.mail.smtp.starttls.required: true\n```\n\n","slug":"Spring Boot-JavaMailSender","published":1,"updated":"2020-03-12T06:04:46.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhph30009i3sl59i2pol6","content":"<h1 id=\"SpringBoot中使用JavaMailSender发送邮件\"><a href=\"#SpringBoot中使用JavaMailSender发送邮件\" class=\"headerlink\" title=\"SpringBoot中使用JavaMailSender发送邮件\"></a>SpringBoot中使用JavaMailSender发送邮件</h1><h2 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h2><p>在Spring Boot的工程中的 .gradle 中引入spring-boot-starter-mail依赖： 使用gradle<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-mail&apos;, version: &apos;1.5.9.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"配置文件-resource-，使用QQ邮箱为例。\"><a href=\"#配置文件-resource-，使用QQ邮箱为例。\" class=\"headerlink\" title=\"配置文件 resource ，使用QQ邮箱为例。\"></a>配置文件 resource ，使用QQ邮箱为例。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.mail.host: smtp.qq.com </span><br><span class=\"line\">spring.mail.username: 用户名</span><br><span class=\"line\">spring.mail.password: 密码  该密码是QQ邮箱的授权码，</span><br><span class=\"line\">spring.mail.properties.mail.smtp.auth: true</span><br><span class=\"line\">spring.mail.properties.mail.smtp.starttls.enable: true</span><br><span class=\"line\">spring.mail.properties.mail.smtp.starttls.required: true</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"<h1 id=\"SpringBoot中使用JavaMailSender发送邮件\"><a href=\"#SpringBoot中使用JavaMailSender发送邮件\" class=\"headerlink\" title=\"SpringBoot中使用JavaMailSender发送邮件\"></a>SpringBoot中使用JavaMailSender发送邮件</h1><h2 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h2><p>在Spring Boot的工程中的 .gradle 中引入spring-boot-starter-mail依赖： 使用gradle<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-mail&apos;, version: &apos;1.5.9.RELEASE&apos;</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"配置文件-resource-，使用QQ邮箱为例。\"><a href=\"#配置文件-resource-，使用QQ邮箱为例。\" class=\"headerlink\" title=\"配置文件 resource ，使用QQ邮箱为例。\"></a>配置文件 resource ，使用QQ邮箱为例。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.mail.host: smtp.qq.com </span><br><span class=\"line\">spring.mail.username: 用户名</span><br><span class=\"line\">spring.mail.password: 密码  该密码是QQ邮箱的授权码，</span><br><span class=\"line\">spring.mail.properties.mail.smtp.auth: true</span><br><span class=\"line\">spring.mail.properties.mail.smtp.starttls.enable: true</span><br><span class=\"line\">spring.mail.properties.mail.smtp.starttls.required: true</span><br></pre></td></tr></table></figure>"},{"title":"Mac安装nodejs","abbrlink":"d038576f","date":"2017-09-18T16:00:00.000Z","_content":"# Mac 安装node js\n## setp 1:\n* 访问nodejs官网，下载稳定版 <https://nodejs.org/en/> \n* 也可以使用 homebrew 安装，执行命令：\n\t```bash\n$ brew install node\n```\n\n## setp 2:\n* 测试是否安装成功 ，执行 :\n\n\t```bash\n$ node -v\n```\n\n\n","source":"_posts/Mac-installnode js.md","raw":"---\ntitle: Mac安装nodejs\ncategory: Web\ntags:\n  - mac\n  - nodejs\nabbrlink: d038576f\ndate: 2017-09-19 00:00:00\n---\n# Mac 安装node js\n## setp 1:\n* 访问nodejs官网，下载稳定版 <https://nodejs.org/en/> \n* 也可以使用 homebrew 安装，执行命令：\n\t```bash\n$ brew install node\n```\n\n## setp 2:\n* 测试是否安装成功 ，执行 :\n\n\t```bash\n$ node -v\n```\n\n\n","slug":"Mac-installnode js","published":1,"updated":"2020-03-12T06:04:33.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhph3000ai3slfzpawuwl","content":"<h1 id=\"Mac-安装node-js\"><a href=\"#Mac-安装node-js\" class=\"headerlink\" title=\"Mac 安装node js\"></a>Mac 安装node js</h1><h2 id=\"setp-1\"><a href=\"#setp-1\" class=\"headerlink\" title=\"setp 1:\"></a>setp 1:</h2><ul>\n<li>访问nodejs官网，下载稳定版 <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a> </li>\n<li>也可以使用 homebrew 安装，执行命令：  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install node</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"setp-2\"><a href=\"#setp-2\" class=\"headerlink\" title=\"setp 2:\"></a>setp 2:</h2><ul>\n<li><p>测试是否安装成功 ，执行 :</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"Mac-安装node-js\"><a href=\"#Mac-安装node-js\" class=\"headerlink\" title=\"Mac 安装node js\"></a>Mac 安装node js</h1><h2 id=\"setp-1\"><a href=\"#setp-1\" class=\"headerlink\" title=\"setp 1:\"></a>setp 1:</h2><ul>\n<li>访问nodejs官网，下载稳定版 <a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a> </li>\n<li>也可以使用 homebrew 安装，执行命令：  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install node</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"setp-2\"><a href=\"#setp-2\" class=\"headerlink\" title=\"setp 2:\"></a>setp 2:</h2><ul>\n<li><p>测试是否安装成功 ，执行 :</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"JDK8源码学习：ArrayList 源码解析","abbrlink":"9e8769e6","date":"2018-02-10T16:00:00.000Z","_content":"# 概述\n* 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。\n* 按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。\n\n* 如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。\n\n* 越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。\n\n# 类结构\nArrayList是Java集合框架List接口的实现类，\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n       // 省略\n}\n```\n\n通过代码我们看出，ArrayList继承AbstractList方法，并且在实现了List方法的同时，还实现了RandomAccess、Cloneable（克隆）、Serializable（序列化）；\nArrayList类图如下所示：\n![](http://qxu1146470209.my3w.com/wordpress/wp-content/uploads/2018/02/49feecd1bc989fa98b6aad419ea8db21.png)\n\n# 源码分析\n\n## 变量定义\n```java\n\t/**\n\t* 默认初始化容量大小为10\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n    /**\n     * 共用的数组实例用于空的实例\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 默认大小的空实例所用的共用的数组实例。我们判断当一个元素被加入时数组实例该怎样扩大\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * elementData存储ArrayList内的元素\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * 存储在ArrayList内的容量大小\n     *\n     * @serial\n     */\n    private int size;\n```\n### 构造方法\n```java\n\t/**\n     * 构造一个空的集合，并规定初始化容量\n     * @param  initialCapacity  该集合需要初始化的容量\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n\t\t\t// 新建一个规定大小容量的集合赋值给 elementData\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n\t\t\t// 空的集合赋给 elementData\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n\t\t\t// 传入变量 非法，抛出异常。\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *  构造一个空的集合并初始化容量为10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定元素的集合，按集合的顺序返回使用迭代器。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array. 替换为空\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n###  添加方法 add()\n```java\n\t/**\n     * 添加规定的根元素到集合的最后\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n```\n在add之前会调用ensureCapacityInternal()方法，判断是否需要扩容\n```java\n\tprivate void ensureCapacityInternal(int minCapacity) {\n\t\t// 如果elementData 为空 ，指定elementData的最小默认容量。如果为第一次添加，默认容量为10\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        ensureExplicitCapacity(minCapacity);\n    }\n\tprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // overflow-conscious code 如容量不足，进行扩容。\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n   /**\n     * 增加容量，确保至少可以支持最小规定元素的数量\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n* 从grow方法中可以看出，ArrayList的elementData数组如遇到容量不足时，将会把新容量newCapacity设置为 oldCapacity + (oldCapacity >> 1)。二进制位操作>> 1等同于/2的效果，扩容导致的newCapacity也就设置为原先的1.5倍。\n* 如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity。不过这种情况一般不会用到，很少会用到这么大的ArrayList。\n* 在确保有容量的情况下，会将元素添加至elementData数组中。\n\n### 移除方法 remove()\n```java\n\t/**\n     * 删除列表中指定的元素 并将index 后面的元素移动位置\n     */\n    public E remove(int index) {\n\t//判断index 是否在 list大小范围之内\n        rangeCheck(index);\n\n        modCount++;\n\t\t// 根据index 取出需要移除的数据 赋值oldValue\n        E oldValue = elementData(index);\n\t\t// 需要移动的大小\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n```\n* 该方法是根据元素位置移除列表数据，首先判断index是否在列表元素的范围之内，将需要移除的数据，赋值给oldvalue存储，计算出该元素之后的列表数量，使用System.arraycopy()方法，该方法的作用是：从指定的源数组中复制一个数组，从指定的位置，到目标数组的指定位置。返回oldValue;\n","source":"_posts/arraylist-source.md","raw":"---\ntitle: JDK8源码学习：ArrayList 源码解析\ncategory: Java相关\ntags:\n  - java\nabbrlink: 9e8769e6\ndate: 2018-02-11 00:00:00\n---\n# 概述\n* 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。\n* 按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。\n\n* 如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。\n\n* 越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。\n\n# 类结构\nArrayList是Java集合框架List接口的实现类，\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n       // 省略\n}\n```\n\n通过代码我们看出，ArrayList继承AbstractList方法，并且在实现了List方法的同时，还实现了RandomAccess、Cloneable（克隆）、Serializable（序列化）；\nArrayList类图如下所示：\n![](http://qxu1146470209.my3w.com/wordpress/wp-content/uploads/2018/02/49feecd1bc989fa98b6aad419ea8db21.png)\n\n# 源码分析\n\n## 变量定义\n```java\n\t/**\n\t* 默认初始化容量大小为10\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n    /**\n     * 共用的数组实例用于空的实例\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 默认大小的空实例所用的共用的数组实例。我们判断当一个元素被加入时数组实例该怎样扩大\n     */\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * elementData存储ArrayList内的元素\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * 存储在ArrayList内的容量大小\n     *\n     * @serial\n     */\n    private int size;\n```\n### 构造方法\n```java\n\t/**\n     * 构造一个空的集合，并规定初始化容量\n     * @param  initialCapacity  该集合需要初始化的容量\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n\t\t\t// 新建一个规定大小容量的集合赋值给 elementData\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n\t\t\t// 空的集合赋给 elementData\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n\t\t\t// 传入变量 非法，抛出异常。\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *  构造一个空的集合并初始化容量为10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定元素的集合，按集合的顺序返回使用迭代器。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array. 替换为空\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n###  添加方法 add()\n```java\n\t/**\n     * 添加规定的根元素到集合的最后\n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n```\n在add之前会调用ensureCapacityInternal()方法，判断是否需要扩容\n```java\n\tprivate void ensureCapacityInternal(int minCapacity) {\n\t\t// 如果elementData 为空 ，指定elementData的最小默认容量。如果为第一次添加，默认容量为10\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n        ensureExplicitCapacity(minCapacity);\n    }\n\tprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // overflow-conscious code 如容量不足，进行扩容。\n        if (minCapacity - elementData.length > 0)\n            grow(minCapacity);\n    }\n   /**\n     * 增加容量，确保至少可以支持最小规定元素的数量\n     */\n    private void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n* 从grow方法中可以看出，ArrayList的elementData数组如遇到容量不足时，将会把新容量newCapacity设置为 oldCapacity + (oldCapacity >> 1)。二进制位操作>> 1等同于/2的效果，扩容导致的newCapacity也就设置为原先的1.5倍。\n* 如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity。不过这种情况一般不会用到，很少会用到这么大的ArrayList。\n* 在确保有容量的情况下，会将元素添加至elementData数组中。\n\n### 移除方法 remove()\n```java\n\t/**\n     * 删除列表中指定的元素 并将index 后面的元素移动位置\n     */\n    public E remove(int index) {\n\t//判断index 是否在 list大小范围之内\n        rangeCheck(index);\n\n        modCount++;\n\t\t// 根据index 取出需要移除的数据 赋值oldValue\n        E oldValue = elementData(index);\n\t\t// 需要移动的大小\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n```\n* 该方法是根据元素位置移除列表数据，首先判断index是否在列表元素的范围之内，将需要移除的数据，赋值给oldvalue存储，计算出该元素之后的列表数量，使用System.arraycopy()方法，该方法的作用是：从指定的源数组中复制一个数组，从指定的位置，到目标数组的指定位置。返回oldValue;\n","slug":"arraylist-source","published":1,"updated":"2019-12-23T10:59:48.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhph5000bi3slyd9wwyuq","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</li>\n<li><p>按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。</p>\n</li>\n<li><p>如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。</p>\n</li>\n<li><p>越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。</p>\n</li>\n</ul>\n<h1 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h1><p>ArrayList是Java集合框架List接口的实现类，<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过代码我们看出，ArrayList继承AbstractList方法，并且在实现了List方法的同时，还实现了RandomAccess、Cloneable（克隆）、Serializable（序列化）；<br>ArrayList类图如下所示：<br><img src=\"http://qxu1146470209.my3w.com/wordpress/wp-content/uploads/2018/02/49feecd1bc989fa98b6aad419ea8db21.png\" alt></p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 默认初始化容量大小为10</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 共用的数组实例用于空的实例</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 默认大小的空实例所用的共用的数组实例。我们判断当一个元素被加入时数组实例该怎样扩大</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * elementData存储ArrayList内的元素</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 存储在ArrayList内的容量大小</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 构造一个空的集合，并规定初始化容量</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span>  initialCapacity  该集合需要初始化的容量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新建一个规定大小容量的集合赋值给 elementData</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 空的集合赋给 elementData</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 传入变量 非法，抛出异常。</span></span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                              initialCapacity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  构造一个空的集合并初始化容量为10</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 构造一个包含指定元素的集合，按集合的顺序返回使用迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">       elementData = c.toArray();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// replace with empty array. 替换为空</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加方法-add\"><a href=\"#添加方法-add\" class=\"headerlink\" title=\"添加方法 add()\"></a>添加方法 add()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 添加规定的根元素到集合的最后</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">       ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">       elementData[size++] = e;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在add之前会调用ensureCapacityInternal()方法，判断是否需要扩容<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果elementData 为空 ，指定elementData的最小默认容量。如果为第一次添加，默认容量为10</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">       modCount++;</span><br><span class=\"line\">       <span class=\"comment\">// overflow-conscious code 如容量不足，进行扩容。</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           grow(minCapacity);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 增加容量，确保至少可以支持最小规定元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           newCapacity = minCapacity;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">       <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>从grow方法中可以看出，ArrayList的elementData数组如遇到容量不足时，将会把新容量newCapacity设置为 oldCapacity + (oldCapacity &gt;&gt; 1)。二进制位操作&gt;&gt; 1等同于/2的效果，扩容导致的newCapacity也就设置为原先的1.5倍。</li>\n<li>如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity。不过这种情况一般不会用到，很少会用到这么大的ArrayList。</li>\n<li>在确保有容量的情况下，会将元素添加至elementData数组中。</li>\n</ul>\n<h3 id=\"移除方法-remove\"><a href=\"#移除方法-remove\" class=\"headerlink\" title=\"移除方法 remove()\"></a>移除方法 remove()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 删除列表中指定的元素 并将index 后面的元素移动位置</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//判断index 是否在 list大小范围之内</span></span><br><span class=\"line\">       rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">       modCount++;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据index 取出需要移除的数据 赋值oldValue</span></span><br><span class=\"line\">       E oldValue = elementData(index);</span><br><span class=\"line\">\t<span class=\"comment\">// 需要移动的大小</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                            numMoved);</span><br><span class=\"line\">       elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该方法是根据元素位置移除列表数据，首先判断index是否在列表元素的范围之内，将需要移除的数据，赋值给oldvalue存储，计算出该元素之后的列表数量，使用System.arraycopy()方法，该方法的作用是：从指定的源数组中复制一个数组，从指定的位置，到目标数组的指定位置。返回oldValue;</li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy（）复制到新的数组。因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</li>\n<li><p>按数组下标访问元素－get（i）、set（i,e） 的性能很高，这是数组的基本优势。</p>\n</li>\n<li><p>如果按下标插入元素、删除元素－add（i,e）、 remove（i）、remove（e），则要用System.arraycopy（）来复制移动部分受影响的元素，性能就变差了。</p>\n</li>\n<li><p>越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素－常用的add（e），删除最后一个元素则无影响。</p>\n</li>\n</ul>\n<h1 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h1><p>ArrayList是Java集合框架List接口的实现类，<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过代码我们看出，ArrayList继承AbstractList方法，并且在实现了List方法的同时，还实现了RandomAccess、Cloneable（克隆）、Serializable（序列化）；<br>ArrayList类图如下所示：<br><img src=\"http://qxu1146470209.my3w.com/wordpress/wp-content/uploads/2018/02/49feecd1bc989fa98b6aad419ea8db21.png\" alt></p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 默认初始化容量大小为10</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 共用的数组实例用于空的实例</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 默认大小的空实例所用的共用的数组实例。我们判断当一个元素被加入时数组实例该怎样扩大</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * elementData存储ArrayList内的元素</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 存储在ArrayList内的容量大小</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 构造一个空的集合，并规定初始化容量</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span>  initialCapacity  该集合需要初始化的容量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新建一个规定大小容量的集合赋值给 elementData</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 空的集合赋给 elementData</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 传入变量 非法，抛出异常。</span></span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                              initialCapacity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  构造一个空的集合并初始化容量为10</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 构造一个包含指定元素的集合，按集合的顺序返回使用迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">       elementData = c.toArray();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// replace with empty array. 替换为空</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加方法-add\"><a href=\"#添加方法-add\" class=\"headerlink\" title=\"添加方法 add()\"></a>添加方法 add()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 添加规定的根元素到集合的最后</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">       ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">       elementData[size++] = e;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在add之前会调用ensureCapacityInternal()方法，判断是否需要扩容<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果elementData 为空 ，指定elementData的最小默认容量。如果为第一次添加，默认容量为10</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">       modCount++;</span><br><span class=\"line\">       <span class=\"comment\">// overflow-conscious code 如容量不足，进行扩容。</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           grow(minCapacity);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 增加容量，确保至少可以支持最小规定元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           newCapacity = minCapacity;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">       <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>从grow方法中可以看出，ArrayList的elementData数组如遇到容量不足时，将会把新容量newCapacity设置为 oldCapacity + (oldCapacity &gt;&gt; 1)。二进制位操作&gt;&gt; 1等同于/2的效果，扩容导致的newCapacity也就设置为原先的1.5倍。</li>\n<li>如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity。不过这种情况一般不会用到，很少会用到这么大的ArrayList。</li>\n<li>在确保有容量的情况下，会将元素添加至elementData数组中。</li>\n</ul>\n<h3 id=\"移除方法-remove\"><a href=\"#移除方法-remove\" class=\"headerlink\" title=\"移除方法 remove()\"></a>移除方法 remove()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 删除列表中指定的元素 并将index 后面的元素移动位置</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//判断index 是否在 list大小范围之内</span></span><br><span class=\"line\">       rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">       modCount++;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据index 取出需要移除的数据 赋值oldValue</span></span><br><span class=\"line\">       E oldValue = elementData(index);</span><br><span class=\"line\">\t<span class=\"comment\">// 需要移动的大小</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">           System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                            numMoved);</span><br><span class=\"line\">       elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该方法是根据元素位置移除列表数据，首先判断index是否在列表元素的范围之内，将需要移除的数据，赋值给oldvalue存储，计算出该元素之后的列表数量，使用System.arraycopy()方法，该方法的作用是：从指定的源数组中复制一个数组，从指定的位置，到目标数组的指定位置。返回oldValue;</li>\n</ul>\n"},{"title":"剑指offer——最小的K个数（java版本）","abbrlink":"cb7b911e","date":"2018-10-11T08:16:58.000Z","_content":">最小的K个数\n[牛客网——最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)\n## 题目描述\n输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。\n## 解题思路\n### 全排序\n>先排序，接着找出最小的K个数。时间复制度为O(n*n)。\n\n```java\npublic ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {\n    if (input.length < k)\n        return new ArrayList<>();\n    int len = input.length;\n    for (int i = 0; i < len; i++) {\n        for (int j = 0; j < len-1; j ++){\n            if (input[j] > input[j+1]) {\n                int temp = input[j];\n                input[j] = input[j+1];\n                input[j+1] = temp;\n            }\n        }\n    }\n    ArrayList<Integer> result = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        result.add(input[i]);\n    }\n    return result;\n}\n```\n对于这种解法，是可以优化的，我只需K个数，说明我可以只对K个长度排序，不全排序。对于这种解法，可以叫做局部排序，时间复杂度O(n*k)。\n\n### 堆\n> 先用当前K个元素生存一个大顶堆，这个堆用于存储当前最小的k个元素。接着，从第k+1个元素开始扫描，和堆中最大的元素比较，如果被扫描的元素小于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最小的k个元素。\n> 时间复制度：O(n*lg(k))\n\n```java\npublic ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {\n    if (k > nums.length || k <= 0)\n        return new ArrayList<>();\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);\n    for (int num : nums) {\n        maxHeap.add(num);\n        if (maxHeap.size() > k)\n            maxHeap.poll();\n    }\n    return new ArrayList<>(maxHeap);\n}\n```\n\n\n","source":"_posts/codeinterview-minimum-k-number.md","raw":"---\ntitle: 剑指offer——最小的K个数（java版本）\ncategory: 算法\ntags: '-剑指offer'\nabbrlink: cb7b911e\ndate: 2018-10-11 16:16:58\n---\n>最小的K个数\n[牛客网——最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)\n## 题目描述\n输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。\n## 解题思路\n### 全排序\n>先排序，接着找出最小的K个数。时间复制度为O(n*n)。\n\n```java\npublic ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {\n    if (input.length < k)\n        return new ArrayList<>();\n    int len = input.length;\n    for (int i = 0; i < len; i++) {\n        for (int j = 0; j < len-1; j ++){\n            if (input[j] > input[j+1]) {\n                int temp = input[j];\n                input[j] = input[j+1];\n                input[j+1] = temp;\n            }\n        }\n    }\n    ArrayList<Integer> result = new ArrayList<>();\n    for (int i = 0; i < k; i++) {\n        result.add(input[i]);\n    }\n    return result;\n}\n```\n对于这种解法，是可以优化的，我只需K个数，说明我可以只对K个长度排序，不全排序。对于这种解法，可以叫做局部排序，时间复杂度O(n*k)。\n\n### 堆\n> 先用当前K个元素生存一个大顶堆，这个堆用于存储当前最小的k个元素。接着，从第k+1个元素开始扫描，和堆中最大的元素比较，如果被扫描的元素小于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最小的k个元素。\n> 时间复制度：O(n*lg(k))\n\n```java\npublic ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {\n    if (k > nums.length || k <= 0)\n        return new ArrayList<>();\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);\n    for (int num : nums) {\n        maxHeap.add(num);\n        if (maxHeap.size() > k)\n            maxHeap.poll();\n    }\n    return new ArrayList<>(maxHeap);\n}\n```\n\n\n","slug":"codeinterview-minimum-k-number","published":1,"updated":"2019-12-23T10:59:48.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhph7000fi3sl8qaoy606","content":"<blockquote>\n<p>最小的K个数<br><a href=\"https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网——最小的K个数</a></p>\n</blockquote>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"全排序\"><a href=\"#全排序\" class=\"headerlink\" title=\"全排序\"></a>全排序</h3><blockquote>\n<p>先排序，接着找出最小的K个数。时间复制度为O(n*n)。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">GetLeastNumbers_Solution</span><span class=\"params\">(<span class=\"keyword\">int</span> [] input, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input.length &lt; k)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = input.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len-<span class=\"number\">1</span>; j ++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input[j] &gt; input[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = input[j];</span><br><span class=\"line\">                input[j] = input[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                input[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        result.add(input[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种解法，是可以优化的，我只需K个数，说明我可以只对K个长度排序，不全排序。对于这种解法，可以叫做局部排序，时间复杂度O(n*k)。</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><blockquote>\n<p>先用当前K个元素生存一个大顶堆，这个堆用于存储当前最小的k个元素。接着，从第k+1个元素开始扫描，和堆中最大的元素比较，如果被扫描的元素小于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最小的k个元素。<br>时间复制度：O(n*lg(k))</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">GetLeastNumbers_Solution</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; nums.length || k &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; maxHeap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">        maxHeap.add(num);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxHeap.size() &gt; k)</span><br><span class=\"line\">            maxHeap.poll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<blockquote>\n<p>最小的K个数<br><a href=\"https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网——最小的K个数</a></p>\n</blockquote>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"全排序\"><a href=\"#全排序\" class=\"headerlink\" title=\"全排序\"></a>全排序</h3><blockquote>\n<p>先排序，接着找出最小的K个数。时间复制度为O(n*n)。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">GetLeastNumbers_Solution</span><span class=\"params\">(<span class=\"keyword\">int</span> [] input, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input.length &lt; k)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = input.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len-<span class=\"number\">1</span>; j ++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input[j] &gt; input[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = input[j];</span><br><span class=\"line\">                input[j] = input[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                input[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">        result.add(input[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这种解法，是可以优化的，我只需K个数，说明我可以只对K个长度排序，不全排序。对于这种解法，可以叫做局部排序，时间复杂度O(n*k)。</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><blockquote>\n<p>先用当前K个元素生存一个大顶堆，这个堆用于存储当前最小的k个元素。接着，从第k+1个元素开始扫描，和堆中最大的元素比较，如果被扫描的元素小于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最小的k个元素。<br>时间复制度：O(n*lg(k))</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">GetLeastNumbers_Solution</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &gt; nums.length || k &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; maxHeap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">        maxHeap.add(num);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxHeap.size() &gt; k)</span><br><span class=\"line\">            maxHeap.poll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"剑指offer——栈的压入、弹出序列（java版本）","abbrlink":"47c61732","date":"2018-10-11T08:19:28.000Z","_content":">栈的压入、弹出序列\n[牛客网——栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)\n## 题目描述\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n## 思路\n使用一个栈来模拟压入、弹出操作。依次将第一个数组pushA压入栈，压入之后比对第二个数组popA，判断是否需要弹出。如果pushA已经全部入栈，但是stack却没有弹出完。说明不是一个弹出序列。\n## 实现\n\n```java\npublic boolean IsPopOrder(int [] pushA,int [] popA) {\n    if (pushA == null || pushA.length == 0) {\n        return true;\n    }\n    Stack<Integer> stack = new Stack<>();\n    int len = pushA.length;\n    for (int i = 0, popIndex = 0; i < len; i++) {\n        stack.push(pushA[i]); // 依次入栈\n        // 栈顶元素和popA[popIndex]比较，判断是否需要弹出。\n        while (i < len && !stack.isEmpty() && stack.peek() == popA[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n    return stack.isEmpty();\n}\n```","source":"_posts/codeinterview-stack-push-pop.md","raw":"---\ntitle: 剑指offer——栈的压入、弹出序列（java版本）\ncategory: 算法\ntags: '-剑指offer'\nabbrlink: 47c61732\ndate: 2018-10-11 16:19:28\n---\n>栈的压入、弹出序列\n[牛客网——栈的压入、弹出序列](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)\n## 题目描述\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n## 思路\n使用一个栈来模拟压入、弹出操作。依次将第一个数组pushA压入栈，压入之后比对第二个数组popA，判断是否需要弹出。如果pushA已经全部入栈，但是stack却没有弹出完。说明不是一个弹出序列。\n## 实现\n\n```java\npublic boolean IsPopOrder(int [] pushA,int [] popA) {\n    if (pushA == null || pushA.length == 0) {\n        return true;\n    }\n    Stack<Integer> stack = new Stack<>();\n    int len = pushA.length;\n    for (int i = 0, popIndex = 0; i < len; i++) {\n        stack.push(pushA[i]); // 依次入栈\n        // 栈顶元素和popA[popIndex]比较，判断是否需要弹出。\n        while (i < len && !stack.isEmpty() && stack.peek() == popA[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n    return stack.isEmpty();\n}\n```","slug":"codeinterview-stack-push-pop","published":1,"updated":"2019-12-23T10:59:48.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhph8000gi3sl9zr5do7m","content":"<blockquote>\n<p>栈的压入、弹出序列<br><a href=\"https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网——栈的压入、弹出序列</a></p>\n</blockquote>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用一个栈来模拟压入、弹出操作。依次将第一个数组pushA压入栈，压入之后比对第二个数组popA，判断是否需要弹出。如果pushA已经全部入栈，但是stack却没有弹出完。说明不是一个弹出序列。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">IsPopOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> [] pushA,<span class=\"keyword\">int</span> [] popA)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pushA == <span class=\"keyword\">null</span> || pushA.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pushA.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, popIndex = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        stack.push(pushA[i]); <span class=\"comment\">// 依次入栈</span></span><br><span class=\"line\">        <span class=\"comment\">// 栈顶元素和popA[popIndex]比较，判断是否需要弹出。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popA[popIndex]) &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">            popIndex++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack.isEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"variables":""}},"excerpt":"","more":"<blockquote>\n<p>栈的压入、弹出序列<br><a href=\"https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\" target=\"_blank\" rel=\"noopener\">牛客网——栈的压入、弹出序列</a></p>\n</blockquote>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>使用一个栈来模拟压入、弹出操作。依次将第一个数组pushA压入栈，压入之后比对第二个数组popA，判断是否需要弹出。如果pushA已经全部入栈，但是stack却没有弹出完。说明不是一个弹出序列。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">IsPopOrder</span><span class=\"params\">(<span class=\"keyword\">int</span> [] pushA,<span class=\"keyword\">int</span> [] popA)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pushA == <span class=\"keyword\">null</span> || pushA.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pushA.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, popIndex = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        stack.push(pushA[i]); <span class=\"comment\">// 依次入栈</span></span><br><span class=\"line\">        <span class=\"comment\">// 栈顶元素和popA[popIndex]比较，判断是否需要弹出。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popA[popIndex]) &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">            popIndex++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack.isEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"exchange邮箱类型使用Java发送邮件","abbrlink":"b3686e94","date":"2018-02-10T16:00:00.000Z","_content":"# 需求\n使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。\n# 添加dependencie\n使用gradle，代码如下：\n```groovy\ncompile 'com.microsoft.ews-java-api:ews-java-api:2.0'\n```\n使用maven，代码如下：\n```xml\n<dependency>\n\t<groupId>com.microsoft.ews-java-api</groupId>\n\t<artifactId>ews-java-api</artifactId>\n\t<version>2.0</version>\n</dependency>\n```\n或者直接导入`ews-java-api-2.0.jar`包\n\n# 实现\n```java\npackage com.myluffy.springboot.chapter33;\n\nimport microsoft.exchange.webservices.data.core.ExchangeService;\nimport microsoft.exchange.webservices.data.core.enumeration.misc.ExchangeVersion;\nimport microsoft.exchange.webservices.data.core.enumeration.property.BodyType;\nimport microsoft.exchange.webservices.data.core.service.item.EmailMessage;\nimport microsoft.exchange.webservices.data.credential.ExchangeCredentials;\nimport microsoft.exchange.webservices.data.credential.WebCredentials;\nimport microsoft.exchange.webservices.data.property.complex.MessageBody;\n\nimport java.net.URI;\n\n\npublic class ExchangeSendMail {\n    public void sendMail() throws Exception{\n        ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2010_SP1);\n        ExchangeCredentials credentials = new WebCredentials(\"username\", \"password\");\n        service.setCredentials(credentials);\n        // outlook.com 改为自己的邮箱服务器地址\n        service.setUrl(new URI(\"https://outlook.com/EWS/Exchange.asmx\"));\n        EmailMessage msg = new EmailMessage(service);\n        // 主题\n        msg.setSubject(\"subject\");\n        // 内容\n        // MessageBody 默认是发送html格式的内容\n        MessageBody content = new MessageBody(BodyType.Text, \"content\");\n        msg.setBody(content);\n//        msg.setBody(MessageBody.getMessageBodyFromText(\"content\")); // 内容为html格式\n        // 收件人\n        msg.getToRecipients().add(\"xx@gmail.com\");\n        // 抄送人\n        msg.getCcRecipients().add(\"xx2@gmail.com\");\n        // 暗送\n        msg.getBccRecipients().add(\"xx3@gmail.com\");\n        // 附件\n        msg.getAttachments().addFileAttachment(\"/Users/xx/Downloads/demo.text\");\n        msg.send();\n    }\n}\n\n```\n如有问题，可联系我。\n\n参考文档\n[ews-java-api](https://github.com/OfficeDev/ews-java-api/wiki/Getting-Started-Guide \"ews-java-api\")","source":"_posts/exchange-send-mail-java.md","raw":"---\ntitle: exchange邮箱类型使用Java发送邮件\ncategory: 技术\ntags:\n  - java\nabbrlink: b3686e94\ndate: 2018-02-11 00:00:00\n---\n# 需求\n使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。\n# 添加dependencie\n使用gradle，代码如下：\n```groovy\ncompile 'com.microsoft.ews-java-api:ews-java-api:2.0'\n```\n使用maven，代码如下：\n```xml\n<dependency>\n\t<groupId>com.microsoft.ews-java-api</groupId>\n\t<artifactId>ews-java-api</artifactId>\n\t<version>2.0</version>\n</dependency>\n```\n或者直接导入`ews-java-api-2.0.jar`包\n\n# 实现\n```java\npackage com.myluffy.springboot.chapter33;\n\nimport microsoft.exchange.webservices.data.core.ExchangeService;\nimport microsoft.exchange.webservices.data.core.enumeration.misc.ExchangeVersion;\nimport microsoft.exchange.webservices.data.core.enumeration.property.BodyType;\nimport microsoft.exchange.webservices.data.core.service.item.EmailMessage;\nimport microsoft.exchange.webservices.data.credential.ExchangeCredentials;\nimport microsoft.exchange.webservices.data.credential.WebCredentials;\nimport microsoft.exchange.webservices.data.property.complex.MessageBody;\n\nimport java.net.URI;\n\n\npublic class ExchangeSendMail {\n    public void sendMail() throws Exception{\n        ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2010_SP1);\n        ExchangeCredentials credentials = new WebCredentials(\"username\", \"password\");\n        service.setCredentials(credentials);\n        // outlook.com 改为自己的邮箱服务器地址\n        service.setUrl(new URI(\"https://outlook.com/EWS/Exchange.asmx\"));\n        EmailMessage msg = new EmailMessage(service);\n        // 主题\n        msg.setSubject(\"subject\");\n        // 内容\n        // MessageBody 默认是发送html格式的内容\n        MessageBody content = new MessageBody(BodyType.Text, \"content\");\n        msg.setBody(content);\n//        msg.setBody(MessageBody.getMessageBodyFromText(\"content\")); // 内容为html格式\n        // 收件人\n        msg.getToRecipients().add(\"xx@gmail.com\");\n        // 抄送人\n        msg.getCcRecipients().add(\"xx2@gmail.com\");\n        // 暗送\n        msg.getBccRecipients().add(\"xx3@gmail.com\");\n        // 附件\n        msg.getAttachments().addFileAttachment(\"/Users/xx/Downloads/demo.text\");\n        msg.send();\n    }\n}\n\n```\n如有问题，可联系我。\n\n参考文档\n[ews-java-api](https://github.com/OfficeDev/ews-java-api/wiki/Getting-Started-Guide \"ews-java-api\")","slug":"exchange-send-mail-java","published":1,"updated":"2019-12-23T10:59:48.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhph9000ki3slwwf6uhul","content":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。</p>\n<h1 id=\"添加dependencie\"><a href=\"#添加dependencie\" class=\"headerlink\" title=\"添加dependencie\"></a>添加dependencie</h1><p>使用gradle，代码如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">'com.microsoft.ews-java-api:ews-java-api:2.0'</span></span><br></pre></td></tr></table></figure></p>\n<p>使用maven，代码如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.microsoft.ews-java-api<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ews-java-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者直接导入<code>ews-java-api-2.0.jar</code>包</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.myluffy.springboot.chapter33;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.ExchangeService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.enumeration.misc.ExchangeVersion;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.enumeration.property.BodyType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.service.item.EmailMessage;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.credential.ExchangeCredentials;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.credential.WebCredentials;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.property.complex.MessageBody;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URI;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangeSendMail</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        ExchangeService service = <span class=\"keyword\">new</span> ExchangeService(ExchangeVersion.Exchange2010_SP1);</span><br><span class=\"line\">        ExchangeCredentials credentials = <span class=\"keyword\">new</span> WebCredentials(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">        service.setCredentials(credentials);</span><br><span class=\"line\">        <span class=\"comment\">// outlook.com 改为自己的邮箱服务器地址</span></span><br><span class=\"line\">        service.setUrl(<span class=\"keyword\">new</span> URI(<span class=\"string\">\"https://outlook.com/EWS/Exchange.asmx\"</span>));</span><br><span class=\"line\">        EmailMessage msg = <span class=\"keyword\">new</span> EmailMessage(service);</span><br><span class=\"line\">        <span class=\"comment\">// 主题</span></span><br><span class=\"line\">        msg.setSubject(<span class=\"string\">\"subject\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 内容</span></span><br><span class=\"line\">        <span class=\"comment\">// MessageBody 默认是发送html格式的内容</span></span><br><span class=\"line\">        MessageBody content = <span class=\"keyword\">new</span> MessageBody(BodyType.Text, <span class=\"string\">\"content\"</span>);</span><br><span class=\"line\">        msg.setBody(content);</span><br><span class=\"line\"><span class=\"comment\">//        msg.setBody(MessageBody.getMessageBodyFromText(\"content\")); // 内容为html格式</span></span><br><span class=\"line\">        <span class=\"comment\">// 收件人</span></span><br><span class=\"line\">        msg.getToRecipients().add(<span class=\"string\">\"xx@gmail.com\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 抄送人</span></span><br><span class=\"line\">        msg.getCcRecipients().add(<span class=\"string\">\"xx2@gmail.com\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 暗送</span></span><br><span class=\"line\">        msg.getBccRecipients().add(<span class=\"string\">\"xx3@gmail.com\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 附件</span></span><br><span class=\"line\">        msg.getAttachments().addFileAttachment(<span class=\"string\">\"/Users/xx/Downloads/demo.text\"</span>);</span><br><span class=\"line\">        msg.send();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如有问题，可联系我。</p>\n<p>参考文档<br><a href=\"https://github.com/OfficeDev/ews-java-api/wiki/Getting-Started-Guide\" title=\"ews-java-api\" target=\"_blank\" rel=\"noopener\">ews-java-api</a></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>使用Java实现自动发送exchange类型邮箱的功能，本文不会使用SMTP。</p>\n<h1 id=\"添加dependencie\"><a href=\"#添加dependencie\" class=\"headerlink\" title=\"添加dependencie\"></a>添加dependencie</h1><p>使用gradle，代码如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">'com.microsoft.ews-java-api:ews-java-api:2.0'</span></span><br></pre></td></tr></table></figure></p>\n<p>使用maven，代码如下：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.microsoft.ews-java-api<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ews-java-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者直接导入<code>ews-java-api-2.0.jar</code>包</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.myluffy.springboot.chapter33;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.ExchangeService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.enumeration.misc.ExchangeVersion;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.enumeration.property.BodyType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.core.service.item.EmailMessage;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.credential.ExchangeCredentials;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.credential.WebCredentials;</span><br><span class=\"line\"><span class=\"keyword\">import</span> microsoft.exchange.webservices.data.property.complex.MessageBody;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.URI;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangeSendMail</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        ExchangeService service = <span class=\"keyword\">new</span> ExchangeService(ExchangeVersion.Exchange2010_SP1);</span><br><span class=\"line\">        ExchangeCredentials credentials = <span class=\"keyword\">new</span> WebCredentials(<span class=\"string\">\"username\"</span>, <span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">        service.setCredentials(credentials);</span><br><span class=\"line\">        <span class=\"comment\">// outlook.com 改为自己的邮箱服务器地址</span></span><br><span class=\"line\">        service.setUrl(<span class=\"keyword\">new</span> URI(<span class=\"string\">\"https://outlook.com/EWS/Exchange.asmx\"</span>));</span><br><span class=\"line\">        EmailMessage msg = <span class=\"keyword\">new</span> EmailMessage(service);</span><br><span class=\"line\">        <span class=\"comment\">// 主题</span></span><br><span class=\"line\">        msg.setSubject(<span class=\"string\">\"subject\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 内容</span></span><br><span class=\"line\">        <span class=\"comment\">// MessageBody 默认是发送html格式的内容</span></span><br><span class=\"line\">        MessageBody content = <span class=\"keyword\">new</span> MessageBody(BodyType.Text, <span class=\"string\">\"content\"</span>);</span><br><span class=\"line\">        msg.setBody(content);</span><br><span class=\"line\"><span class=\"comment\">//        msg.setBody(MessageBody.getMessageBodyFromText(\"content\")); // 内容为html格式</span></span><br><span class=\"line\">        <span class=\"comment\">// 收件人</span></span><br><span class=\"line\">        msg.getToRecipients().add(<span class=\"string\">\"xx@gmail.com\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 抄送人</span></span><br><span class=\"line\">        msg.getCcRecipients().add(<span class=\"string\">\"xx2@gmail.com\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 暗送</span></span><br><span class=\"line\">        msg.getBccRecipients().add(<span class=\"string\">\"xx3@gmail.com\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 附件</span></span><br><span class=\"line\">        msg.getAttachments().addFileAttachment(<span class=\"string\">\"/Users/xx/Downloads/demo.text\"</span>);</span><br><span class=\"line\">        msg.send();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如有问题，可联系我。</p>\n<p>参考文档<br><a href=\"https://github.com/OfficeDev/ews-java-api/wiki/Getting-Started-Guide\" title=\"ews-java-api\" target=\"_blank\" rel=\"noopener\">ews-java-api</a></p>\n"},{"title":"coderbyte练习题--匹配字符串的特殊字符","abbrlink":"1fda1044","date":"2017-10-24T16:00:00.000Z","_content":"\n## 字符串中两个数字之间 有三个‘？’返回 true\n\n```\nimport java.util.*;\nimport java.io.*;\n\nclass Main {  \n  public static String QuestionsMarks(String str) {\n\n    // code goes here   \n    /* Note: In Java the return type of a function and the\n       parameter types being passed are defined, so this return\n       call must match the return type of the function.\n       You are free to modify the return type. */\n        int len =str.length();\n       boolean isFlag=false;\n       for(int i=0;i<len;++i){\n           char c = str.charAt(i);\n           int n =(int)c;\n           if(n >= 48 && n<=57){\n               int s = n-48;\n                for(int j=i+1;j<len;++j){\n                        char c1= str.charAt(j);\n                        int n1 = (int)c1;\n                        if(n1>=48 && n1<=57){\n                            int s1 = n1-48;\n                            if(s1 + s == 10){\n                                String v = str.substring(i+1,j);\n                        //        System.out.print(v+\" \");\n                                int count =0 ;\n                                for(int k=0;k<v.length();++k){\n                                    if(v.charAt(k) == '?'){\n                                        count++;\n                                    }\n                                }\n                                if(count==3){\n                           //         System.out.print(\" && \");\n                                   isFlag=true;\n                                }else {\n                             //      System.out.print(\" @@ \");\n                                    isFlag=false;\n                                    return \"false\";\n                                }\n                                j=len;\n                            }\n                        }\n                }\n       }\n       }\n       if(isFlag)\n       return \"true\";\n    return \"false\";\n  }\n  public static void main (String[] args) {  \n    // keep this function call here     \n    Scanner s = new Scanner(System.in);\n    System.out.print(QuestionsMarks(s.nextLine()));\n  }   \n}\n```\n","source":"_posts/coderbyte .md","raw":"---\ntitle: coderbyte练习题--匹配字符串的特殊字符\ncategory: 算法\ntags:\n  - coderbyte\n  - java\nabbrlink: 1fda1044\ndate: 2017-10-25 00:00:00\n---\n\n## 字符串中两个数字之间 有三个‘？’返回 true\n\n```\nimport java.util.*;\nimport java.io.*;\n\nclass Main {  \n  public static String QuestionsMarks(String str) {\n\n    // code goes here   \n    /* Note: In Java the return type of a function and the\n       parameter types being passed are defined, so this return\n       call must match the return type of the function.\n       You are free to modify the return type. */\n        int len =str.length();\n       boolean isFlag=false;\n       for(int i=0;i<len;++i){\n           char c = str.charAt(i);\n           int n =(int)c;\n           if(n >= 48 && n<=57){\n               int s = n-48;\n                for(int j=i+1;j<len;++j){\n                        char c1= str.charAt(j);\n                        int n1 = (int)c1;\n                        if(n1>=48 && n1<=57){\n                            int s1 = n1-48;\n                            if(s1 + s == 10){\n                                String v = str.substring(i+1,j);\n                        //        System.out.print(v+\" \");\n                                int count =0 ;\n                                for(int k=0;k<v.length();++k){\n                                    if(v.charAt(k) == '?'){\n                                        count++;\n                                    }\n                                }\n                                if(count==3){\n                           //         System.out.print(\" && \");\n                                   isFlag=true;\n                                }else {\n                             //      System.out.print(\" @@ \");\n                                    isFlag=false;\n                                    return \"false\";\n                                }\n                                j=len;\n                            }\n                        }\n                }\n       }\n       }\n       if(isFlag)\n       return \"true\";\n    return \"false\";\n  }\n  public static void main (String[] args) {  \n    // keep this function call here     \n    Scanner s = new Scanner(System.in);\n    System.out.print(QuestionsMarks(s.nextLine()));\n  }   \n}\n```\n","slug":"coderbyte ","published":1,"updated":"2019-12-23T10:59:48.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpha000li3slom1zp6ns","content":"<h2 id=\"字符串中两个数字之间-有三个‘？’返回-true\"><a href=\"#字符串中两个数字之间-有三个‘？’返回-true\" class=\"headerlink\" title=\"字符串中两个数字之间 有三个‘？’返回 true\"></a>字符串中两个数字之间 有三个‘？’返回 true</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.*;</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main &#123;  </span><br><span class=\"line\">  public static String QuestionsMarks(String str) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // code goes here   </span><br><span class=\"line\">    /* Note: In Java the return type of a function and the</span><br><span class=\"line\">       parameter types being passed are defined, so this return</span><br><span class=\"line\">       call must match the return type of the function.</span><br><span class=\"line\">       You are free to modify the return type. */</span><br><span class=\"line\">        int len =str.length();</span><br><span class=\"line\">       boolean isFlag=false;</span><br><span class=\"line\">       for(int i=0;i&lt;len;++i)&#123;</span><br><span class=\"line\">           char c = str.charAt(i);</span><br><span class=\"line\">           int n =(int)c;</span><br><span class=\"line\">           if(n &gt;= 48 &amp;&amp; n&lt;=57)&#123;</span><br><span class=\"line\">               int s = n-48;</span><br><span class=\"line\">                for(int j=i+1;j&lt;len;++j)&#123;</span><br><span class=\"line\">                        char c1= str.charAt(j);</span><br><span class=\"line\">                        int n1 = (int)c1;</span><br><span class=\"line\">                        if(n1&gt;=48 &amp;&amp; n1&lt;=57)&#123;</span><br><span class=\"line\">                            int s1 = n1-48;</span><br><span class=\"line\">                            if(s1 + s == 10)&#123;</span><br><span class=\"line\">                                String v = str.substring(i+1,j);</span><br><span class=\"line\">                        //        System.out.print(v+&quot; &quot;);</span><br><span class=\"line\">                                int count =0 ;</span><br><span class=\"line\">                                for(int k=0;k&lt;v.length();++k)&#123;</span><br><span class=\"line\">                                    if(v.charAt(k) == &apos;?&apos;)&#123;</span><br><span class=\"line\">                                        count++;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                if(count==3)&#123;</span><br><span class=\"line\">                           //         System.out.print(&quot; &amp;&amp; &quot;);</span><br><span class=\"line\">                                   isFlag=true;</span><br><span class=\"line\">                                &#125;else &#123;</span><br><span class=\"line\">                             //      System.out.print(&quot; @@ &quot;);</span><br><span class=\"line\">                                    isFlag=false;</span><br><span class=\"line\">                                    return &quot;false&quot;;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                j=len;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if(isFlag)</span><br><span class=\"line\">       return &quot;true&quot;;</span><br><span class=\"line\">    return &quot;false&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static void main (String[] args) &#123;  </span><br><span class=\"line\">    // keep this function call here     </span><br><span class=\"line\">    Scanner s = new Scanner(System.in);</span><br><span class=\"line\">    System.out.print(QuestionsMarks(s.nextLine()));</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h2 id=\"字符串中两个数字之间-有三个‘？’返回-true\"><a href=\"#字符串中两个数字之间-有三个‘？’返回-true\" class=\"headerlink\" title=\"字符串中两个数字之间 有三个‘？’返回 true\"></a>字符串中两个数字之间 有三个‘？’返回 true</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.*;</span><br><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">class Main &#123;  </span><br><span class=\"line\">  public static String QuestionsMarks(String str) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // code goes here   </span><br><span class=\"line\">    /* Note: In Java the return type of a function and the</span><br><span class=\"line\">       parameter types being passed are defined, so this return</span><br><span class=\"line\">       call must match the return type of the function.</span><br><span class=\"line\">       You are free to modify the return type. */</span><br><span class=\"line\">        int len =str.length();</span><br><span class=\"line\">       boolean isFlag=false;</span><br><span class=\"line\">       for(int i=0;i&lt;len;++i)&#123;</span><br><span class=\"line\">           char c = str.charAt(i);</span><br><span class=\"line\">           int n =(int)c;</span><br><span class=\"line\">           if(n &gt;= 48 &amp;&amp; n&lt;=57)&#123;</span><br><span class=\"line\">               int s = n-48;</span><br><span class=\"line\">                for(int j=i+1;j&lt;len;++j)&#123;</span><br><span class=\"line\">                        char c1= str.charAt(j);</span><br><span class=\"line\">                        int n1 = (int)c1;</span><br><span class=\"line\">                        if(n1&gt;=48 &amp;&amp; n1&lt;=57)&#123;</span><br><span class=\"line\">                            int s1 = n1-48;</span><br><span class=\"line\">                            if(s1 + s == 10)&#123;</span><br><span class=\"line\">                                String v = str.substring(i+1,j);</span><br><span class=\"line\">                        //        System.out.print(v+&quot; &quot;);</span><br><span class=\"line\">                                int count =0 ;</span><br><span class=\"line\">                                for(int k=0;k&lt;v.length();++k)&#123;</span><br><span class=\"line\">                                    if(v.charAt(k) == &apos;?&apos;)&#123;</span><br><span class=\"line\">                                        count++;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                if(count==3)&#123;</span><br><span class=\"line\">                           //         System.out.print(&quot; &amp;&amp; &quot;);</span><br><span class=\"line\">                                   isFlag=true;</span><br><span class=\"line\">                                &#125;else &#123;</span><br><span class=\"line\">                             //      System.out.print(&quot; @@ &quot;);</span><br><span class=\"line\">                                    isFlag=false;</span><br><span class=\"line\">                                    return &quot;false&quot;;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                j=len;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if(isFlag)</span><br><span class=\"line\">       return &quot;true&quot;;</span><br><span class=\"line\">    return &quot;false&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  public static void main (String[] args) &#123;  </span><br><span class=\"line\">    // keep this function call here     </span><br><span class=\"line\">    Scanner s = new Scanner(System.in);</span><br><span class=\"line\">    System.out.print(QuestionsMarks(s.nextLine()));</span><br><span class=\"line\">  &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Mac使用fish终端命令，不支持 `$`符号","abbrlink":"e5358b53","date":"2018-10-26T23:37:13.000Z","_content":"## 问题\n在fish命令中使用以下命令\neg 1:\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\neg 2:\n```shell\ncd \"$(brew --repo)\"\n```\n报错提示：\n> fish: $(...) is not supported. In fish, please use '(curl)'.\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n在Mac 的fish终端中使用了 \"$\"报错。\n## 解决方法\n去掉`$`即可工作\n\n```shell\n/usr/bin/ruby -e (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\n```\n\n\n","source":"_posts/homebrew-fish-err.md","raw":"---\ntitle: Mac使用fish终端命令，不支持 `$`符号\ncategory: MacOS\ntags:\n  - mac\n  - fish\nabbrlink: e5358b53\ndate: 2018-10-27 07:37:13\n---\n## 问题\n在fish命令中使用以下命令\neg 1:\n```shell\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\neg 2:\n```shell\ncd \"$(brew --repo)\"\n```\n报错提示：\n> fish: $(...) is not supported. In fish, please use '(curl)'.\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n在Mac 的fish终端中使用了 \"$\"报错。\n## 解决方法\n去掉`$`即可工作\n\n```shell\n/usr/bin/ruby -e (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\n```\n\n\n","slug":"homebrew-fish-err","published":1,"updated":"2019-12-23T10:59:48.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphb000pi3slpxat4scv","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在fish命令中使用以下命令<br>eg 1:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"</span><br></pre></td></tr></table></figure></p>\n<p>eg 2:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd \"$(brew --repo)\"</span><br></pre></td></tr></table></figure></p>\n<p>报错提示：</p>\n<blockquote>\n<p>fish: $(…) is not supported. In fish, please use ‘(curl)’.<br>/usr/bin/ruby -e “$(curl -fsSL <a href=\"https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p>\n</blockquote>\n<p>在Mac 的fish终端中使用了 “$”报错。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>去掉<code>$</code>即可工作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在fish命令中使用以下命令<br>eg 1:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"</span><br></pre></td></tr></table></figure></p>\n<p>eg 2:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd \"$(brew --repo)\"</span><br></pre></td></tr></table></figure></p>\n<p>报错提示：</p>\n<blockquote>\n<p>fish: $(…) is not supported. In fish, please use ‘(curl)’.<br>/usr/bin/ruby -e “$(curl -fsSL <a href=\"https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a></p>\n</blockquote>\n<p>在Mac 的fish终端中使用了 “$”报错。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>去掉<code>$</code>即可工作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span><br></pre></td></tr></table></figure>\n"},{"title":"使用hexo 同步code到GitHub","abbrlink":"5aa02c5","date":"2017-09-19T16:00:00.000Z","_content":"\n因为 我们第一次同步的代码到master分支，只属于编译之后的代码（md文件解析成了HTML文件）。当我们需要更换电脑的时候，同步master分支的代码就无法自由更新hexo blog。所以我们就需要把本地的code也同步上传到GitHub上面。步骤如下：\n\n``` bash\n$ git init  //初始化本地仓库\n$ git add source //将必要的文件依次添加，有些文件夹如npm $install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示\n$ git commit -m \"code commit\"\n$ git branch hexo  //新建hexo分支\n$ git checkout hexo  //切换到hexo分支上\n$ git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接\n$ git push origin hexo  //push到Github项目的hexo分支上 \n```\n ","source":"_posts/hexo-github.md","raw":"---\ntitle: 使用hexo 同步code到GitHub\ntags:\n  - hexo\ncategory: Hexo\nabbrlink: 5aa02c5\ndate: 2017-09-20 00:00:00\n---\n\n因为 我们第一次同步的代码到master分支，只属于编译之后的代码（md文件解析成了HTML文件）。当我们需要更换电脑的时候，同步master分支的代码就无法自由更新hexo blog。所以我们就需要把本地的code也同步上传到GitHub上面。步骤如下：\n\n``` bash\n$ git init  //初始化本地仓库\n$ git add source //将必要的文件依次添加，有些文件夹如npm $install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示\n$ git commit -m \"code commit\"\n$ git branch hexo  //新建hexo分支\n$ git checkout hexo  //切换到hexo分支上\n$ git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接\n$ git push origin hexo  //push到Github项目的hexo分支上 \n```\n ","slug":"hexo-github","published":1,"updated":"2020-03-12T06:02:42.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphc000ri3sl50qkwso6","content":"<p>因为 我们第一次同步的代码到master分支，只属于编译之后的代码（md文件解析成了HTML文件）。当我们需要更换电脑的时候，同步master分支的代码就无法自由更新hexo blog。所以我们就需要把本地的code也同步上传到GitHub上面。步骤如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init  //初始化本地仓库</span><br><span class=\"line\">$ git add <span class=\"built_in\">source</span> //将必要的文件依次添加，有些文件夹如npm <span class=\"variable\">$install</span>产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"code commit\"</span></span><br><span class=\"line\">$ git branch hexo  //新建hexo分支</span><br><span class=\"line\">$ git checkout hexo  //切换到hexo分支上</span><br><span class=\"line\">$ git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class=\"line\">$ git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<p>因为 我们第一次同步的代码到master分支，只属于编译之后的代码（md文件解析成了HTML文件）。当我们需要更换电脑的时候，同步master分支的代码就无法自由更新hexo blog。所以我们就需要把本地的code也同步上传到GitHub上面。步骤如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init  //初始化本地仓库</span><br><span class=\"line\">$ git add <span class=\"built_in\">source</span> //将必要的文件依次添加，有些文件夹如npm <span class=\"variable\">$install</span>产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"code commit\"</span></span><br><span class=\"line\">$ git branch hexo  //新建hexo分支</span><br><span class=\"line\">$ git checkout hexo  //切换到hexo分支上</span><br><span class=\"line\">$ git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class=\"line\">$ git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></table></figure>\n"},{"title":"Java关键字：instanceof、transient、 final","abbrlink":"384d8ae2","date":"2019-04-25T05:44:31.000Z","_content":"# instanceof\n`instanceof` 是 Java 的一个二元操作符，类似于 ==，>，< 等操作符。\n`instanceof` 是 Java 的保留关键字。用于测试对象是否是指定类型（类或子类或接口）的实例，返回Boolean类型。\neg:\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        List arrayList = new ArrayList();\n        Object obj = new Object();\n        System.out.println(arrayList instanceof List); // output: true\n        System.out.println(arrayList instanceof ArrayList); //output:  true\n        System.out.println(arrayList instanceof LinkedList); //output:  false\n    }\n}\n```\n\n# transient\nJava中的transient关键字用于指示字段不应该是序列化（这意味着保存，比如文件）过程的一部分。\n[https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3)\n> 变量可以标记为瞬态，以指示它们不是对象的持久状态的一部分。\n比如下面的列子，不需要将密码保存起来。\neg：\n```java\nimport java.io.*;\npublic class TransientDemo {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        User user = new User();\n        user.setName(\"luffy\");\n        // password 字段为 transient\n        user.setPassword(\"123456\");\n        writeFile(user);\n        readFile();\n    }\n\n    private static void writeFile(User user) throws IOException {\n        File file = new File(\"/Users/luffy/work/temp/user.txt\");\n        FileOutputStream os = new FileOutputStream(file);\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        oos.writeObject(user);\n    }\n\n    private static void readFile() throws IOException, ClassNotFoundException {\n        File file = new File(\"/Users/luffy/work/temp/user.txt\");\n        FileInputStream os = new FileInputStream(file);\n        ObjectInputStream ois = new ObjectInputStream(os);\n        User user = (User) ois.readObject();\n        System.out.println(\"name:\" + user.getName()); // output name:wayne\n        System.out.println(\"password:\" + user.getPassword()); // output password:null\n    }\n\n}\n\nimport java.io.Serializable;\n\npublic class User implements Serializable {\n    private static final long serialVersionUID = -8855687778988171741L;\n\n    private String name;\n    private transient String password;\n    // getter setter 省略\n}\n```\n\n# final\nfinal是一个非访问修饰符，仅适用于变量，方法或类。\n> final Variable: 创建常量变量\n> final Method: 禁止方法被覆盖\n> final Class: 禁止类被继承\n\n如果一个变量是用final关键字声明的，那么它的值不能被修改，本质上是一个常量。这也意味着必须初始化最终变量。\n1. 可以在声明它时初始化最终变量。这种方法是最常见的。如果在声明时未初始化，则最终变量称为空白最终变量。\n2. 空白的最终变量可以在实例初始化块或内部构造函数中初始化。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。\n3. 可以在静态块内初始化空白的最终静态变量。\n\n让我们通过一个例子看到上面初始化最终变量的不同方法。\n\n```java\n\npublic class FinalDemo {\n    // 一个final变量, 直接初始化\n    final int A = 5;\n\n    // 一个空白变量, 后面通过初始化实例块 初始化变量\n    final int B;\n\n    {\n        B = 10;\n    }\n\n    // 另一个空白的 final 变量,通过构造方法初始化\n    final int C;\n\n    public FinalDemo() {\n        C = 15;\n    }\n\n    // 一个静态类型的 final 变量, 直接初始化\n    static final double D = 20;\n\n    // 一个空白的 静态类型final 变量,通过静态初始化块\n    static final double E;\n    static {\n        E = 25;\n    }\n}\n```\n","source":"_posts/java-keywords.md","raw":"---\ntitle: Java关键字：instanceof、transient、 final\ncategory:\n  - Java\ntags:\n  - java\nabbrlink: 384d8ae2\ndate: 2019-04-25 13:44:31\n---\n# instanceof\n`instanceof` 是 Java 的一个二元操作符，类似于 ==，>，< 等操作符。\n`instanceof` 是 Java 的保留关键字。用于测试对象是否是指定类型（类或子类或接口）的实例，返回Boolean类型。\neg:\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        List arrayList = new ArrayList();\n        Object obj = new Object();\n        System.out.println(arrayList instanceof List); // output: true\n        System.out.println(arrayList instanceof ArrayList); //output:  true\n        System.out.println(arrayList instanceof LinkedList); //output:  false\n    }\n}\n```\n\n# transient\nJava中的transient关键字用于指示字段不应该是序列化（这意味着保存，比如文件）过程的一部分。\n[https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3)\n> 变量可以标记为瞬态，以指示它们不是对象的持久状态的一部分。\n比如下面的列子，不需要将密码保存起来。\neg：\n```java\nimport java.io.*;\npublic class TransientDemo {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        User user = new User();\n        user.setName(\"luffy\");\n        // password 字段为 transient\n        user.setPassword(\"123456\");\n        writeFile(user);\n        readFile();\n    }\n\n    private static void writeFile(User user) throws IOException {\n        File file = new File(\"/Users/luffy/work/temp/user.txt\");\n        FileOutputStream os = new FileOutputStream(file);\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        oos.writeObject(user);\n    }\n\n    private static void readFile() throws IOException, ClassNotFoundException {\n        File file = new File(\"/Users/luffy/work/temp/user.txt\");\n        FileInputStream os = new FileInputStream(file);\n        ObjectInputStream ois = new ObjectInputStream(os);\n        User user = (User) ois.readObject();\n        System.out.println(\"name:\" + user.getName()); // output name:wayne\n        System.out.println(\"password:\" + user.getPassword()); // output password:null\n    }\n\n}\n\nimport java.io.Serializable;\n\npublic class User implements Serializable {\n    private static final long serialVersionUID = -8855687778988171741L;\n\n    private String name;\n    private transient String password;\n    // getter setter 省略\n}\n```\n\n# final\nfinal是一个非访问修饰符，仅适用于变量，方法或类。\n> final Variable: 创建常量变量\n> final Method: 禁止方法被覆盖\n> final Class: 禁止类被继承\n\n如果一个变量是用final关键字声明的，那么它的值不能被修改，本质上是一个常量。这也意味着必须初始化最终变量。\n1. 可以在声明它时初始化最终变量。这种方法是最常见的。如果在声明时未初始化，则最终变量称为空白最终变量。\n2. 空白的最终变量可以在实例初始化块或内部构造函数中初始化。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。\n3. 可以在静态块内初始化空白的最终静态变量。\n\n让我们通过一个例子看到上面初始化最终变量的不同方法。\n\n```java\n\npublic class FinalDemo {\n    // 一个final变量, 直接初始化\n    final int A = 5;\n\n    // 一个空白变量, 后面通过初始化实例块 初始化变量\n    final int B;\n\n    {\n        B = 10;\n    }\n\n    // 另一个空白的 final 变量,通过构造方法初始化\n    final int C;\n\n    public FinalDemo() {\n        C = 15;\n    }\n\n    // 一个静态类型的 final 变量, 直接初始化\n    static final double D = 20;\n\n    // 一个空白的 静态类型final 变量,通过静态初始化块\n    static final double E;\n    static {\n        E = 25;\n    }\n}\n```\n","slug":"java-keywords","published":1,"updated":"2019-12-23T10:59:48.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphd000wi3slor284can","content":"<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p><code>instanceof</code> 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。<br><code>instanceof</code> 是 Java 的保留关键字。用于测试对象是否是指定类型（类或子类或接口）的实例，返回Boolean类型。<br>eg:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List arrayList = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">        System.out.println(arrayList <span class=\"keyword\">instanceof</span> List); <span class=\"comment\">// output: true</span></span><br><span class=\"line\">        System.out.println(arrayList <span class=\"keyword\">instanceof</span> ArrayList); <span class=\"comment\">//output:  true</span></span><br><span class=\"line\">        System.out.println(arrayList <span class=\"keyword\">instanceof</span> LinkedList); <span class=\"comment\">//output:  false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h1><p>Java中的transient关键字用于指示字段不应该是序列化（这意味着保存，比如文件）过程的一部分。<br><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3</a></p>\n<blockquote>\n<p>变量可以标记为瞬态，以指示它们不是对象的持久状态的一部分。<br>比如下面的列子，不需要将密码保存起来。<br>eg：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransientDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"luffy\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// password 字段为 transient</span></span><br><span class=\"line\">        user.setPassword(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        writeFile(user);</span><br><span class=\"line\">        readFile();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/Users/luffy/work/temp/user.txt\"</span>);</span><br><span class=\"line\">        FileOutputStream os = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">        ObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(os);</span><br><span class=\"line\">        oos.writeObject(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/Users/luffy/work/temp/user.txt\"</span>);</span><br><span class=\"line\">        FileInputStream os = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(os);</span><br><span class=\"line\">        User user = (User) ois.readObject();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name:\"</span> + user.getName()); <span class=\"comment\">// output name:wayne</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"password:\"</span> + user.getPassword()); <span class=\"comment\">// output password:null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">8855687778988171741L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> String password;</span><br><span class=\"line\">    <span class=\"comment\">// getter setter 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><p>final是一个非访问修饰符，仅适用于变量，方法或类。</p>\n<blockquote>\n<p>final Variable: 创建常量变量<br>final Method: 禁止方法被覆盖<br>final Class: 禁止类被继承</p>\n</blockquote>\n<p>如果一个变量是用final关键字声明的，那么它的值不能被修改，本质上是一个常量。这也意味着必须初始化最终变量。</p>\n<ol>\n<li>可以在声明它时初始化最终变量。这种方法是最常见的。如果在声明时未初始化，则最终变量称为空白最终变量。</li>\n<li>空白的最终变量可以在实例初始化块或内部构造函数中初始化。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。</li>\n<li>可以在静态块内初始化空白的最终静态变量。</li>\n</ol>\n<p>让我们通过一个例子看到上面初始化最终变量的不同方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一个final变量, 直接初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> A = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个空白变量, 后面通过初始化实例块 初始化变量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> B;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        B = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 另一个空白的 final 变量,通过构造方法初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> C;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FinalDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        C = <span class=\"number\">15</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个静态类型的 final 变量, 直接初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> D = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个空白的 静态类型final 变量,通过静态初始化块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> E;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        E = <span class=\"number\">25</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h1><p><code>instanceof</code> 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。<br><code>instanceof</code> 是 Java 的保留关键字。用于测试对象是否是指定类型（类或子类或接口）的实例，返回Boolean类型。<br>eg:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List arrayList = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">        System.out.println(arrayList <span class=\"keyword\">instanceof</span> List); <span class=\"comment\">// output: true</span></span><br><span class=\"line\">        System.out.println(arrayList <span class=\"keyword\">instanceof</span> ArrayList); <span class=\"comment\">//output:  true</span></span><br><span class=\"line\">        System.out.println(arrayList <span class=\"keyword\">instanceof</span> LinkedList); <span class=\"comment\">//output:  false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h1><p>Java中的transient关键字用于指示字段不应该是序列化（这意味着保存，比如文件）过程的一部分。<br><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3</a></p>\n<blockquote>\n<p>变量可以标记为瞬态，以指示它们不是对象的持久状态的一部分。<br>比如下面的列子，不需要将密码保存起来。<br>eg：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransientDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"luffy\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// password 字段为 transient</span></span><br><span class=\"line\">        user.setPassword(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        writeFile(user);</span><br><span class=\"line\">        readFile();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/Users/luffy/work/temp/user.txt\"</span>);</span><br><span class=\"line\">        FileOutputStream os = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">        ObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(os);</span><br><span class=\"line\">        oos.writeObject(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/Users/luffy/work/temp/user.txt\"</span>);</span><br><span class=\"line\">        FileInputStream os = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(os);</span><br><span class=\"line\">        User user = (User) ois.readObject();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"name:\"</span> + user.getName()); <span class=\"comment\">// output name:wayne</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"password:\"</span> + user.getPassword()); <span class=\"comment\">// output password:null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">8855687778988171741L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> String password;</span><br><span class=\"line\">    <span class=\"comment\">// getter setter 省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h1><p>final是一个非访问修饰符，仅适用于变量，方法或类。</p>\n<blockquote>\n<p>final Variable: 创建常量变量<br>final Method: 禁止方法被覆盖<br>final Class: 禁止类被继承</p>\n</blockquote>\n<p>如果一个变量是用final关键字声明的，那么它的值不能被修改，本质上是一个常量。这也意味着必须初始化最终变量。</p>\n<ol>\n<li>可以在声明它时初始化最终变量。这种方法是最常见的。如果在声明时未初始化，则最终变量称为空白最终变量。</li>\n<li>空白的最终变量可以在实例初始化块或内部构造函数中初始化。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。</li>\n<li>可以在静态块内初始化空白的最终静态变量。</li>\n</ol>\n<p>让我们通过一个例子看到上面初始化最终变量的不同方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一个final变量, 直接初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> A = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个空白变量, 后面通过初始化实例块 初始化变量</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> B;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        B = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 另一个空白的 final 变量,通过构造方法初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> C;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FinalDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        C = <span class=\"number\">15</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个静态类型的 final 变量, 直接初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> D = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个空白的 静态类型final 变量,通过静态初始化块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> E;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        E = <span class=\"number\">25</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java源码学习：Object","abbrlink":"ad5258d2","date":"2018-04-02T16:00:00.000Z","_content":"# 简介\nObject类是所有类根，即所有的类都隐式继承了Object.\n# 常用方法\n## hashCode()\nhashCode方法返回对象的散列码，相等对象必须返回相等的hashCode，不同对象的hashCode尽可能不相等；Obejct中定义的hashCode方法为：\n```\npublic native int hashCode();\n```\n## equals()\nObject中定义的equals()方法：\n```java\npublic boolean equals(Object obj) {\n\treturn (this == obj);\n}\n```\nequals()方法，顾名思义就是判断是否相等，可以看见Object中equals()方法是用 ‘==’来判断地址;由此可见，我们常用String类的肯定是重写了该方法的，查看String的源码；\n```java\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n当我们重写equals时总要重写hashCode：\n* 重写equals不重写hashCode，会导致“不相等对象拥有相同的hashCode”，导致集合类HashMap，HashSet和Hashtable无法工作；极端情况下，在散列表中使所有对象的hashCode都相等，所有对象都被映射到同一个桶中，散列表退化成链表；\n* 当两个对象调用equal返回true，则两个对象各自调用hashCode()返回相同hashCode；\n* 当两个对象调用equal返回false， 两个对象各自调用hashCode()返回的hashCode可以相同（散列冲突不能完全避免）\n\n## toString()\nObject类中toString方法，输出对象的“对象类名@散列码”；\n```java\n    public String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n```\n\n## finalize()\nObejct类中finalize()方法\n```java\nprotected void finalize() throws Throwable { }\n```\nfinalize()会在对象被垃圾回收时由垃圾回收器调用，垃圾对象是指没有引用指向的对象\n* JVM的垃圾回收是\"最少回收\"方式，只有当内存不够的时候才会进行垃圾回收\n* 如果调用System.gc() 这个方法，只是告诉JVM 希望这里进行垃圾回收，但是具体什么时候回收还需要看JVM的运行状态，且System.gc()对资源还是有一定消耗，如果盲目的运用System.gc()这个方法，反而效率还会下降，看场景适用；\n\n# Reference\nhttps://blog.csdn.net/xu511739113/article/details/52328727\nhttps://segmentfault.com/a/1190000009057426","source":"_posts/java-object-source.md","raw":"---\ntitle: Java源码学习：Object\ncategory: Java\ntags:\n  - java\nabbrlink: ad5258d2\ndate: 2018-04-03 00:00:00\n---\n# 简介\nObject类是所有类根，即所有的类都隐式继承了Object.\n# 常用方法\n## hashCode()\nhashCode方法返回对象的散列码，相等对象必须返回相等的hashCode，不同对象的hashCode尽可能不相等；Obejct中定义的hashCode方法为：\n```\npublic native int hashCode();\n```\n## equals()\nObject中定义的equals()方法：\n```java\npublic boolean equals(Object obj) {\n\treturn (this == obj);\n}\n```\nequals()方法，顾名思义就是判断是否相等，可以看见Object中equals()方法是用 ‘==’来判断地址;由此可见，我们常用String类的肯定是重写了该方法的，查看String的源码；\n```java\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n当我们重写equals时总要重写hashCode：\n* 重写equals不重写hashCode，会导致“不相等对象拥有相同的hashCode”，导致集合类HashMap，HashSet和Hashtable无法工作；极端情况下，在散列表中使所有对象的hashCode都相等，所有对象都被映射到同一个桶中，散列表退化成链表；\n* 当两个对象调用equal返回true，则两个对象各自调用hashCode()返回相同hashCode；\n* 当两个对象调用equal返回false， 两个对象各自调用hashCode()返回的hashCode可以相同（散列冲突不能完全避免）\n\n## toString()\nObject类中toString方法，输出对象的“对象类名@散列码”；\n```java\n    public String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n```\n\n## finalize()\nObejct类中finalize()方法\n```java\nprotected void finalize() throws Throwable { }\n```\nfinalize()会在对象被垃圾回收时由垃圾回收器调用，垃圾对象是指没有引用指向的对象\n* JVM的垃圾回收是\"最少回收\"方式，只有当内存不够的时候才会进行垃圾回收\n* 如果调用System.gc() 这个方法，只是告诉JVM 希望这里进行垃圾回收，但是具体什么时候回收还需要看JVM的运行状态，且System.gc()对资源还是有一定消耗，如果盲目的运用System.gc()这个方法，反而效率还会下降，看场景适用；\n\n# Reference\nhttps://blog.csdn.net/xu511739113/article/details/52328727\nhttps://segmentfault.com/a/1190000009057426","slug":"java-object-source","published":1,"updated":"2019-12-23T10:59:48.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphd000xi3sl8ypy2cr5","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Object类是所有类根，即所有的类都隐式继承了Object.</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode()\"></a>hashCode()</h2><p>hashCode方法返回对象的散列码，相等对象必须返回相等的hashCode，不同对象的hashCode尽可能不相等；Obejct中定义的hashCode方法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public native int hashCode();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals()\"></a>equals()</h2><p>Object中定义的equals()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>equals()方法，顾名思义就是判断是否相等，可以看见Object中equals()方法是用 ‘==’来判断地址;由此可见，我们常用String类的肯定是重写了该方法的，查看String的源码；<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们重写equals时总要重写hashCode：</p>\n<ul>\n<li>重写equals不重写hashCode，会导致“不相等对象拥有相同的hashCode”，导致集合类HashMap，HashSet和Hashtable无法工作；极端情况下，在散列表中使所有对象的hashCode都相等，所有对象都被映射到同一个桶中，散列表退化成链表；</li>\n<li>当两个对象调用equal返回true，则两个对象各自调用hashCode()返回相同hashCode；</li>\n<li>当两个对象调用equal返回false， 两个对象各自调用hashCode()返回的hashCode可以相同（散列冲突不能完全避免）</li>\n</ul>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><p>Object类中toString方法，输出对象的“对象类名@散列码”；<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getName() + <span class=\"string\">\"@\"</span> + Integer.toHexString(hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize()\"></a>finalize()</h2><p>Obejct类中finalize()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>finalize()会在对象被垃圾回收时由垃圾回收器调用，垃圾对象是指没有引用指向的对象</p>\n<ul>\n<li>JVM的垃圾回收是”最少回收”方式，只有当内存不够的时候才会进行垃圾回收</li>\n<li>如果调用System.gc() 这个方法，只是告诉JVM 希望这里进行垃圾回收，但是具体什么时候回收还需要看JVM的运行状态，且System.gc()对资源还是有一定消耗，如果盲目的运用System.gc()这个方法，反而效率还会下降，看场景适用；</li>\n</ul>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://blog.csdn.net/xu511739113/article/details/52328727\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xu511739113/article/details/52328727</a><br><a href=\"https://segmentfault.com/a/1190000009057426\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009057426</a></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Object类是所有类根，即所有的类都隐式继承了Object.</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode()\"></a>hashCode()</h2><p>hashCode方法返回对象的散列码，相等对象必须返回相等的hashCode，不同对象的hashCode尽可能不相等；Obejct中定义的hashCode方法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public native int hashCode();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals()\"></a>equals()</h2><p>Object中定义的equals()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>equals()方法，顾名思义就是判断是否相等，可以看见Object中equals()方法是用 ‘==’来判断地址;由此可见，我们常用String类的肯定是重写了该方法的，查看String的源码；<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们重写equals时总要重写hashCode：</p>\n<ul>\n<li>重写equals不重写hashCode，会导致“不相等对象拥有相同的hashCode”，导致集合类HashMap，HashSet和Hashtable无法工作；极端情况下，在散列表中使所有对象的hashCode都相等，所有对象都被映射到同一个桶中，散列表退化成链表；</li>\n<li>当两个对象调用equal返回true，则两个对象各自调用hashCode()返回相同hashCode；</li>\n<li>当两个对象调用equal返回false， 两个对象各自调用hashCode()返回的hashCode可以相同（散列冲突不能完全避免）</li>\n</ul>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h2><p>Object类中toString方法，输出对象的“对象类名@散列码”；<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getName() + <span class=\"string\">\"@\"</span> + Integer.toHexString(hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize()\"></a>finalize()</h2><p>Obejct类中finalize()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>finalize()会在对象被垃圾回收时由垃圾回收器调用，垃圾对象是指没有引用指向的对象</p>\n<ul>\n<li>JVM的垃圾回收是”最少回收”方式，只有当内存不够的时候才会进行垃圾回收</li>\n<li>如果调用System.gc() 这个方法，只是告诉JVM 希望这里进行垃圾回收，但是具体什么时候回收还需要看JVM的运行状态，且System.gc()对资源还是有一定消耗，如果盲目的运用System.gc()这个方法，反而效率还会下降，看场景适用；</li>\n</ul>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://blog.csdn.net/xu511739113/article/details/52328727\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xu511739113/article/details/52328727</a><br><a href=\"https://segmentfault.com/a/1190000009057426\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009057426</a></p>\n"},{"title":"Java实现LRU算法","abbrlink":"2d1b3bf6","date":"2019-07-18T04:22:19.000Z","_content":"# 介绍\nLRU 的全称是 Least Recently Used ，它是一种最少使用算法，当存储的空间已满时，将最久未使用到的数据淘汰。\n# 实现\n使用HashMap和双向链表实现。因为HashMap的get()方法时间复杂度为O(1)，双向链表使节点添加/删除操作O(1)。\n* get(key) 获取缓存中的值\n* put(key, value) 添加值，当缓存容量满了时，则删除最久未访问的数据。\n\n建立一个Node类\n```java\n/**\n * 双向链表\n */\nclass Node {\n    String key;\n    String value;\n    Node next;\n    Node prev;\n\n    public Node(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```\nNode类里面包含了key、value 和前置节点、后置节点。\nLRUCache实现类如下：\n```java\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LRUCache {\n\n    /**\n     * 尾节点\n     */\n    Node tail;\n    /**\n     * 头结点\n     */\n    Node head;\n    Map<String, Node> map = null;\n    private int capacity = 0; // 容量\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n    }\n\n    public String get(String key) {\n        Node node = map.get(key);\n        if (node == null) {\n            return \"\";\n        }\n        // 移除末尾节点\n        removeNode(node);\n        // 移动 node 到头节点\n        moveToHead(node);\n        // 返回\n        return node.value;\n    }\n\n    public void put(String key, String value) {\n\n        if (map.containsKey(key)) {\n            // 已经存在该 key 将key 移动到头结点\n            Node node = map.get(key);\n            // 移除末尾节点\n            removeNode(node);\n            // 移动 node 到头节点\n            moveToHead(node);\n        } else {\n            // 容量判断\n            if (map.size() >= capacity) {\n                // 删除 尾节点\n                map.remove(tail.key);\n                removeNode(tail);\n            }\n            // 插入节点 到 头节点\n            Node node = new Node(key, value);\n            moveToHead(node);\n            map.put(key, node);\n\n        }\n    }\n\n    /**\n     * 移除节点\n     * @param n\n     */\n    private void removeNode(Node n) {\n        if (n.prev != null) {\n            n.prev.next = n.next;\n        } else {\n            head = n.next;\n        }\n        if (n.next != null) {\n            n.next.prev = n.prev;\n        } else {\n            tail = n.prev;\n        }\n    }\n\n    /**\n     * 添加节点到头节点\n     * @param n\n     */\n    private void moveToHead(Node n) {\n        final Node f = head;\n        head = n;\n        if (f != null) {\n            f.prev = n;\n            head.next = f;\n        }\n        if (tail == null) {\n            tail = f;\n        }\n    }\n}\n```\n# 结果\n建立一个测试类\n```java\n\npublic class LRUCacheTest {\n    public static void main(String[] args) {\n        // 设置容量为10 的缓存\n        LRUCache cache = new LRUCache(10);\n        for (int i = 0; i < 12; i++) {\n            cache.put(\"\" + i, \"\" + i);\n        }\n        Node head = cache.head;\n        // 输出缓存中的元素\n        // output: 11 10 9 8 7 6 5 4 3 2  \n        while (head != null) {\n            System.out.print(head.value + \" \");\n            head = head.next;\n        }\n        System.out.println();\n        System.out.println(cache.get(\"0\")); // \"0\"没有在缓存中 output: \"\"\n        System.out.println(cache.get(\"3\")); // output: \"3\"\n        System.out.println(cache.get(\"4\")); // output: \"4\"\n\n        // 因为上面 获取了 '3'、'4'这两个元素，所以缓存中的元素顺序发生了变化\n        Node head2 = cache.head;\n        // output: 4 3 11 10 9 8 7 6 5 2\n        while (head2 != null) {\n            System.out.print(head2.value + \" \");\n            head2 = head2.next;\n        }\n    }\n}\n```\n通过上面的测试 LRU 缓存是将最新使用的元素更新到链表的前面，当超出容量时，则移除链表末尾的元素。\n![](https://ws1.sinaimg.cn/large/64202e18ly1g53xf21frlj20fw06wjri.jpg)\n","source":"_posts/java-lru.md","raw":"---\ntitle: Java实现LRU算法\ncategory:\n  - Java\ntags:\n  - 算法\nabbrlink: 2d1b3bf6\ndate: 2019-07-18 12:22:19\n---\n# 介绍\nLRU 的全称是 Least Recently Used ，它是一种最少使用算法，当存储的空间已满时，将最久未使用到的数据淘汰。\n# 实现\n使用HashMap和双向链表实现。因为HashMap的get()方法时间复杂度为O(1)，双向链表使节点添加/删除操作O(1)。\n* get(key) 获取缓存中的值\n* put(key, value) 添加值，当缓存容量满了时，则删除最久未访问的数据。\n\n建立一个Node类\n```java\n/**\n * 双向链表\n */\nclass Node {\n    String key;\n    String value;\n    Node next;\n    Node prev;\n\n    public Node(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```\nNode类里面包含了key、value 和前置节点、后置节点。\nLRUCache实现类如下：\n```java\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LRUCache {\n\n    /**\n     * 尾节点\n     */\n    Node tail;\n    /**\n     * 头结点\n     */\n    Node head;\n    Map<String, Node> map = null;\n    private int capacity = 0; // 容量\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n    }\n\n    public String get(String key) {\n        Node node = map.get(key);\n        if (node == null) {\n            return \"\";\n        }\n        // 移除末尾节点\n        removeNode(node);\n        // 移动 node 到头节点\n        moveToHead(node);\n        // 返回\n        return node.value;\n    }\n\n    public void put(String key, String value) {\n\n        if (map.containsKey(key)) {\n            // 已经存在该 key 将key 移动到头结点\n            Node node = map.get(key);\n            // 移除末尾节点\n            removeNode(node);\n            // 移动 node 到头节点\n            moveToHead(node);\n        } else {\n            // 容量判断\n            if (map.size() >= capacity) {\n                // 删除 尾节点\n                map.remove(tail.key);\n                removeNode(tail);\n            }\n            // 插入节点 到 头节点\n            Node node = new Node(key, value);\n            moveToHead(node);\n            map.put(key, node);\n\n        }\n    }\n\n    /**\n     * 移除节点\n     * @param n\n     */\n    private void removeNode(Node n) {\n        if (n.prev != null) {\n            n.prev.next = n.next;\n        } else {\n            head = n.next;\n        }\n        if (n.next != null) {\n            n.next.prev = n.prev;\n        } else {\n            tail = n.prev;\n        }\n    }\n\n    /**\n     * 添加节点到头节点\n     * @param n\n     */\n    private void moveToHead(Node n) {\n        final Node f = head;\n        head = n;\n        if (f != null) {\n            f.prev = n;\n            head.next = f;\n        }\n        if (tail == null) {\n            tail = f;\n        }\n    }\n}\n```\n# 结果\n建立一个测试类\n```java\n\npublic class LRUCacheTest {\n    public static void main(String[] args) {\n        // 设置容量为10 的缓存\n        LRUCache cache = new LRUCache(10);\n        for (int i = 0; i < 12; i++) {\n            cache.put(\"\" + i, \"\" + i);\n        }\n        Node head = cache.head;\n        // 输出缓存中的元素\n        // output: 11 10 9 8 7 6 5 4 3 2  \n        while (head != null) {\n            System.out.print(head.value + \" \");\n            head = head.next;\n        }\n        System.out.println();\n        System.out.println(cache.get(\"0\")); // \"0\"没有在缓存中 output: \"\"\n        System.out.println(cache.get(\"3\")); // output: \"3\"\n        System.out.println(cache.get(\"4\")); // output: \"4\"\n\n        // 因为上面 获取了 '3'、'4'这两个元素，所以缓存中的元素顺序发生了变化\n        Node head2 = cache.head;\n        // output: 4 3 11 10 9 8 7 6 5 2\n        while (head2 != null) {\n            System.out.print(head2.value + \" \");\n            head2 = head2.next;\n        }\n    }\n}\n```\n通过上面的测试 LRU 缓存是将最新使用的元素更新到链表的前面，当超出容量时，则移除链表末尾的元素。\n![](https://ws1.sinaimg.cn/large/64202e18ly1g53xf21frlj20fw06wjri.jpg)\n","slug":"java-lru","published":1,"updated":"2019-12-23T10:59:48.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphe0010i3slec8ob3cq","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>LRU 的全称是 Least Recently Used ，它是一种最少使用算法，当存储的空间已满时，将最久未使用到的数据淘汰。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>使用HashMap和双向链表实现。因为HashMap的get()方法时间复杂度为O(1)，双向链表使节点添加/删除操作O(1)。</p>\n<ul>\n<li>get(key) 获取缓存中的值</li>\n<li>put(key, value) 添加值，当缓存容量满了时，则删除最久未访问的数据。</li>\n</ul>\n<p>建立一个Node类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 双向链表</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    String key;</span><br><span class=\"line\">    String value;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\">    Node prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Node类里面包含了key、value 和前置节点、后置节点。<br>LRUCache实现类如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尾节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Node tail;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 头结点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Node head;</span><br><span class=\"line\">    Map&lt;String, Node&gt; map = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity = <span class=\"number\">0</span>; <span class=\"comment\">// 容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        Node node = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 移除末尾节点</span></span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        <span class=\"comment\">// 移动 node 到头节点</span></span><br><span class=\"line\">        moveToHead(node);</span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 已经存在该 key 将key 移动到头结点</span></span><br><span class=\"line\">            Node node = map.get(key);</span><br><span class=\"line\">            <span class=\"comment\">// 移除末尾节点</span></span><br><span class=\"line\">            removeNode(node);</span><br><span class=\"line\">            <span class=\"comment\">// 移动 node 到头节点</span></span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 容量判断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 删除 尾节点</span></span><br><span class=\"line\">                map.remove(tail.key);</span><br><span class=\"line\">                removeNode(tail);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 插入节点 到 头节点</span></span><br><span class=\"line\">            Node node = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">            map.put(key, node);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n.prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n.prev.next = n.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            head = n.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n.next.prev = n.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tail = n.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加节点到头节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToHead</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node f = head;</span><br><span class=\"line\">        head = n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            f.prev = n;</span><br><span class=\"line\">            head.next = f;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tail == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            tail = f;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><p>建立一个测试类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCacheTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置容量为10 的缓存</span></span><br><span class=\"line\">        LRUCache cache = <span class=\"keyword\">new</span> LRUCache(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">12</span>; i++) &#123;</span><br><span class=\"line\">            cache.put(<span class=\"string\">\"\"</span> + i, <span class=\"string\">\"\"</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node head = cache.head;</span><br><span class=\"line\">        <span class=\"comment\">// 输出缓存中的元素</span></span><br><span class=\"line\">        <span class=\"comment\">// output: 11 10 9 8 7 6 5 4 3 2  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.print(head.value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"string\">\"0\"</span>)); <span class=\"comment\">// \"0\"没有在缓存中 output: \"\"</span></span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"string\">\"3\"</span>)); <span class=\"comment\">// output: \"3\"</span></span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"string\">\"4\"</span>)); <span class=\"comment\">// output: \"4\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 因为上面 获取了 '3'、'4'这两个元素，所以缓存中的元素顺序发生了变化</span></span><br><span class=\"line\">        Node head2 = cache.head;</span><br><span class=\"line\">        <span class=\"comment\">// output: 4 3 11 10 9 8 7 6 5 2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.print(head2.value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的测试 LRU 缓存是将最新使用的元素更新到链表的前面，当超出容量时，则移除链表末尾的元素。<br><img src=\"https://ws1.sinaimg.cn/large/64202e18ly1g53xf21frlj20fw06wjri.jpg\" alt></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>LRU 的全称是 Least Recently Used ，它是一种最少使用算法，当存储的空间已满时，将最久未使用到的数据淘汰。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>使用HashMap和双向链表实现。因为HashMap的get()方法时间复杂度为O(1)，双向链表使节点添加/删除操作O(1)。</p>\n<ul>\n<li>get(key) 获取缓存中的值</li>\n<li>put(key, value) 添加值，当缓存容量满了时，则删除最久未访问的数据。</li>\n</ul>\n<p>建立一个Node类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 双向链表</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    String key;</span><br><span class=\"line\">    String value;</span><br><span class=\"line\">    Node next;</span><br><span class=\"line\">    Node prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Node类里面包含了key、value 和前置节点、后置节点。<br>LRUCache实现类如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尾节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Node tail;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 头结点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Node head;</span><br><span class=\"line\">    Map&lt;String, Node&gt; map = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity = <span class=\"number\">0</span>; <span class=\"comment\">// 容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        Node node = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 移除末尾节点</span></span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        <span class=\"comment\">// 移动 node 到头节点</span></span><br><span class=\"line\">        moveToHead(node);</span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 已经存在该 key 将key 移动到头结点</span></span><br><span class=\"line\">            Node node = map.get(key);</span><br><span class=\"line\">            <span class=\"comment\">// 移除末尾节点</span></span><br><span class=\"line\">            removeNode(node);</span><br><span class=\"line\">            <span class=\"comment\">// 移动 node 到头节点</span></span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 容量判断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 删除 尾节点</span></span><br><span class=\"line\">                map.remove(tail.key);</span><br><span class=\"line\">                removeNode(tail);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 插入节点 到 头节点</span></span><br><span class=\"line\">            Node node = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">            moveToHead(node);</span><br><span class=\"line\">            map.put(key, node);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n.prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n.prev.next = n.next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            head = n.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n.next.prev = n.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            tail = n.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加节点到头节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToHead</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node f = head;</span><br><span class=\"line\">        head = n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            f.prev = n;</span><br><span class=\"line\">            head.next = f;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tail == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            tail = f;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><p>建立一个测试类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCacheTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置容量为10 的缓存</span></span><br><span class=\"line\">        LRUCache cache = <span class=\"keyword\">new</span> LRUCache(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">12</span>; i++) &#123;</span><br><span class=\"line\">            cache.put(<span class=\"string\">\"\"</span> + i, <span class=\"string\">\"\"</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node head = cache.head;</span><br><span class=\"line\">        <span class=\"comment\">// 输出缓存中的元素</span></span><br><span class=\"line\">        <span class=\"comment\">// output: 11 10 9 8 7 6 5 4 3 2  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.print(head.value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"string\">\"0\"</span>)); <span class=\"comment\">// \"0\"没有在缓存中 output: \"\"</span></span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"string\">\"3\"</span>)); <span class=\"comment\">// output: \"3\"</span></span><br><span class=\"line\">        System.out.println(cache.get(<span class=\"string\">\"4\"</span>)); <span class=\"comment\">// output: \"4\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 因为上面 获取了 '3'、'4'这两个元素，所以缓存中的元素顺序发生了变化</span></span><br><span class=\"line\">        Node head2 = cache.head;</span><br><span class=\"line\">        <span class=\"comment\">// output: 4 3 11 10 9 8 7 6 5 2</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.print(head2.value + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的测试 LRU 缓存是将最新使用的元素更新到链表的前面，当超出容量时，则移除链表末尾的元素。<br><img src=\"https://ws1.sinaimg.cn/large/64202e18ly1g53xf21frlj20fw06wjri.jpg\" alt></p>\n"},{"title":"java 字符串位数不足自动补全","abbrlink":"9c5e6c30","date":"2018-04-26T16:00:00.000Z","_content":"## java 字符串位数不足自动补全\n* 使用`org.apache.commons.lang`包下的`StringUtils`的leftPad函数，可以直接得到想要的结果。\n\n\n```java\npublic class Demo{\n\tpublic static void main(String[] args) {\n\t\t//第一个参数：补位之前的值，第二个参数：总共的位数，第三个参数：补位用什么字符来填充。\n\t\tfinal String s = org.apache.commons.lang.StringUtils.leftPad(\"10110\", 8, \"0\");\n\t\tSystem.out.println(s); // output: 00010110\n\t}\n}\n```","source":"_posts/java-string-autocompile.md","raw":"---\ntitle: java 字符串位数不足自动补全\ncategory: Java\ntags:\n  - java\nabbrlink: 9c5e6c30\ndate: 2018-04-27 00:00:00\n---\n## java 字符串位数不足自动补全\n* 使用`org.apache.commons.lang`包下的`StringUtils`的leftPad函数，可以直接得到想要的结果。\n\n\n```java\npublic class Demo{\n\tpublic static void main(String[] args) {\n\t\t//第一个参数：补位之前的值，第二个参数：总共的位数，第三个参数：补位用什么字符来填充。\n\t\tfinal String s = org.apache.commons.lang.StringUtils.leftPad(\"10110\", 8, \"0\");\n\t\tSystem.out.println(s); // output: 00010110\n\t}\n}\n```","slug":"java-string-autocompile","published":1,"updated":"2020-03-30T11:07:26.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphf0014i3sl26ila16k","content":"<h2 id=\"java-字符串位数不足自动补全\"><a href=\"#java-字符串位数不足自动补全\" class=\"headerlink\" title=\"java 字符串位数不足自动补全\"></a>java 字符串位数不足自动补全</h2><ul>\n<li>使用<code>org.apache.commons.lang</code>包下的<code>StringUtils</code>的leftPad函数，可以直接得到想要的结果。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一个参数：补位之前的值，第二个参数：总共的位数，第三个参数：补位用什么字符来填充。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> String s = org.apache.commons.lang.StringUtils.leftPad(<span class=\"string\">\"10110\"</span>, <span class=\"number\">8</span>, <span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(s); <span class=\"comment\">// output: 00010110</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"variables":""}},"excerpt":"","more":"<h2 id=\"java-字符串位数不足自动补全\"><a href=\"#java-字符串位数不足自动补全\" class=\"headerlink\" title=\"java 字符串位数不足自动补全\"></a>java 字符串位数不足自动补全</h2><ul>\n<li>使用<code>org.apache.commons.lang</code>包下的<code>StringUtils</code>的leftPad函数，可以直接得到想要的结果。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//第一个参数：补位之前的值，第二个参数：总共的位数，第三个参数：补位用什么字符来填充。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> String s = org.apache.commons.lang.StringUtils.leftPad(<span class=\"string\">\"10110\"</span>, <span class=\"number\">8</span>, <span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(s); <span class=\"comment\">// output: 00010110</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java使用split 按照'|'（竖线）拆分字符串","abbrlink":"9ac45683","date":"2017-11-19T16:00:00.000Z","_content":"\n在使用String类中的split方法时候，才开始使用了\n\n```  java\n\"ab|cd\".split(\"|\"); \n```\n 发现得到的结果是错误的，结果如下：\n \n``` java\na\nb\n|\nc\nd\n```\n<!--more-->\n很显然，这不是我所需要的结果。\n原因是竖线 | 在正则中是特殊字符，需要转义，也就是\n\n```\nsplit(\"\\|\");\n```\n但实际在java中使用时，\\又是java的特殊字符，需要转义，最终变成了\n\n```\nsplit(\"\\\\|\");\n```\n正确使用如下：\n\n``` java\n\"ab|cd\".split(\"\\\\|\");\n```\n结果如下：\n\n```\nab\ncd\n```\n","source":"_posts/java-split-method.md","raw":"---\ntitle: Java使用split 按照'|'（竖线）拆分字符串\ncategory: Java\ntags:\n  - java\nabbrlink: 9ac45683\ndate: 2017-11-20 00:00:00\n---\n\n在使用String类中的split方法时候，才开始使用了\n\n```  java\n\"ab|cd\".split(\"|\"); \n```\n 发现得到的结果是错误的，结果如下：\n \n``` java\na\nb\n|\nc\nd\n```\n<!--more-->\n很显然，这不是我所需要的结果。\n原因是竖线 | 在正则中是特殊字符，需要转义，也就是\n\n```\nsplit(\"\\|\");\n```\n但实际在java中使用时，\\又是java的特殊字符，需要转义，最终变成了\n\n```\nsplit(\"\\\\|\");\n```\n正确使用如下：\n\n``` java\n\"ab|cd\".split(\"\\\\|\");\n```\n结果如下：\n\n```\nab\ncd\n```\n","slug":"java-split-method","published":1,"updated":"2020-03-12T06:04:17.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphg0016i3slaa7baqnq","content":"<p>在使用String类中的split方法时候，才开始使用了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"ab|cd\"</span>.split(<span class=\"string\">\"|\"</span>);</span><br></pre></td></tr></table></figure>\n<p> 发现得到的结果是错误的，结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">|</span><br><span class=\"line\">c</span><br><span class=\"line\">d</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>很显然，这不是我所需要的结果。<br>原因是竖线 | 在正则中是特殊字符，需要转义，也就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(&quot;\\|&quot;);</span><br></pre></td></tr></table></figure>\n<p>但实际在java中使用时，\\又是java的特殊字符，需要转义，最终变成了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(&quot;\\\\|&quot;);</span><br></pre></td></tr></table></figure>\n<p>正确使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"ab|cd\"</span>.split(<span class=\"string\">\"\\\\|\"</span>);</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ab</span><br><span class=\"line\">cd</span><br></pre></td></tr></table></figure>\n","site":{"data":{"variables":""}},"excerpt":"<p>在使用String类中的split方法时候，才开始使用了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"ab|cd\"</span>.split(<span class=\"string\">\"|\"</span>);</span><br></pre></td></tr></table></figure>\n<p> 发现得到的结果是错误的，结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">|</span><br><span class=\"line\">c</span><br><span class=\"line\">d</span><br></pre></td></tr></table></figure>","more":"<p>很显然，这不是我所需要的结果。<br>原因是竖线 | 在正则中是特殊字符，需要转义，也就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(&quot;\\|&quot;);</span><br></pre></td></tr></table></figure>\n<p>但实际在java中使用时，\\又是java的特殊字符，需要转义，最终变成了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">split(&quot;\\\\|&quot;);</span><br></pre></td></tr></table></figure>\n<p>正确使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"ab|cd\"</span>.split(<span class=\"string\">\"\\\\|\"</span>);</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ab</span><br><span class=\"line\">cd</span><br></pre></td></tr></table></figure>"},{"title":"JDK8源码学习： Integer 的自动装箱拆箱和缓存机制","abbrlink":"90698191","date":"2019-04-21T13:10:07.000Z","_content":"# 介绍\n`Integer` 是 `int` 的包装类，`Integer` 中还有一个匿名内部类 `IntegerCache` 它是一个对 `Integer` 的对象缓存，但是它有一个范围，默认是 `-128——127`。首先来看看 `IntegerCache` 的实现。\n```java\nprivate static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            // 默认为127\n            int h = 127;\n            //获取JVM设置的参数值（+XX:AutoBoxCacheMax=？）\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    // 防止设置的参数大于了 Integer的最大值。\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                // 将-128 到 h的值放进数组里面\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {}\n    }\n```\nIntegerCache的功能就是将-128到127的整数缓存起来。并且可以通过jvm参数设置 IntegerCache的最大值，增加了灵活性。\n# 属性\n下面是一些Integer的基本参数介绍。\n## MAX_VALUE 最大值\n`MAX_VALUE`顾名思义，就是Integer的最大值，它是不可变的。它的值为 2^31-1 = 2147483647\n``` java\n@Native public static final int   MAX_VALUE = 0x7fffffff;\n```\n## MIN_VALUE 最小值\n`MIN_VALUE`对应Integer的最小值，也是不可变的。值为： -2^31 = -2147483648\n```java\n@Native public static final int   MIN_VALUE = 0x80000000;\n```\n# 方法\n介绍一下常用方法。\n## toString 方法\n`Integer#toString` 其实就是将Integer类型变成了String类型。\n```java\npublic String toString() {\n    return toString(value);\n}\n\npublic static String toString(int i) {\n    if (i == Integer.MIN_VALUE)\n        // 如果为最小值 直接返回最小值\n        return \"-2147483648\";\n    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);\n    char[] buf = new char[size];\n    getChars(i, size, buf);\n    return new String(buf, true);\n}\n```\n\n## valueOf(int) 方法\n我们先看看下面这段代码：\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        Integer i = 10;\n        System.out.println(i);\n    }\n}\n```\n10是 `int` 类型，为什么可以直接赋值给 `Integer` 类型呢？我们分别张歘`javac Demo.class` 和 `javap -c Demo.class`命令看看程序是怎么编译的。\n```java\n  public static void main(java.lang.String[]);\n    Code:\n       0: bipush        10\n       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n       5: astore_1\n       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       9: aload_1\n      10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n      13: return\n```\n<!-- ![bc7fca64c9f9284e995e4f618989bb02.png](evernotecid://99E24FA2-4BAA-475C-B10C-A7D31B5CD72F/appyinxiangcom/16310471/ENResource/p851) -->\n上面是部分编译结果，可以看见`2: invokestatic  #2 ` 自动调用了`Integer#valueOf` 方法，这里就是程序自动将 `int` 变成了 `Integer` 类型。\n现在我们来看`Integer#valueOf`的具体实现。\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n我们在文章开头已经说了一下 `IntegerCache` 类，我们可以看见 `valueOf` 的方法，首先判断i的值是否在 `IntegerCache` 的范围之内，如果在，直接从cache里面获取即可，不在范围之内，则new 一个Integer 返回。\n\n## intValue() 方法\n下面这段代码将 一个Integer类型的赋值给了int类型。为什么Integer可以赋值给int，这里就涉及到了Integer的自动拆箱。\n``` java\nInteger i = 10;\nint i2 = i;\n```\n在执行 `int i2 = i;`的时候，i会先执行`Integer#intValue`再赋值给i2。下面是 `Integer#intValue`的实现代码。\n```java\nprivate final int value;\n\npublic int intValue() {\n    return value;\n}\n```\n就一行代码，直接返回了Integer的value。\n\n# 结束\nInteger的缓存机制，是面试中或者笔试中比较常见的，需要注意下。","source":"_posts/jdk8-source-Integer.md","raw":"---\ntitle: JDK8源码学习： Integer 的自动装箱拆箱和缓存机制\ncategory:\n  - java相关\ntags:\n  - java\n  - 源码\nabbrlink: '90698191'\ndate: 2019-04-21 21:10:07\n---\n# 介绍\n`Integer` 是 `int` 的包装类，`Integer` 中还有一个匿名内部类 `IntegerCache` 它是一个对 `Integer` 的对象缓存，但是它有一个范围，默认是 `-128——127`。首先来看看 `IntegerCache` 的实现。\n```java\nprivate static class IntegerCache {\n        static final int low = -128;\n        static final int high;\n        static final Integer cache[];\n\n        static {\n            // high value may be configured by property\n            // 默认为127\n            int h = 127;\n            //获取JVM设置的参数值（+XX:AutoBoxCacheMax=？）\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    // 防止设置的参数大于了 Integer的最大值。\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n\n            cache = new Integer[(high - low) + 1];\n            int j = low;\n            for(int k = 0; k < cache.length; k++)\n                // 将-128 到 h的值放进数组里面\n                cache[k] = new Integer(j++);\n\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n\n        private IntegerCache() {}\n    }\n```\nIntegerCache的功能就是将-128到127的整数缓存起来。并且可以通过jvm参数设置 IntegerCache的最大值，增加了灵活性。\n# 属性\n下面是一些Integer的基本参数介绍。\n## MAX_VALUE 最大值\n`MAX_VALUE`顾名思义，就是Integer的最大值，它是不可变的。它的值为 2^31-1 = 2147483647\n``` java\n@Native public static final int   MAX_VALUE = 0x7fffffff;\n```\n## MIN_VALUE 最小值\n`MIN_VALUE`对应Integer的最小值，也是不可变的。值为： -2^31 = -2147483648\n```java\n@Native public static final int   MIN_VALUE = 0x80000000;\n```\n# 方法\n介绍一下常用方法。\n## toString 方法\n`Integer#toString` 其实就是将Integer类型变成了String类型。\n```java\npublic String toString() {\n    return toString(value);\n}\n\npublic static String toString(int i) {\n    if (i == Integer.MIN_VALUE)\n        // 如果为最小值 直接返回最小值\n        return \"-2147483648\";\n    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);\n    char[] buf = new char[size];\n    getChars(i, size, buf);\n    return new String(buf, true);\n}\n```\n\n## valueOf(int) 方法\n我们先看看下面这段代码：\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        Integer i = 10;\n        System.out.println(i);\n    }\n}\n```\n10是 `int` 类型，为什么可以直接赋值给 `Integer` 类型呢？我们分别张歘`javac Demo.class` 和 `javap -c Demo.class`命令看看程序是怎么编译的。\n```java\n  public static void main(java.lang.String[]);\n    Code:\n       0: bipush        10\n       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n       5: astore_1\n       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       9: aload_1\n      10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n      13: return\n```\n<!-- ![bc7fca64c9f9284e995e4f618989bb02.png](evernotecid://99E24FA2-4BAA-475C-B10C-A7D31B5CD72F/appyinxiangcom/16310471/ENResource/p851) -->\n上面是部分编译结果，可以看见`2: invokestatic  #2 ` 自动调用了`Integer#valueOf` 方法，这里就是程序自动将 `int` 变成了 `Integer` 类型。\n现在我们来看`Integer#valueOf`的具体实现。\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n我们在文章开头已经说了一下 `IntegerCache` 类，我们可以看见 `valueOf` 的方法，首先判断i的值是否在 `IntegerCache` 的范围之内，如果在，直接从cache里面获取即可，不在范围之内，则new 一个Integer 返回。\n\n## intValue() 方法\n下面这段代码将 一个Integer类型的赋值给了int类型。为什么Integer可以赋值给int，这里就涉及到了Integer的自动拆箱。\n``` java\nInteger i = 10;\nint i2 = i;\n```\n在执行 `int i2 = i;`的时候，i会先执行`Integer#intValue`再赋值给i2。下面是 `Integer#intValue`的实现代码。\n```java\nprivate final int value;\n\npublic int intValue() {\n    return value;\n}\n```\n就一行代码，直接返回了Integer的value。\n\n# 结束\nInteger的缓存机制，是面试中或者笔试中比较常见的，需要注意下。","slug":"jdk8-source-Integer","published":1,"updated":"2019-12-23T10:59:48.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphj001bi3slqxda1c6i","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>Integer</code> 是 <code>int</code> 的包装类，<code>Integer</code> 中还有一个匿名内部类 <code>IntegerCache</code> 它是一个对 <code>Integer</code> 的对象缓存，但是它有一个范围，默认是 <code>-128——127</code>。首先来看看 <code>IntegerCache</code> 的实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">            <span class=\"comment\">// 默认为127</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">            <span class=\"comment\">//获取JVM设置的参数值（+XX:AutoBoxCacheMax=？）</span></span><br><span class=\"line\">            String integerCacheHighPropValue =</span><br><span class=\"line\">                sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                    i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">                    <span class=\"comment\">// 防止设置的参数大于了 Integer的最大值。</span></span><br><span class=\"line\">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">            cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">                <span class=\"comment\">// 将-128 到 h的值放进数组里面</span></span><br><span class=\"line\">                cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>IntegerCache的功能就是将-128到127的整数缓存起来。并且可以通过jvm参数设置 IntegerCache的最大值，增加了灵活性。</p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><p>下面是一些Integer的基本参数介绍。</p>\n<h2 id=\"MAX-VALUE-最大值\"><a href=\"#MAX-VALUE-最大值\" class=\"headerlink\" title=\"MAX_VALUE 最大值\"></a>MAX_VALUE 最大值</h2><p><code>MAX_VALUE</code>顾名思义，就是Integer的最大值，它是不可变的。它的值为 2^31-1 = 2147483647<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Native</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>   MAX_VALUE = <span class=\"number\">0x7fffffff</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"MIN-VALUE-最小值\"><a href=\"#MIN-VALUE-最小值\" class=\"headerlink\" title=\"MIN_VALUE 最小值\"></a>MIN_VALUE 最小值</h2><p><code>MIN_VALUE</code>对应Integer的最小值，也是不可变的。值为： -2^31 = -2147483648<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Native</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>   MIN_VALUE = <span class=\"number\">0x80000000</span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>介绍一下常用方法。</p>\n<h2 id=\"toString-方法\"><a href=\"#toString-方法\" class=\"headerlink\" title=\"toString 方法\"></a>toString 方法</h2><p><code>Integer#toString</code> 其实就是将Integer类型变成了String类型。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> toString(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">toString</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == Integer.MIN_VALUE)</span><br><span class=\"line\">        <span class=\"comment\">// 如果为最小值 直接返回最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"-2147483648\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = (i &lt; <span class=\"number\">0</span>) ? stringSize(-i) + <span class=\"number\">1</span> : stringSize(i);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[size];</span><br><span class=\"line\">    getChars(i, size, buf);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(buf, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"valueOf-int-方法\"><a href=\"#valueOf-int-方法\" class=\"headerlink\" title=\"valueOf(int) 方法\"></a>valueOf(int) 方法</h2><p>我们先看看下面这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer i = <span class=\"number\">10</span>;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>10是 <code>int</code> 类型，为什么可以直接赋值给 <code>Integer</code> 类型呢？我们分别张歘<code>javac Demo.class</code> 和 <code>javap -c Demo.class</code>命令看看程序是怎么编译的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">  Code:</span><br><span class=\"line\">     <span class=\"number\">0</span>: bipush        <span class=\"number\">10</span></span><br><span class=\"line\">     2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">     <span class=\"number\">5</span>: astore_1</span><br><span class=\"line\">     6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">     <span class=\"number\">9</span>: aload_1</span><br><span class=\"line\">    10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class=\"line\">    <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure></p>\n<!-- ![bc7fca64c9f9284e995e4f618989bb02.png](evernotecid://99E24FA2-4BAA-475C-B10C-A7D31B5CD72F/appyinxiangcom/16310471/ENResource/p851) -->\n<p>上面是部分编译结果，可以看见<code>2: invokestatic  #2</code> 自动调用了<code>Integer#valueOf</code> 方法，这里就是程序自动将 <code>int</code> 变成了 <code>Integer</code> 类型。<br>现在我们来看<code>Integer#valueOf</code>的具体实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在文章开头已经说了一下 <code>IntegerCache</code> 类，我们可以看见 <code>valueOf</code> 的方法，首先判断i的值是否在 <code>IntegerCache</code> 的范围之内，如果在，直接从cache里面获取即可，不在范围之内，则new 一个Integer 返回。</p>\n<h2 id=\"intValue-方法\"><a href=\"#intValue-方法\" class=\"headerlink\" title=\"intValue() 方法\"></a>intValue() 方法</h2><p>下面这段代码将 一个Integer类型的赋值给了int类型。为什么Integer可以赋值给int，这里就涉及到了Integer的自动拆箱。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i2 = i;</span><br></pre></td></tr></table></figure></p>\n<p>在执行 <code>int i2 = i;</code>的时候，i会先执行<code>Integer#intValue</code>再赋值给i2。下面是 <code>Integer#intValue</code>的实现代码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">intValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就一行代码，直接返回了Integer的value。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>Integer的缓存机制，是面试中或者笔试中比较常见的，需要注意下。</p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>Integer</code> 是 <code>int</code> 的包装类，<code>Integer</code> 中还有一个匿名内部类 <code>IntegerCache</code> 它是一个对 <code>Integer</code> 的对象缓存，但是它有一个范围，默认是 <code>-128——127</code>。首先来看看 <code>IntegerCache</code> 的实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">            <span class=\"comment\">// 默认为127</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">            <span class=\"comment\">//获取JVM设置的参数值（+XX:AutoBoxCacheMax=？）</span></span><br><span class=\"line\">            String integerCacheHighPropValue =</span><br><span class=\"line\">                sun.misc.VM.getSavedProperty(<span class=\"string\">\"java.lang.Integer.IntegerCache.high\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                    i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">                    <span class=\"comment\">// 防止设置的参数大于了 Integer的最大值。</span></span><br><span class=\"line\">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">            cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">                <span class=\"comment\">// 将-128 到 h的值放进数组里面</span></span><br><span class=\"line\">                cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>IntegerCache的功能就是将-128到127的整数缓存起来。并且可以通过jvm参数设置 IntegerCache的最大值，增加了灵活性。</p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><p>下面是一些Integer的基本参数介绍。</p>\n<h2 id=\"MAX-VALUE-最大值\"><a href=\"#MAX-VALUE-最大值\" class=\"headerlink\" title=\"MAX_VALUE 最大值\"></a>MAX_VALUE 最大值</h2><p><code>MAX_VALUE</code>顾名思义，就是Integer的最大值，它是不可变的。它的值为 2^31-1 = 2147483647<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Native</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>   MAX_VALUE = <span class=\"number\">0x7fffffff</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"MIN-VALUE-最小值\"><a href=\"#MIN-VALUE-最小值\" class=\"headerlink\" title=\"MIN_VALUE 最小值\"></a>MIN_VALUE 最小值</h2><p><code>MIN_VALUE</code>对应Integer的最小值，也是不可变的。值为： -2^31 = -2147483648<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Native</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>   MIN_VALUE = <span class=\"number\">0x80000000</span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>介绍一下常用方法。</p>\n<h2 id=\"toString-方法\"><a href=\"#toString-方法\" class=\"headerlink\" title=\"toString 方法\"></a>toString 方法</h2><p><code>Integer#toString</code> 其实就是将Integer类型变成了String类型。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> toString(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">toString</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == Integer.MIN_VALUE)</span><br><span class=\"line\">        <span class=\"comment\">// 如果为最小值 直接返回最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"-2147483648\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = (i &lt; <span class=\"number\">0</span>) ? stringSize(-i) + <span class=\"number\">1</span> : stringSize(i);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[size];</span><br><span class=\"line\">    getChars(i, size, buf);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(buf, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"valueOf-int-方法\"><a href=\"#valueOf-int-方法\" class=\"headerlink\" title=\"valueOf(int) 方法\"></a>valueOf(int) 方法</h2><p>我们先看看下面这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer i = <span class=\"number\">10</span>;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>10是 <code>int</code> 类型，为什么可以直接赋值给 <code>Integer</code> 类型呢？我们分别张歘<code>javac Demo.class</code> 和 <code>javap -c Demo.class</code>命令看看程序是怎么编译的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">  Code:</span><br><span class=\"line\">     <span class=\"number\">0</span>: bipush        <span class=\"number\">10</span></span><br><span class=\"line\">     2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">     <span class=\"number\">5</span>: astore_1</span><br><span class=\"line\">     6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">     <span class=\"number\">9</span>: aload_1</span><br><span class=\"line\">    10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class=\"line\">    <span class=\"number\">13</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure></p>\n<!-- ![bc7fca64c9f9284e995e4f618989bb02.png](evernotecid://99E24FA2-4BAA-475C-B10C-A7D31B5CD72F/appyinxiangcom/16310471/ENResource/p851) -->\n<p>上面是部分编译结果，可以看见<code>2: invokestatic  #2</code> 自动调用了<code>Integer#valueOf</code> 方法，这里就是程序自动将 <code>int</code> 变成了 <code>Integer</code> 类型。<br>现在我们来看<code>Integer#valueOf</code>的具体实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们在文章开头已经说了一下 <code>IntegerCache</code> 类，我们可以看见 <code>valueOf</code> 的方法，首先判断i的值是否在 <code>IntegerCache</code> 的范围之内，如果在，直接从cache里面获取即可，不在范围之内，则new 一个Integer 返回。</p>\n<h2 id=\"intValue-方法\"><a href=\"#intValue-方法\" class=\"headerlink\" title=\"intValue() 方法\"></a>intValue() 方法</h2><p>下面这段代码将 一个Integer类型的赋值给了int类型。为什么Integer可以赋值给int，这里就涉及到了Integer的自动拆箱。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i2 = i;</span><br></pre></td></tr></table></figure></p>\n<p>在执行 <code>int i2 = i;</code>的时候，i会先执行<code>Integer#intValue</code>再赋值给i2。下面是 <code>Integer#intValue</code>的实现代码。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">intValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就一行代码，直接返回了Integer的value。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>Integer的缓存机制，是面试中或者笔试中比较常见的，需要注意下。</p>\n"},{"title":"JDK8源码学习：HashSet","abbrlink":"8cf8f8a0","date":"2019-04-23T09:35:01.000Z","_content":"# 介绍\nHashSet实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序，HashSet允许元素为null。并且该类不是线程安全的。它能保证元素唯一性，一般可以用于去重。\n如果要线程安全，可以通过以下方式实现：\n```java\nSet s = Collections.synchronizedSet(new HashSet(...));\n```\n\n# 变量\n\n# 构造方法\n## public HashSet()\n默认构造方法，是新建一个空的set,由HashMap支持，默认初始容量（16）和加载因子（0.75），对加载因子的解释在[HashMap源码](https://www.waynezw.cn/archives/2da9164.html)这篇文章中有解释。\n```java\npublic HashSet() {\n    map = new HashMap<>();\n}\npublic HashSet(int initialCapacity, float loadFactor) {\n    map = new HashMap<>(initialCapacity, loadFactor);\n}\npublic HashSet(int initialCapacity) {\n    map = new HashMap<>(initialCapacity);\n}\n```\n`HashSet` 的构造方法都是调用 `HashMap` 的构造方法完成的。\n\n# 方法\n## public boolean add (E e)\n添加元素，如果指定的元素尚不存在，则将其添加到此集合中，返回true，如果不存在，返回false。实现代码如下：\n```java\npublic boolean add(E e) {\n    return map.put(e, PRESENT)==null;\n}\n```\n这里直接调用了` Map#put` 方法，方法有一个 `PRESENT`,它是一个虚拟的`object`值，实际上我们在添加元素的时候往 map里面put值的时候是没有value的，但是map的put方法是需要接收一个value值，这里就用到了`PRESENT`，一个默认的虚拟值。\n因为 `HashSet#add` 方法实际上调用了` Map#put`方法，将元素 `e`当做了map的key值，这样就保证了`HashSet`元素的唯一性。该方法的具体实现可以看这篇文章[HashMap源码](https://www.waynezw.cn/archives/2da9164.html)。\n我们通过下面的列子来印证。\n```java \nSet<String> set = new HashSet<>();\nboolean bool = set.add(\"hash set\");\nSystem.out.println(bool + \"\"); //  output: true\nboolean bool2 = set.add(\"hash set\");\nSystem.out.println(bool2 + \"\"); // output: false\nIterator<String> iterator = set.iterator();\nwhile (iterator.hasNext()) { // 3\n    System.out.println(iterator.next()); \n}\n```\n通过上面的代码我们可以清楚的看见 步骤`3` 只输出了一次 `hash set`，证实了HashSet元素的唯一性。\n\n## public boolean contains (Object o)\n如果此set包含指定的元素，则返回true。\n```java\npublic boolean contains(Object o) {\n    return map.containsKey(o);\n}\n```\n`contains`调用`HashMap#containsKey`方法，其实就是调用了`HashMap#getNode`， 该方法的具体实现可以看这篇文章[HashMap源码](https://www.waynezw.cn/archives/2da9164.html)。\n\n## boolean remove(Object o)\n删除元素，存在元素，并且删除成功，返回true，反之false；实现也是基于HashMap的方法。\n\n## 遍历\nHashSet推荐遍历的方式；\n```java\npublic static void main(String[] args) {\n    Set<Integer> set = new HashSet<>();\n    for (int i = 0; i < 10; i++) {\n        set.add(i);\n    }\n    forHashSet(set);\n    whileHashSet(set);\n}\n\nprivate static void whileHashSet(Set<Integer> set) {\n    Iterator<Integer> iterator = set.iterator();\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n\nprivate static void forHashSet(Set<Integer> set) {\n    for (Iterator iterator = set.iterator();\n         iterator.hasNext(); ) {\n        System.out.println(iterator.next());\n    }\n}\n\n```\n`whileHashSet`和`forHashSet`本质上都是调用了 `iterator`，只是分别使用 for循环或者while来实现而已。\n\n# 总结\n\n* 基于HashMap的支持\n* 元素唯一性\n* 不保证元素添加的顺序\n* 线程不安全类","source":"_posts/jdk8-source-hashset.md","raw":"---\ntitle: JDK8源码学习：HashSet\ncategory:\n  - Java\ntags:\n  - java\n  - 源码\nabbrlink: 8cf8f8a0\ndate: 2019-04-23 17:35:01\n---\n# 介绍\nHashSet实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序，HashSet允许元素为null。并且该类不是线程安全的。它能保证元素唯一性，一般可以用于去重。\n如果要线程安全，可以通过以下方式实现：\n```java\nSet s = Collections.synchronizedSet(new HashSet(...));\n```\n\n# 变量\n\n# 构造方法\n## public HashSet()\n默认构造方法，是新建一个空的set,由HashMap支持，默认初始容量（16）和加载因子（0.75），对加载因子的解释在[HashMap源码](https://www.waynezw.cn/archives/2da9164.html)这篇文章中有解释。\n```java\npublic HashSet() {\n    map = new HashMap<>();\n}\npublic HashSet(int initialCapacity, float loadFactor) {\n    map = new HashMap<>(initialCapacity, loadFactor);\n}\npublic HashSet(int initialCapacity) {\n    map = new HashMap<>(initialCapacity);\n}\n```\n`HashSet` 的构造方法都是调用 `HashMap` 的构造方法完成的。\n\n# 方法\n## public boolean add (E e)\n添加元素，如果指定的元素尚不存在，则将其添加到此集合中，返回true，如果不存在，返回false。实现代码如下：\n```java\npublic boolean add(E e) {\n    return map.put(e, PRESENT)==null;\n}\n```\n这里直接调用了` Map#put` 方法，方法有一个 `PRESENT`,它是一个虚拟的`object`值，实际上我们在添加元素的时候往 map里面put值的时候是没有value的，但是map的put方法是需要接收一个value值，这里就用到了`PRESENT`，一个默认的虚拟值。\n因为 `HashSet#add` 方法实际上调用了` Map#put`方法，将元素 `e`当做了map的key值，这样就保证了`HashSet`元素的唯一性。该方法的具体实现可以看这篇文章[HashMap源码](https://www.waynezw.cn/archives/2da9164.html)。\n我们通过下面的列子来印证。\n```java \nSet<String> set = new HashSet<>();\nboolean bool = set.add(\"hash set\");\nSystem.out.println(bool + \"\"); //  output: true\nboolean bool2 = set.add(\"hash set\");\nSystem.out.println(bool2 + \"\"); // output: false\nIterator<String> iterator = set.iterator();\nwhile (iterator.hasNext()) { // 3\n    System.out.println(iterator.next()); \n}\n```\n通过上面的代码我们可以清楚的看见 步骤`3` 只输出了一次 `hash set`，证实了HashSet元素的唯一性。\n\n## public boolean contains (Object o)\n如果此set包含指定的元素，则返回true。\n```java\npublic boolean contains(Object o) {\n    return map.containsKey(o);\n}\n```\n`contains`调用`HashMap#containsKey`方法，其实就是调用了`HashMap#getNode`， 该方法的具体实现可以看这篇文章[HashMap源码](https://www.waynezw.cn/archives/2da9164.html)。\n\n## boolean remove(Object o)\n删除元素，存在元素，并且删除成功，返回true，反之false；实现也是基于HashMap的方法。\n\n## 遍历\nHashSet推荐遍历的方式；\n```java\npublic static void main(String[] args) {\n    Set<Integer> set = new HashSet<>();\n    for (int i = 0; i < 10; i++) {\n        set.add(i);\n    }\n    forHashSet(set);\n    whileHashSet(set);\n}\n\nprivate static void whileHashSet(Set<Integer> set) {\n    Iterator<Integer> iterator = set.iterator();\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n\nprivate static void forHashSet(Set<Integer> set) {\n    for (Iterator iterator = set.iterator();\n         iterator.hasNext(); ) {\n        System.out.println(iterator.next());\n    }\n}\n\n```\n`whileHashSet`和`forHashSet`本质上都是调用了 `iterator`，只是分别使用 for循环或者while来实现而已。\n\n# 总结\n\n* 基于HashMap的支持\n* 元素唯一性\n* 不保证元素添加的顺序\n* 线程不安全类","slug":"jdk8-source-hashset","published":1,"updated":"2019-12-23T10:59:48.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphk001ei3sltgcdf1h3","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>HashSet实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序，HashSet允许元素为null。并且该类不是线程安全的。它能保证元素唯一性，一般可以用于去重。<br>如果要线程安全，可以通过以下方式实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set s = Collections.synchronizedSet(<span class=\"keyword\">new</span> HashSet(...));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><h2 id=\"public-HashSet\"><a href=\"#public-HashSet\" class=\"headerlink\" title=\"public HashSet()\"></a>public HashSet()</h2><p>默认构造方法，是新建一个空的set,由HashMap支持，默认初始容量（16）和加载因子（0.75），对加载因子的解释在<a href=\"https://www.waynezw.cn/archives/2da9164.html\" target=\"_blank\" rel=\"noopener\">HashMap源码</a>这篇文章中有解释。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>HashSet</code> 的构造方法都是调用 <code>HashMap</code> 的构造方法完成的。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"public-boolean-add-E-e\"><a href=\"#public-boolean-add-E-e\" class=\"headerlink\" title=\"public boolean add (E e)\"></a>public boolean add (E e)</h2><p>添加元素，如果指定的元素尚不存在，则将其添加到此集合中，返回true，如果不存在，返回false。实现代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里直接调用了<code>Map#put</code> 方法，方法有一个 <code>PRESENT</code>,它是一个虚拟的<code>object</code>值，实际上我们在添加元素的时候往 map里面put值的时候是没有value的，但是map的put方法是需要接收一个value值，这里就用到了<code>PRESENT</code>，一个默认的虚拟值。<br>因为 <code>HashSet#add</code> 方法实际上调用了<code>Map#put</code>方法，将元素 <code>e</code>当做了map的key值，这样就保证了<code>HashSet</code>元素的唯一性。该方法的具体实现可以看这篇文章<a href=\"https://www.waynezw.cn/archives/2da9164.html\" target=\"_blank\" rel=\"noopener\">HashMap源码</a>。<br>我们通过下面的列子来印证。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> bool = set.add(<span class=\"string\">\"hash set\"</span>);</span><br><span class=\"line\">System.out.println(bool + <span class=\"string\">\"\"</span>); <span class=\"comment\">//  output: true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> bool2 = set.add(<span class=\"string\">\"hash set\"</span>);</span><br><span class=\"line\">System.out.println(bool2 + <span class=\"string\">\"\"</span>); <span class=\"comment\">// output: false</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">    System.out.println(iterator.next()); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的代码我们可以清楚的看见 步骤<code>3</code> 只输出了一次 <code>hash set</code>，证实了HashSet元素的唯一性。</p>\n<h2 id=\"public-boolean-contains-Object-o\"><a href=\"#public-boolean-contains-Object-o\" class=\"headerlink\" title=\"public boolean contains (Object o)\"></a>public boolean contains (Object o)</h2><p>如果此set包含指定的元素，则返回true。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.containsKey(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>contains</code>调用<code>HashMap#containsKey</code>方法，其实就是调用了<code>HashMap#getNode</code>， 该方法的具体实现可以看这篇文章<a href=\"https://www.waynezw.cn/archives/2da9164.html\" target=\"_blank\" rel=\"noopener\">HashMap源码</a>。</p>\n<h2 id=\"boolean-remove-Object-o\"><a href=\"#boolean-remove-Object-o\" class=\"headerlink\" title=\"boolean remove(Object o)\"></a>boolean remove(Object o)</h2><p>删除元素，存在元素，并且删除成功，返回true，反之false；实现也是基于HashMap的方法。</p>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>HashSet推荐遍历的方式；<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        set.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    forHashSet(set);</span><br><span class=\"line\">    whileHashSet(set);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">whileHashSet</span><span class=\"params\">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(iterator.next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">forHashSet</span><span class=\"params\">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator iterator = set.iterator();</span><br><span class=\"line\">         iterator.hasNext(); ) &#123;</span><br><span class=\"line\">        System.out.println(iterator.next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>whileHashSet</code>和<code>forHashSet</code>本质上都是调用了 <code>iterator</code>，只是分别使用 for循环或者while来实现而已。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>基于HashMap的支持</li>\n<li>元素唯一性</li>\n<li>不保证元素添加的顺序</li>\n<li>线程不安全类</li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>HashSet实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序，HashSet允许元素为null。并且该类不是线程安全的。它能保证元素唯一性，一般可以用于去重。<br>如果要线程安全，可以通过以下方式实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set s = Collections.synchronizedSet(<span class=\"keyword\">new</span> HashSet(...));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><h2 id=\"public-HashSet\"><a href=\"#public-HashSet\" class=\"headerlink\" title=\"public HashSet()\"></a>public HashSet()</h2><p>默认构造方法，是新建一个空的set,由HashMap支持，默认初始容量（16）和加载因子（0.75），对加载因子的解释在<a href=\"https://www.waynezw.cn/archives/2da9164.html\" target=\"_blank\" rel=\"noopener\">HashMap源码</a>这篇文章中有解释。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>HashSet</code> 的构造方法都是调用 <code>HashMap</code> 的构造方法完成的。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"public-boolean-add-E-e\"><a href=\"#public-boolean-add-E-e\" class=\"headerlink\" title=\"public boolean add (E e)\"></a>public boolean add (E e)</h2><p>添加元素，如果指定的元素尚不存在，则将其添加到此集合中，返回true，如果不存在，返回false。实现代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里直接调用了<code>Map#put</code> 方法，方法有一个 <code>PRESENT</code>,它是一个虚拟的<code>object</code>值，实际上我们在添加元素的时候往 map里面put值的时候是没有value的，但是map的put方法是需要接收一个value值，这里就用到了<code>PRESENT</code>，一个默认的虚拟值。<br>因为 <code>HashSet#add</code> 方法实际上调用了<code>Map#put</code>方法，将元素 <code>e</code>当做了map的key值，这样就保证了<code>HashSet</code>元素的唯一性。该方法的具体实现可以看这篇文章<a href=\"https://www.waynezw.cn/archives/2da9164.html\" target=\"_blank\" rel=\"noopener\">HashMap源码</a>。<br>我们通过下面的列子来印证。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> bool = set.add(<span class=\"string\">\"hash set\"</span>);</span><br><span class=\"line\">System.out.println(bool + <span class=\"string\">\"\"</span>); <span class=\"comment\">//  output: true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> bool2 = set.add(<span class=\"string\">\"hash set\"</span>);</span><br><span class=\"line\">System.out.println(bool2 + <span class=\"string\">\"\"</span>); <span class=\"comment\">// output: false</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">    System.out.println(iterator.next()); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的代码我们可以清楚的看见 步骤<code>3</code> 只输出了一次 <code>hash set</code>，证实了HashSet元素的唯一性。</p>\n<h2 id=\"public-boolean-contains-Object-o\"><a href=\"#public-boolean-contains-Object-o\" class=\"headerlink\" title=\"public boolean contains (Object o)\"></a>public boolean contains (Object o)</h2><p>如果此set包含指定的元素，则返回true。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.containsKey(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>contains</code>调用<code>HashMap#containsKey</code>方法，其实就是调用了<code>HashMap#getNode</code>， 该方法的具体实现可以看这篇文章<a href=\"https://www.waynezw.cn/archives/2da9164.html\" target=\"_blank\" rel=\"noopener\">HashMap源码</a>。</p>\n<h2 id=\"boolean-remove-Object-o\"><a href=\"#boolean-remove-Object-o\" class=\"headerlink\" title=\"boolean remove(Object o)\"></a>boolean remove(Object o)</h2><p>删除元素，存在元素，并且删除成功，返回true，反之false；实现也是基于HashMap的方法。</p>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>HashSet推荐遍历的方式；<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        set.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    forHashSet(set);</span><br><span class=\"line\">    whileHashSet(set);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">whileHashSet</span><span class=\"params\">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(iterator.next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">forHashSet</span><span class=\"params\">(Set&lt;Integer&gt; set)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator iterator = set.iterator();</span><br><span class=\"line\">         iterator.hasNext(); ) &#123;</span><br><span class=\"line\">        System.out.println(iterator.next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>whileHashSet</code>和<code>forHashSet</code>本质上都是调用了 <code>iterator</code>，只是分别使用 for循环或者while来实现而已。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>基于HashMap的支持</li>\n<li>元素唯一性</li>\n<li>不保证元素添加的顺序</li>\n<li>线程不安全类</li>\n</ul>\n"},{"title":"Mac对nginx 启动、关闭、重启","abbrlink":"c21378c4","date":"2018-10-21T16:00:00.000Z","_content":"\n## 问题\n在终端中执行：\n`brew install nginx`\n安装完成之后，nginx配置文件路径在`/usr/local/etc/nginx`下\n## 常用命令\n查看nginx版本\n`nginx -v`\n![](/images/nginx-v.jpg)\n启动nginx：`brew services start nginx`\n![](/images/nginx-start.jpg)\n关闭nginx：`brew services stop nginx`\n![](/images/nginx-stop.jpg)\n\n也可以使用如下快捷指令\n重新启动nginx：\n`nginx -s reload`\n停止nginx：\n`nginx -s stop`\n","source":"_posts/mac-install-nginx.md","raw":"---\ntitle: Mac对nginx 启动、关闭、重启\ncategory: MacOS\ntags:\n  - mac\n  - nginx\nabbrlink: c21378c4\ndate: 2018-10-22 00:00:00\n---\n\n## 问题\n在终端中执行：\n`brew install nginx`\n安装完成之后，nginx配置文件路径在`/usr/local/etc/nginx`下\n## 常用命令\n查看nginx版本\n`nginx -v`\n![](/images/nginx-v.jpg)\n启动nginx：`brew services start nginx`\n![](/images/nginx-start.jpg)\n关闭nginx：`brew services stop nginx`\n![](/images/nginx-stop.jpg)\n\n也可以使用如下快捷指令\n重新启动nginx：\n`nginx -s reload`\n停止nginx：\n`nginx -s stop`\n","slug":"mac-install-nginx","published":1,"updated":"2019-12-23T10:59:48.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphm001ji3slql7u5yjf","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在终端中执行：<br><code>brew install nginx</code><br>安装完成之后，nginx配置文件路径在<code>/usr/local/etc/nginx</code>下</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>查看nginx版本<br><code>nginx -v</code><br><img src=\"/images/nginx-v.jpg\" alt><br>启动nginx：<code>brew services start nginx</code><br><img src=\"/images/nginx-start.jpg\" alt><br>关闭nginx：<code>brew services stop nginx</code><br><img src=\"/images/nginx-stop.jpg\" alt></p>\n<p>也可以使用如下快捷指令<br>重新启动nginx：<br><code>nginx -s reload</code><br>停止nginx：<br><code>nginx -s stop</code></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在终端中执行：<br><code>brew install nginx</code><br>安装完成之后，nginx配置文件路径在<code>/usr/local/etc/nginx</code>下</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>查看nginx版本<br><code>nginx -v</code><br><img src=\"/images/nginx-v.jpg\" alt><br>启动nginx：<code>brew services start nginx</code><br><img src=\"/images/nginx-start.jpg\" alt><br>关闭nginx：<code>brew services stop nginx</code><br><img src=\"/images/nginx-stop.jpg\" alt></p>\n<p>也可以使用如下快捷指令<br>重新启动nginx：<br><code>nginx -s reload</code><br>停止nginx：<br><code>nginx -s stop</code></p>\n"},{"title":"利用Python3 连接mysql 导出数据为excel格式","abbrlink":"21a7feb2","date":"2018-07-08T16:00:00.000Z","_content":"## 背景\n最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。\n才开始觉得sql每次都是固定不变，总量也不多，就通过 MySQL workbench 一条一条查询导出为 *.csv文件，但是发现 *.csv文件直接打开会出现中文乱码，就需要转码，我就通过Notepad++ 打开csv文件，设置文件格式 utf-8 bom 编码。这一系列步骤下来。人都不好了。\n后面自己受不了了，就想通过脚本来解决这个重复性工作。我是一个Java开发者，就准备用Java来实现这个工作，但是后面发现Java来解决这个问题，有点太麻烦了，需要连接MySQL，查询数据，通过poi遍历做成poi对应excel的hssfworkbook对象（或者xssfworkbook），然后通过io流输出成excel文件。想到这些，就直接放弃了用Java来实现这个工作了。\n后面想到了Python，我对Python不熟。就在网上查找了一些资料，发现还是满简单的了。就这样决定用Python来实现了。\n## 具体实现\n下面是Python的具体实现代码：\n\n```python\n# coding:utf8\nimport sys\nimport xlwt\n#import MySQLdb\nimport pymysql as MySQLdb\nimport datetime\n\ndef get_conn_mysql():\n    conn = MySQLdb.connect(host='localhost', port=3306, user='root', passwd='root', db='test', charset='utf8')\n    return conn\ndef query_data(cur, sql, args):\n    cur.execute(sql, args)\n    return cur.fetchall()\n\n# out_path 保存的路径， sql： 需要执行的语句\ndef read_mysql_to_excel(out_path, sql):\n    conn = get_conn_mysql()\n    cursor = conn.cursor()\n    count = cursor.execute(sql)\n    if count != 0:\n        print(count)\n        cursor.scroll(0, mode='absolute')\n        results = cursor.fetchall()\n        fields = cursor.description\n        workbook = xlwt.Workbook()\n        sheet = workbook.add_sheet('building', cell_overwrite_ok=True)\n\n        for field in range(0, len(fields)):\n            sheet.write(0, field, fields[field][0])\n\n        row = 1\n        col = 0\n        for row in range(1, len(results)+1):\n            for col in range(0, len(fields)):\n                if results[row-1][col] != None:\n                    sheet.write(row, col, u'%s'%results[row-1][col])\n                else:\n                    val = ''\n                    sheet.write(row, col, u'%s'%val)\n        workbook.save(out_path)\nif __name__ == '__main__':\n\t# 执行的sql语句\n\tsql = 'select * from sys_user'\n\tread_mysql_to_excel('1.xls', sql)\n```\n\n* 就这样一个简单的 导出数据为excel格式的demo就完成了。\n* 如果有多个sql语句，只需要 hard code，在分别调用那个 `read_mysql_to_excel` 方法就好了。\n\n参考资料：[https://blog.csdn.net/tingzuhuitou/article/details/78749185](https://blog.csdn.net/tingzuhuitou/article/details/78749185 \"https://blog.csdn.net/tingzuhuitou/article/details/78749185\")\n","source":"_posts/python3-link-mysql-export.md","raw":"---\ntitle: 利用Python3 连接mysql 导出数据为excel格式\ncategory: python\ntags:\n  - python\n  - mysql\nabbrlink: 21a7feb2\ndate: 2018-07-09 00:00:00\n---\n## 背景\n最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。\n才开始觉得sql每次都是固定不变，总量也不多，就通过 MySQL workbench 一条一条查询导出为 *.csv文件，但是发现 *.csv文件直接打开会出现中文乱码，就需要转码，我就通过Notepad++ 打开csv文件，设置文件格式 utf-8 bom 编码。这一系列步骤下来。人都不好了。\n后面自己受不了了，就想通过脚本来解决这个重复性工作。我是一个Java开发者，就准备用Java来实现这个工作，但是后面发现Java来解决这个问题，有点太麻烦了，需要连接MySQL，查询数据，通过poi遍历做成poi对应excel的hssfworkbook对象（或者xssfworkbook），然后通过io流输出成excel文件。想到这些，就直接放弃了用Java来实现这个工作了。\n后面想到了Python，我对Python不熟。就在网上查找了一些资料，发现还是满简单的了。就这样决定用Python来实现了。\n## 具体实现\n下面是Python的具体实现代码：\n\n```python\n# coding:utf8\nimport sys\nimport xlwt\n#import MySQLdb\nimport pymysql as MySQLdb\nimport datetime\n\ndef get_conn_mysql():\n    conn = MySQLdb.connect(host='localhost', port=3306, user='root', passwd='root', db='test', charset='utf8')\n    return conn\ndef query_data(cur, sql, args):\n    cur.execute(sql, args)\n    return cur.fetchall()\n\n# out_path 保存的路径， sql： 需要执行的语句\ndef read_mysql_to_excel(out_path, sql):\n    conn = get_conn_mysql()\n    cursor = conn.cursor()\n    count = cursor.execute(sql)\n    if count != 0:\n        print(count)\n        cursor.scroll(0, mode='absolute')\n        results = cursor.fetchall()\n        fields = cursor.description\n        workbook = xlwt.Workbook()\n        sheet = workbook.add_sheet('building', cell_overwrite_ok=True)\n\n        for field in range(0, len(fields)):\n            sheet.write(0, field, fields[field][0])\n\n        row = 1\n        col = 0\n        for row in range(1, len(results)+1):\n            for col in range(0, len(fields)):\n                if results[row-1][col] != None:\n                    sheet.write(row, col, u'%s'%results[row-1][col])\n                else:\n                    val = ''\n                    sheet.write(row, col, u'%s'%val)\n        workbook.save(out_path)\nif __name__ == '__main__':\n\t# 执行的sql语句\n\tsql = 'select * from sys_user'\n\tread_mysql_to_excel('1.xls', sql)\n```\n\n* 就这样一个简单的 导出数据为excel格式的demo就完成了。\n* 如果有多个sql语句，只需要 hard code，在分别调用那个 `read_mysql_to_excel` 方法就好了。\n\n参考资料：[https://blog.csdn.net/tingzuhuitou/article/details/78749185](https://blog.csdn.net/tingzuhuitou/article/details/78749185 \"https://blog.csdn.net/tingzuhuitou/article/details/78749185\")\n","slug":"python3-link-mysql-export","published":1,"updated":"2019-12-23T10:59:48.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphn001mi3slywkjtrc6","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。<br>才开始觉得sql每次都是固定不变，总量也不多，就通过 MySQL workbench 一条一条查询导出为 <em>.csv文件，但是发现 </em>.csv文件直接打开会出现中文乱码，就需要转码，我就通过Notepad++ 打开csv文件，设置文件格式 utf-8 bom 编码。这一系列步骤下来。人都不好了。<br>后面自己受不了了，就想通过脚本来解决这个重复性工作。我是一个Java开发者，就准备用Java来实现这个工作，但是后面发现Java来解决这个问题，有点太麻烦了，需要连接MySQL，查询数据，通过poi遍历做成poi对应excel的hssfworkbook对象（或者xssfworkbook），然后通过io流输出成excel文件。想到这些，就直接放弃了用Java来实现这个工作了。<br>后面想到了Python，我对Python不熟。就在网上查找了一些资料，发现还是满简单的了。就这样决定用Python来实现了。</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>下面是Python的具体实现代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding:utf8</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> xlwt</span><br><span class=\"line\"><span class=\"comment\">#import MySQLdb</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql <span class=\"keyword\">as</span> MySQLdb</span><br><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_conn_mysql</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    conn = MySQLdb.connect(host=<span class=\"string\">'localhost'</span>, port=<span class=\"number\">3306</span>, user=<span class=\"string\">'root'</span>, passwd=<span class=\"string\">'root'</span>, db=<span class=\"string\">'test'</span>, charset=<span class=\"string\">'utf8'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_data</span><span class=\"params\">(cur, sql, args)</span>:</span></span><br><span class=\"line\">    cur.execute(sql, args)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur.fetchall()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># out_path 保存的路径， sql： 需要执行的语句</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_mysql_to_excel</span><span class=\"params\">(out_path, sql)</span>:</span></span><br><span class=\"line\">    conn = get_conn_mysql()</span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    count = cursor.execute(sql)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> count != <span class=\"number\">0</span>:</span><br><span class=\"line\">        print(count)</span><br><span class=\"line\">        cursor.scroll(<span class=\"number\">0</span>, mode=<span class=\"string\">'absolute'</span>)</span><br><span class=\"line\">        results = cursor.fetchall()</span><br><span class=\"line\">        fields = cursor.description</span><br><span class=\"line\">        workbook = xlwt.Workbook()</span><br><span class=\"line\">        sheet = workbook.add_sheet(<span class=\"string\">'building'</span>, cell_overwrite_ok=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(fields)):</span><br><span class=\"line\">            sheet.write(<span class=\"number\">0</span>, field, fields[field][<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        row = <span class=\"number\">1</span></span><br><span class=\"line\">        col = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(results)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(fields)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> results[row<span class=\"number\">-1</span>][col] != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                    sheet.write(row, col, <span class=\"string\">u'%s'</span>%results[row<span class=\"number\">-1</span>][col])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    val = <span class=\"string\">''</span></span><br><span class=\"line\">                    sheet.write(row, col, <span class=\"string\">u'%s'</span>%val)</span><br><span class=\"line\">        workbook.save(out_path)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">\t<span class=\"comment\"># 执行的sql语句</span></span><br><span class=\"line\">\tsql = <span class=\"string\">'select * from sys_user'</span></span><br><span class=\"line\">\tread_mysql_to_excel(<span class=\"string\">'1.xls'</span>, sql)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>就这样一个简单的 导出数据为excel格式的demo就完成了。</li>\n<li>如果有多个sql语句，只需要 hard code，在分别调用那个 <code>read_mysql_to_excel</code> 方法就好了。</li>\n</ul>\n<p>参考资料：<a href=\"https://blog.csdn.net/tingzuhuitou/article/details/78749185\" title=\"https://blog.csdn.net/tingzuhuitou/article/details/78749185\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tingzuhuitou/article/details/78749185</a></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近在工作中，遇到每隔一段时间都要跑一次数据校验。大概有15个sql语句，需要将这15个sql语句查询的记录导出并且存为excel格式。<br>才开始觉得sql每次都是固定不变，总量也不多，就通过 MySQL workbench 一条一条查询导出为 <em>.csv文件，但是发现 </em>.csv文件直接打开会出现中文乱码，就需要转码，我就通过Notepad++ 打开csv文件，设置文件格式 utf-8 bom 编码。这一系列步骤下来。人都不好了。<br>后面自己受不了了，就想通过脚本来解决这个重复性工作。我是一个Java开发者，就准备用Java来实现这个工作，但是后面发现Java来解决这个问题，有点太麻烦了，需要连接MySQL，查询数据，通过poi遍历做成poi对应excel的hssfworkbook对象（或者xssfworkbook），然后通过io流输出成excel文件。想到这些，就直接放弃了用Java来实现这个工作了。<br>后面想到了Python，我对Python不熟。就在网上查找了一些资料，发现还是满简单的了。就这样决定用Python来实现了。</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>下面是Python的具体实现代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding:utf8</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> xlwt</span><br><span class=\"line\"><span class=\"comment\">#import MySQLdb</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql <span class=\"keyword\">as</span> MySQLdb</span><br><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_conn_mysql</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    conn = MySQLdb.connect(host=<span class=\"string\">'localhost'</span>, port=<span class=\"number\">3306</span>, user=<span class=\"string\">'root'</span>, passwd=<span class=\"string\">'root'</span>, db=<span class=\"string\">'test'</span>, charset=<span class=\"string\">'utf8'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">query_data</span><span class=\"params\">(cur, sql, args)</span>:</span></span><br><span class=\"line\">    cur.execute(sql, args)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur.fetchall()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># out_path 保存的路径， sql： 需要执行的语句</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_mysql_to_excel</span><span class=\"params\">(out_path, sql)</span>:</span></span><br><span class=\"line\">    conn = get_conn_mysql()</span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    count = cursor.execute(sql)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> count != <span class=\"number\">0</span>:</span><br><span class=\"line\">        print(count)</span><br><span class=\"line\">        cursor.scroll(<span class=\"number\">0</span>, mode=<span class=\"string\">'absolute'</span>)</span><br><span class=\"line\">        results = cursor.fetchall()</span><br><span class=\"line\">        fields = cursor.description</span><br><span class=\"line\">        workbook = xlwt.Workbook()</span><br><span class=\"line\">        sheet = workbook.add_sheet(<span class=\"string\">'building'</span>, cell_overwrite_ok=<span class=\"keyword\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> field <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(fields)):</span><br><span class=\"line\">            sheet.write(<span class=\"number\">0</span>, field, fields[field][<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        row = <span class=\"number\">1</span></span><br><span class=\"line\">        col = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(results)+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> col <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(fields)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> results[row<span class=\"number\">-1</span>][col] != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                    sheet.write(row, col, <span class=\"string\">u'%s'</span>%results[row<span class=\"number\">-1</span>][col])</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    val = <span class=\"string\">''</span></span><br><span class=\"line\">                    sheet.write(row, col, <span class=\"string\">u'%s'</span>%val)</span><br><span class=\"line\">        workbook.save(out_path)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">\t<span class=\"comment\"># 执行的sql语句</span></span><br><span class=\"line\">\tsql = <span class=\"string\">'select * from sys_user'</span></span><br><span class=\"line\">\tread_mysql_to_excel(<span class=\"string\">'1.xls'</span>, sql)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>就这样一个简单的 导出数据为excel格式的demo就完成了。</li>\n<li>如果有多个sql语句，只需要 hard code，在分别调用那个 <code>read_mysql_to_excel</code> 方法就好了。</li>\n</ul>\n<p>参考资料：<a href=\"https://blog.csdn.net/tingzuhuitou/article/details/78749185\" title=\"https://blog.csdn.net/tingzuhuitou/article/details/78749185\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tingzuhuitou/article/details/78749185</a></p>\n"},{"title":"Java 短链接项目","abbrlink":"8913fd1b","date":"2018-07-30T16:00:00.000Z","_content":"# 需求\n将很长的http请求的地址，转为短链接。如下所示：\n![](http://www.myluffy.com/wp-content/uploads/2018/07/112a80391435658790d15308b377aba3.png)\n为什么要转短链，短链接可以转发给第三方的时候，能轻易识别，我在开发中有遇到过一次，别人分享给我的地址里面包含了一些特殊字符（$、&）等，我在我的微信里面，直接点击地址，只识别到特殊字符的前半部分，没有整个链接识别完成。\n## 短链服务的作用：\n- 将长链接变为短链接，当然是越短越好\n- 用户点击短链接的时候，实现自动跳转到原来的长链接\n\n## 原理解析\n- 在游览器地址栏输入短链接地址：如 http://domain/shUESS\n- 游览器会将domain解析为ip地址，得到IP地址之后，会向这个IP发送请求。\n- 后台接收到shUESS字符之后，去对应的存储中查询出原网址。\n- 通过重定向调转到原网址。\n\n# 实现\ndemo使用springboot完成，相关依赖如下：\n```\n\t\t<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n\t\t<!-- MD5加密 -->\n        <dependency>\n            <groupId>commons-codec</groupId>\n            <artifactId>commons-codec</artifactId>\n            <version>1.5</version>\n        </dependency>\n```\n\n## 长链接转短链接\n将一长串的链接，转为4至6个字符，我是使用MySQL做存储，用来存储，转换之后的字符 short_key和原来的链接originalUrl；\n表结构简单版本如下：\n- id: 主键ID，自动递增\n- short_key: 转换之后的字符，正式环境数据量很大，可以建立索引\n- originalUrl: 原来的网址\n\n本文采用MD5加密算法\n对传入网址进行MD5加密，并且将加密之后的字符串，分为4部分分别于0x3FFFFFFF 进行位与运算，生成4个字符串，4个字符串都可以使用。\n加密核心代码如下：\n```java\npublic static String[] shortUrl(String url) {\n        // 可以自定义生成 MD5 加密字符传前的混合 KEY\n        String key = \"\";\n        // 要使用生成 URL 的字符\n        String[] chars = new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\n                \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\",\n                \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\",\n                \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n                \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\",\n                \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n\n        // 对传入网址进行 MD5 加密\n        String sMD5EncryptResult = DigestUtils.md5Hex(key + url);\n        String hex = sMD5EncryptResult;\n        String[] resUrl = new String[4];\n        for (int i = 0; i < 4; i++) {\n            // 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算\n            String sTempSubString = hex.substring(i * 8, i * 8 + 8);\n            // 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用\n            // long ，则会越界\n            long lHexLong = 0x3FFFFFFF & Long.parseLong(sTempSubString, 16);\n            String outChars = \"\";\n            for (int j = 0; j < 6; j++) {\n                // 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引\n                long index = 0x0000003D & lHexLong;\n                // 把取得的字符相加\n                outChars += chars[(int) index];\n                // 每次循环按位右移 5 位\n                lHexLong = lHexLong >> 5;\n            }\n\n            // 把字符串存入对应索引的输出数组\n            resUrl[i] = outChars;\n        }\n        return resUrl;\n    }\n```\n\n## 短链接转长链接\n有了长链接转短链接之后，这一步就简单多了。\n通过请求的地址，得到short_key,去查询出对应的原网址，再重定向到原网址即可。\n代码如下：\n```java\n@RequestMapping(\"/{key}\")\npublic String find(@PathVariable String key) {\n\tif (StringUtils.isEmpty(key)) {\n\t\treturn \"error\";\n\t}\n\tShortUrl byShortKey = repository.getByShortKey(key);\n\tif (byShortKey == null) {\n\t\treturn \"error\";\n\t}\n\n\treturn \"redirect:\" + byShortKey.getOriginalUrl();\n}\n```\n\n完整项目已上传到[github](https://github.com/waynecoder/springboot-example/tree/master/short-url \"short_url\")\n\n# 参考\n[https://blog.csdn.net/yushouling/article/details/55096992](https://blog.csdn.net/yushouling/article/details/55096992 \"https://blog.csdn.net/yushouling/article/details/55096992\")\n","source":"_posts/shorturl-project-java.md","raw":"---\ntitle: Java 短链接项目\ncategory: Java\ntags:\n  - java\n  - spring\n  - springboot\nabbrlink: 8913fd1b\ndate: 2018-07-31 00:00:00\n---\n# 需求\n将很长的http请求的地址，转为短链接。如下所示：\n![](http://www.myluffy.com/wp-content/uploads/2018/07/112a80391435658790d15308b377aba3.png)\n为什么要转短链，短链接可以转发给第三方的时候，能轻易识别，我在开发中有遇到过一次，别人分享给我的地址里面包含了一些特殊字符（$、&）等，我在我的微信里面，直接点击地址，只识别到特殊字符的前半部分，没有整个链接识别完成。\n## 短链服务的作用：\n- 将长链接变为短链接，当然是越短越好\n- 用户点击短链接的时候，实现自动跳转到原来的长链接\n\n## 原理解析\n- 在游览器地址栏输入短链接地址：如 http://domain/shUESS\n- 游览器会将domain解析为ip地址，得到IP地址之后，会向这个IP发送请求。\n- 后台接收到shUESS字符之后，去对应的存储中查询出原网址。\n- 通过重定向调转到原网址。\n\n# 实现\ndemo使用springboot完成，相关依赖如下：\n```\n\t\t<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n\t\t<!-- MD5加密 -->\n        <dependency>\n            <groupId>commons-codec</groupId>\n            <artifactId>commons-codec</artifactId>\n            <version>1.5</version>\n        </dependency>\n```\n\n## 长链接转短链接\n将一长串的链接，转为4至6个字符，我是使用MySQL做存储，用来存储，转换之后的字符 short_key和原来的链接originalUrl；\n表结构简单版本如下：\n- id: 主键ID，自动递增\n- short_key: 转换之后的字符，正式环境数据量很大，可以建立索引\n- originalUrl: 原来的网址\n\n本文采用MD5加密算法\n对传入网址进行MD5加密，并且将加密之后的字符串，分为4部分分别于0x3FFFFFFF 进行位与运算，生成4个字符串，4个字符串都可以使用。\n加密核心代码如下：\n```java\npublic static String[] shortUrl(String url) {\n        // 可以自定义生成 MD5 加密字符传前的混合 KEY\n        String key = \"\";\n        // 要使用生成 URL 的字符\n        String[] chars = new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\n                \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\",\n                \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\",\n                \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n                \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\",\n                \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n\n        // 对传入网址进行 MD5 加密\n        String sMD5EncryptResult = DigestUtils.md5Hex(key + url);\n        String hex = sMD5EncryptResult;\n        String[] resUrl = new String[4];\n        for (int i = 0; i < 4; i++) {\n            // 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算\n            String sTempSubString = hex.substring(i * 8, i * 8 + 8);\n            // 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用\n            // long ，则会越界\n            long lHexLong = 0x3FFFFFFF & Long.parseLong(sTempSubString, 16);\n            String outChars = \"\";\n            for (int j = 0; j < 6; j++) {\n                // 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引\n                long index = 0x0000003D & lHexLong;\n                // 把取得的字符相加\n                outChars += chars[(int) index];\n                // 每次循环按位右移 5 位\n                lHexLong = lHexLong >> 5;\n            }\n\n            // 把字符串存入对应索引的输出数组\n            resUrl[i] = outChars;\n        }\n        return resUrl;\n    }\n```\n\n## 短链接转长链接\n有了长链接转短链接之后，这一步就简单多了。\n通过请求的地址，得到short_key,去查询出对应的原网址，再重定向到原网址即可。\n代码如下：\n```java\n@RequestMapping(\"/{key}\")\npublic String find(@PathVariable String key) {\n\tif (StringUtils.isEmpty(key)) {\n\t\treturn \"error\";\n\t}\n\tShortUrl byShortKey = repository.getByShortKey(key);\n\tif (byShortKey == null) {\n\t\treturn \"error\";\n\t}\n\n\treturn \"redirect:\" + byShortKey.getOriginalUrl();\n}\n```\n\n完整项目已上传到[github](https://github.com/waynecoder/springboot-example/tree/master/short-url \"short_url\")\n\n# 参考\n[https://blog.csdn.net/yushouling/article/details/55096992](https://blog.csdn.net/yushouling/article/details/55096992 \"https://blog.csdn.net/yushouling/article/details/55096992\")\n","slug":"shorturl-project-java","published":1,"updated":"2019-12-23T10:59:48.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphp001ri3slk9wp9gv7","content":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>将很长的http请求的地址，转为短链接。如下所示：<br><img src=\"http://www.myluffy.com/wp-content/uploads/2018/07/112a80391435658790d15308b377aba3.png\" alt><br>为什么要转短链，短链接可以转发给第三方的时候，能轻易识别，我在开发中有遇到过一次，别人分享给我的地址里面包含了一些特殊字符（$、&amp;）等，我在我的微信里面，直接点击地址，只识别到特殊字符的前半部分，没有整个链接识别完成。</p>\n<h2 id=\"短链服务的作用：\"><a href=\"#短链服务的作用：\" class=\"headerlink\" title=\"短链服务的作用：\"></a>短链服务的作用：</h2><ul>\n<li>将长链接变为短链接，当然是越短越好</li>\n<li>用户点击短链接的时候，实现自动跳转到原来的长链接</li>\n</ul>\n<h2 id=\"原理解析\"><a href=\"#原理解析\" class=\"headerlink\" title=\"原理解析\"></a>原理解析</h2><ul>\n<li>在游览器地址栏输入短链接地址：如 <a href=\"http://domain/shUESS\" target=\"_blank\" rel=\"noopener\">http://domain/shUESS</a></li>\n<li>游览器会将domain解析为ip地址，得到IP地址之后，会向这个IP发送请求。</li>\n<li>后台接收到shUESS字符之后，去对应的存储中查询出原网址。</li>\n<li>通过重定向调转到原网址。</li>\n</ul>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>demo使用springboot完成，相关依赖如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- MD5加密 --&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class=\"line\">          &lt;version&gt;1.5&lt;/version&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"长链接转短链接\"><a href=\"#长链接转短链接\" class=\"headerlink\" title=\"长链接转短链接\"></a>长链接转短链接</h2><p>将一长串的链接，转为4至6个字符，我是使用MySQL做存储，用来存储，转换之后的字符 short_key和原来的链接originalUrl；<br>表结构简单版本如下：</p>\n<ul>\n<li>id: 主键ID，自动递增</li>\n<li>short_key: 转换之后的字符，正式环境数据量很大，可以建立索引</li>\n<li>originalUrl: 原来的网址</li>\n</ul>\n<p>本文采用MD5加密算法<br>对传入网址进行MD5加密，并且将加密之后的字符串，分为4部分分别于0x3FFFFFFF 进行位与运算，生成4个字符串，4个字符串都可以使用。<br>加密核心代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] shortUrl(String url) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以自定义生成 MD5 加密字符传前的混合 KEY</span></span><br><span class=\"line\">        String key = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 要使用生成 URL 的字符</span></span><br><span class=\"line\">        String[] chars = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>, <span class=\"string\">\"g\"</span>, <span class=\"string\">\"h\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"i\"</span>, <span class=\"string\">\"j\"</span>, <span class=\"string\">\"k\"</span>, <span class=\"string\">\"l\"</span>, <span class=\"string\">\"m\"</span>, <span class=\"string\">\"n\"</span>, <span class=\"string\">\"o\"</span>, <span class=\"string\">\"p\"</span>, <span class=\"string\">\"q\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"string\">\"s\"</span>, <span class=\"string\">\"t\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"u\"</span>, <span class=\"string\">\"v\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"string\">\"x\"</span>, <span class=\"string\">\"y\"</span>, <span class=\"string\">\"z\"</span>, <span class=\"string\">\"0\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"6\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"I\"</span>, <span class=\"string\">\"J\"</span>, <span class=\"string\">\"K\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"N\"</span>, <span class=\"string\">\"O\"</span>, <span class=\"string\">\"P\"</span>, <span class=\"string\">\"Q\"</span>, <span class=\"string\">\"R\"</span>, <span class=\"string\">\"S\"</span>, <span class=\"string\">\"T\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"U\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"W\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"Y\"</span>, <span class=\"string\">\"Z\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对传入网址进行 MD5 加密</span></span><br><span class=\"line\">        String sMD5EncryptResult = DigestUtils.md5Hex(key + url);</span><br><span class=\"line\">        String hex = sMD5EncryptResult;</span><br><span class=\"line\">        String[] resUrl = <span class=\"keyword\">new</span> String[<span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算</span></span><br><span class=\"line\">            String sTempSubString = hex.substring(i * <span class=\"number\">8</span>, i * <span class=\"number\">8</span> + <span class=\"number\">8</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用</span></span><br><span class=\"line\">            <span class=\"comment\">// long ，则会越界</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> lHexLong = <span class=\"number\">0x3FFFFFFF</span> &amp; Long.parseLong(sTempSubString, <span class=\"number\">16</span>);</span><br><span class=\"line\">            String outChars = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">6</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> index = <span class=\"number\">0x0000003D</span> &amp; lHexLong;</span><br><span class=\"line\">                <span class=\"comment\">// 把取得的字符相加</span></span><br><span class=\"line\">                outChars += chars[(<span class=\"keyword\">int</span>) index];</span><br><span class=\"line\">                <span class=\"comment\">// 每次循环按位右移 5 位</span></span><br><span class=\"line\">                lHexLong = lHexLong &gt;&gt; <span class=\"number\">5</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 把字符串存入对应索引的输出数组</span></span><br><span class=\"line\">            resUrl[i] = outChars;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resUrl;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"短链接转长链接\"><a href=\"#短链接转长链接\" class=\"headerlink\" title=\"短链接转长链接\"></a>短链接转长链接</h2><p>有了长链接转短链接之后，这一步就简单多了。<br>通过请求的地址，得到short_key,去查询出对应的原网址，再重定向到原网址即可。<br>代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;key&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">find</span><span class=\"params\">(@PathVariable String key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (StringUtils.isEmpty(key)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tShortUrl byShortKey = repository.getByShortKey(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (byShortKey == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"redirect:\"</span> + byShortKey.getOriginalUrl();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完整项目已上传到<a href=\"https://github.com/waynecoder/springboot-example/tree/master/short-url\" title=\"short_url\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://blog.csdn.net/yushouling/article/details/55096992\" title=\"https://blog.csdn.net/yushouling/article/details/55096992\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yushouling/article/details/55096992</a></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>将很长的http请求的地址，转为短链接。如下所示：<br><img src=\"http://www.myluffy.com/wp-content/uploads/2018/07/112a80391435658790d15308b377aba3.png\" alt><br>为什么要转短链，短链接可以转发给第三方的时候，能轻易识别，我在开发中有遇到过一次，别人分享给我的地址里面包含了一些特殊字符（$、&amp;）等，我在我的微信里面，直接点击地址，只识别到特殊字符的前半部分，没有整个链接识别完成。</p>\n<h2 id=\"短链服务的作用：\"><a href=\"#短链服务的作用：\" class=\"headerlink\" title=\"短链服务的作用：\"></a>短链服务的作用：</h2><ul>\n<li>将长链接变为短链接，当然是越短越好</li>\n<li>用户点击短链接的时候，实现自动跳转到原来的长链接</li>\n</ul>\n<h2 id=\"原理解析\"><a href=\"#原理解析\" class=\"headerlink\" title=\"原理解析\"></a>原理解析</h2><ul>\n<li>在游览器地址栏输入短链接地址：如 <a href=\"http://domain/shUESS\" target=\"_blank\" rel=\"noopener\">http://domain/shUESS</a></li>\n<li>游览器会将domain解析为ip地址，得到IP地址之后，会向这个IP发送请求。</li>\n<li>后台接收到shUESS字符之后，去对应的存储中查询出原网址。</li>\n<li>通过重定向调转到原网址。</li>\n</ul>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p>demo使用springboot完成，相关依赖如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- MD5加密 --&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class=\"line\">          &lt;version&gt;1.5&lt;/version&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"长链接转短链接\"><a href=\"#长链接转短链接\" class=\"headerlink\" title=\"长链接转短链接\"></a>长链接转短链接</h2><p>将一长串的链接，转为4至6个字符，我是使用MySQL做存储，用来存储，转换之后的字符 short_key和原来的链接originalUrl；<br>表结构简单版本如下：</p>\n<ul>\n<li>id: 主键ID，自动递增</li>\n<li>short_key: 转换之后的字符，正式环境数据量很大，可以建立索引</li>\n<li>originalUrl: 原来的网址</li>\n</ul>\n<p>本文采用MD5加密算法<br>对传入网址进行MD5加密，并且将加密之后的字符串，分为4部分分别于0x3FFFFFFF 进行位与运算，生成4个字符串，4个字符串都可以使用。<br>加密核心代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] shortUrl(String url) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以自定义生成 MD5 加密字符传前的混合 KEY</span></span><br><span class=\"line\">        String key = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 要使用生成 URL 的字符</span></span><br><span class=\"line\">        String[] chars = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"f\"</span>, <span class=\"string\">\"g\"</span>, <span class=\"string\">\"h\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"i\"</span>, <span class=\"string\">\"j\"</span>, <span class=\"string\">\"k\"</span>, <span class=\"string\">\"l\"</span>, <span class=\"string\">\"m\"</span>, <span class=\"string\">\"n\"</span>, <span class=\"string\">\"o\"</span>, <span class=\"string\">\"p\"</span>, <span class=\"string\">\"q\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"string\">\"s\"</span>, <span class=\"string\">\"t\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"u\"</span>, <span class=\"string\">\"v\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"string\">\"x\"</span>, <span class=\"string\">\"y\"</span>, <span class=\"string\">\"z\"</span>, <span class=\"string\">\"0\"</span>, <span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>, <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"6\"</span>, <span class=\"string\">\"7\"</span>, <span class=\"string\">\"8\"</span>, <span class=\"string\">\"9\"</span>, <span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"I\"</span>, <span class=\"string\">\"J\"</span>, <span class=\"string\">\"K\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"M\"</span>, <span class=\"string\">\"N\"</span>, <span class=\"string\">\"O\"</span>, <span class=\"string\">\"P\"</span>, <span class=\"string\">\"Q\"</span>, <span class=\"string\">\"R\"</span>, <span class=\"string\">\"S\"</span>, <span class=\"string\">\"T\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"U\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"W\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"Y\"</span>, <span class=\"string\">\"Z\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对传入网址进行 MD5 加密</span></span><br><span class=\"line\">        String sMD5EncryptResult = DigestUtils.md5Hex(key + url);</span><br><span class=\"line\">        String hex = sMD5EncryptResult;</span><br><span class=\"line\">        String[] resUrl = <span class=\"keyword\">new</span> String[<span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算</span></span><br><span class=\"line\">            String sTempSubString = hex.substring(i * <span class=\"number\">8</span>, i * <span class=\"number\">8</span> + <span class=\"number\">8</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用</span></span><br><span class=\"line\">            <span class=\"comment\">// long ，则会越界</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> lHexLong = <span class=\"number\">0x3FFFFFFF</span> &amp; Long.parseLong(sTempSubString, <span class=\"number\">16</span>);</span><br><span class=\"line\">            String outChars = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">6</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> index = <span class=\"number\">0x0000003D</span> &amp; lHexLong;</span><br><span class=\"line\">                <span class=\"comment\">// 把取得的字符相加</span></span><br><span class=\"line\">                outChars += chars[(<span class=\"keyword\">int</span>) index];</span><br><span class=\"line\">                <span class=\"comment\">// 每次循环按位右移 5 位</span></span><br><span class=\"line\">                lHexLong = lHexLong &gt;&gt; <span class=\"number\">5</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 把字符串存入对应索引的输出数组</span></span><br><span class=\"line\">            resUrl[i] = outChars;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resUrl;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"短链接转长链接\"><a href=\"#短链接转长链接\" class=\"headerlink\" title=\"短链接转长链接\"></a>短链接转长链接</h2><p>有了长链接转短链接之后，这一步就简单多了。<br>通过请求的地址，得到short_key,去查询出对应的原网址，再重定向到原网址即可。<br>代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/&#123;key&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">find</span><span class=\"params\">(@PathVariable String key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (StringUtils.isEmpty(key)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tShortUrl byShortKey = repository.getByShortKey(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (byShortKey == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"redirect:\"</span> + byShortKey.getOriginalUrl();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完整项目已上传到<a href=\"https://github.com/waynecoder/springboot-example/tree/master/short-url\" title=\"short_url\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://blog.csdn.net/yushouling/article/details/55096992\" title=\"https://blog.csdn.net/yushouling/article/details/55096992\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yushouling/article/details/55096992</a></p>\n"},{"title":"通过Spring发送邮件","abbrlink":"390cf6e4","date":"2017-09-18T16:00:00.000Z","_content":"记录一次在工作使用Spring框架，发送邮件的demo。\n## 依赖\n注意一下，我使用的是gradle，使用maven的需要通过maven的方式引入jar包依赖。\n```groovy\ncompile group: 'com.sun.mail', name: 'javax.mail', version: '1.6.0'\ncompile group: 'org.apache.velocity', name: 'velocity', version: '1.7'\ncompile 'org.springframework:spring-context-support'\n```\n## 具体实现\n```java\n@Service\npublic class MailServiceImpl implements MailService {\n    @Autowired\n    private JavaMailSender mailSender;\n\n    public VelocityEngine getVelocityEngine() {\n        VelocityEngine velocityEngine = new VelocityEngine();\n        velocityEngine.setProperty(\"resource.loader\", \"class\");\n        velocityEngine.setProperty(\"class.resource.loader.class\", \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\");\n        velocityEngine.setProperty(\"input.encoding\", \"UTF-8\");\n        velocityEngine.setProperty(\"output.encoding\", \"UTF-8\");\n        velocityEngine.init();\n        return velocityEngine;\n    }\n\n    private static MimeMessageHelper helper(MimeMessage mimeMessage)throws Exception{\n        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);\n        List<String> tos = new ArrayList<>();\n\t\t// 接收邮件的地址 集合 可以为多个\n//        tos.add(\"service@*.com\");\n        tos.add(\"service2@*.com\");\n        helper.setFrom(\"service@*.com\");\n        String[] strings = (String[])tos.toArray(new String[tos.size()]);\n        helper.setTo(strings);\n        return helper;\n    }\n    @Override\n    public void sendMail(Map<String, Object> map) throws Exception {\n        MimeMessage mimeMessage = mailSender.createMimeMessage();\n        MimeMessageHelper helper = helper(mimeMessage);\n\t\t// 设置邮件主题\n        helper.setSubject(\"overdue\");\n\t\t// 需要填充到模板中的内容\n        Map<String, Object> model = new HashedMap();\n        model.put(\"hospital\", map.get(\"hospital\"));\n\t\t\n        String template = (String) map.get(\"template\");\n\t\t// 得到模板 并填充内容，模板地址根据自己的实际情况所定\n        String text = VelocityEngineUtils.mergeTemplateIntoString(\n                getVelocityEngine(), \"template/\" + template, \"UTF-8\", model);\n        helper.setText(text, true);\n\t\t//  发送邮件\n        mailSender.send(mimeMessage);\n    }\n}\n\n```\n\n## 模板实例\n在resources目录下，新建一个template文件夹，新建一个 *.vm 文件，注意文件后缀为 ``.vm``\n如图所示：\n![](http://www.myluffy.com/wp-content/uploads/2018/06/2c30c54a83059f6cde42ee9e04a56a2e.png)\n\n模板中内容为：\n```html\n<html>\n<body>\n<div>\n    test\n    <p>hospital: ${hospital}</p>\n</div>\n</body>\n</html>\n```\n** 注意 ``${hospital}`` 和service中model字段相对应。\n\n## 配置发送邮件的密码\n基本代码写好之后，我们需要在 ``application.yml`` 中配置一下邮件的用户名密码等；\n```groovy\nspring:\n  mail:\n    default-encoding: utf-8\n    host: smtp.exmail.qq.com # 邮箱host，不同的邮箱host是不一样的，这个列子是腾讯企业邮的，具体可以google。\n    username: service@*.com # 发送邮箱的用户名， 替换为自己的\n    password: 123456 # 填写自己邮箱的密码，如果是QQ邮箱，应该是需要填写授权码\n```\n\n## 测试用例\n现在基本代码洗好了，我们接着写一个测试用例\n我的项目所用的是springboot，具体情况视自己项目的情况而定。\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n@SpringBootTest(classes = OverdueApplication.class)\n@ActiveProfiles(\"ubuntu\")\n@Ignore\npublic class MailTest {\n\n    @Autowired\n    private MailService mailService;\n\n    @Test\n    public void testSendMail() {\n        Map<String, Object> map = new HashMap<>();\n\t\t// 模板中的变量\n        map.put(\"hospital\", \"test hospital\");\n\t\t// 对应的邮件模板 文件名\n        map.put(\"template\", \"overdueMail.vm\");\n        try {\n            mailService.sendMail(map);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n```\n\n## 结果\n![](http://www.myluffy.com/wp-content/uploads/2018/06/38dc06f8e7ed4df81bd4867d54192dd0.png)\n\n这样，一件简单的邮件模板发送就成功了。","source":"_posts/spring-sendmail.md","raw":"---\ntitle: 通过Spring发送邮件\ncategory:\n  - Java\ntags:\n  - spring\n  - java\nabbrlink: 390cf6e4\ndate: 2017-09-19 00:00:00\n---\n记录一次在工作使用Spring框架，发送邮件的demo。\n## 依赖\n注意一下，我使用的是gradle，使用maven的需要通过maven的方式引入jar包依赖。\n```groovy\ncompile group: 'com.sun.mail', name: 'javax.mail', version: '1.6.0'\ncompile group: 'org.apache.velocity', name: 'velocity', version: '1.7'\ncompile 'org.springframework:spring-context-support'\n```\n## 具体实现\n```java\n@Service\npublic class MailServiceImpl implements MailService {\n    @Autowired\n    private JavaMailSender mailSender;\n\n    public VelocityEngine getVelocityEngine() {\n        VelocityEngine velocityEngine = new VelocityEngine();\n        velocityEngine.setProperty(\"resource.loader\", \"class\");\n        velocityEngine.setProperty(\"class.resource.loader.class\", \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\");\n        velocityEngine.setProperty(\"input.encoding\", \"UTF-8\");\n        velocityEngine.setProperty(\"output.encoding\", \"UTF-8\");\n        velocityEngine.init();\n        return velocityEngine;\n    }\n\n    private static MimeMessageHelper helper(MimeMessage mimeMessage)throws Exception{\n        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);\n        List<String> tos = new ArrayList<>();\n\t\t// 接收邮件的地址 集合 可以为多个\n//        tos.add(\"service@*.com\");\n        tos.add(\"service2@*.com\");\n        helper.setFrom(\"service@*.com\");\n        String[] strings = (String[])tos.toArray(new String[tos.size()]);\n        helper.setTo(strings);\n        return helper;\n    }\n    @Override\n    public void sendMail(Map<String, Object> map) throws Exception {\n        MimeMessage mimeMessage = mailSender.createMimeMessage();\n        MimeMessageHelper helper = helper(mimeMessage);\n\t\t// 设置邮件主题\n        helper.setSubject(\"overdue\");\n\t\t// 需要填充到模板中的内容\n        Map<String, Object> model = new HashedMap();\n        model.put(\"hospital\", map.get(\"hospital\"));\n\t\t\n        String template = (String) map.get(\"template\");\n\t\t// 得到模板 并填充内容，模板地址根据自己的实际情况所定\n        String text = VelocityEngineUtils.mergeTemplateIntoString(\n                getVelocityEngine(), \"template/\" + template, \"UTF-8\", model);\n        helper.setText(text, true);\n\t\t//  发送邮件\n        mailSender.send(mimeMessage);\n    }\n}\n\n```\n\n## 模板实例\n在resources目录下，新建一个template文件夹，新建一个 *.vm 文件，注意文件后缀为 ``.vm``\n如图所示：\n![](http://www.myluffy.com/wp-content/uploads/2018/06/2c30c54a83059f6cde42ee9e04a56a2e.png)\n\n模板中内容为：\n```html\n<html>\n<body>\n<div>\n    test\n    <p>hospital: ${hospital}</p>\n</div>\n</body>\n</html>\n```\n** 注意 ``${hospital}`` 和service中model字段相对应。\n\n## 配置发送邮件的密码\n基本代码写好之后，我们需要在 ``application.yml`` 中配置一下邮件的用户名密码等；\n```groovy\nspring:\n  mail:\n    default-encoding: utf-8\n    host: smtp.exmail.qq.com # 邮箱host，不同的邮箱host是不一样的，这个列子是腾讯企业邮的，具体可以google。\n    username: service@*.com # 发送邮箱的用户名， 替换为自己的\n    password: 123456 # 填写自己邮箱的密码，如果是QQ邮箱，应该是需要填写授权码\n```\n\n## 测试用例\n现在基本代码洗好了，我们接着写一个测试用例\n我的项目所用的是springboot，具体情况视自己项目的情况而定。\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n@SpringBootTest(classes = OverdueApplication.class)\n@ActiveProfiles(\"ubuntu\")\n@Ignore\npublic class MailTest {\n\n    @Autowired\n    private MailService mailService;\n\n    @Test\n    public void testSendMail() {\n        Map<String, Object> map = new HashMap<>();\n\t\t// 模板中的变量\n        map.put(\"hospital\", \"test hospital\");\n\t\t// 对应的邮件模板 文件名\n        map.put(\"template\", \"overdueMail.vm\");\n        try {\n            mailService.sendMail(map);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n```\n\n## 结果\n![](http://www.myluffy.com/wp-content/uploads/2018/06/38dc06f8e7ed4df81bd4867d54192dd0.png)\n\n这样，一件简单的邮件模板发送就成功了。","slug":"spring-sendmail","published":1,"updated":"2019-12-23T10:59:48.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphq001ui3slh9bv727q","content":"<p>记录一次在工作使用Spring框架，发送邮件的demo。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>注意一下，我使用的是gradle，使用maven的需要通过maven的方式引入jar包依赖。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">group:</span> <span class=\"string\">'com.sun.mail'</span>, <span class=\"string\">name:</span> <span class=\"string\">'javax.mail'</span>, <span class=\"string\">version:</span> <span class=\"string\">'1.6.0'</span></span><br><span class=\"line\">compile <span class=\"string\">group:</span> <span class=\"string\">'org.apache.velocity'</span>, <span class=\"string\">name:</span> <span class=\"string\">'velocity'</span>, <span class=\"string\">version:</span> <span class=\"string\">'1.7'</span></span><br><span class=\"line\">compile <span class=\"string\">'org.springframework:spring-context-support'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JavaMailSender mailSender;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> VelocityEngine <span class=\"title\">getVelocityEngine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        VelocityEngine velocityEngine = <span class=\"keyword\">new</span> VelocityEngine();</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"resource.loader\"</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"class.resource.loader.class\"</span>, <span class=\"string\">\"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\"</span>);</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"input.encoding\"</span>, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"output.encoding\"</span>, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">        velocityEngine.init();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> velocityEngine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MimeMessageHelper <span class=\"title\">helper</span><span class=\"params\">(MimeMessage mimeMessage)</span><span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        MimeMessageHelper helper = <span class=\"keyword\">new</span> MimeMessageHelper(mimeMessage, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        List&lt;String&gt; tos = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 接收邮件的地址 集合 可以为多个</span></span><br><span class=\"line\"><span class=\"comment\">//        tos.add(\"service@*.com\");</span></span><br><span class=\"line\">        tos.add(<span class=\"string\">\"service2@*.com\"</span>);</span><br><span class=\"line\">        helper.setFrom(<span class=\"string\">\"service@*.com\"</span>);</span><br><span class=\"line\">        String[] strings = (String[])tos.toArray(<span class=\"keyword\">new</span> String[tos.size()]);</span><br><span class=\"line\">        helper.setTo(strings);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMail</span><span class=\"params\">(Map&lt;String, Object&gt; map)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class=\"line\">        MimeMessageHelper helper = helper(mimeMessage);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置邮件主题</span></span><br><span class=\"line\">        helper.setSubject(<span class=\"string\">\"overdue\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 需要填充到模板中的内容</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; model = <span class=\"keyword\">new</span> HashedMap();</span><br><span class=\"line\">        model.put(<span class=\"string\">\"hospital\"</span>, map.get(<span class=\"string\">\"hospital\"</span>));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        String template = (String) map.get(<span class=\"string\">\"template\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 得到模板 并填充内容，模板地址根据自己的实际情况所定</span></span><br><span class=\"line\">        String text = VelocityEngineUtils.mergeTemplateIntoString(</span><br><span class=\"line\">                getVelocityEngine(), <span class=\"string\">\"template/\"</span> + template, <span class=\"string\">\"UTF-8\"</span>, model);</span><br><span class=\"line\">        helper.setText(text, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//  发送邮件</span></span><br><span class=\"line\">        mailSender.send(mimeMessage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板实例\"><a href=\"#模板实例\" class=\"headerlink\" title=\"模板实例\"></a>模板实例</h2><p>在resources目录下，新建一个template文件夹，新建一个 *.vm 文件，注意文件后缀为 <code>.vm</code><br>如图所示：<br><img src=\"http://www.myluffy.com/wp-content/uploads/2018/06/2c30c54a83059f6cde42ee9e04a56a2e.png\" alt></p>\n<p>模板中内容为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    test</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hospital: $&#123;hospital&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>** 注意 <code>${hospital}</code> 和service中model字段相对应。</p>\n<h2 id=\"配置发送邮件的密码\"><a href=\"#配置发送邮件的密码\" class=\"headerlink\" title=\"配置发送邮件的密码\"></a>配置发送邮件的密码</h2><p>基本代码写好之后，我们需要在 <code>application.yml</code> 中配置一下邮件的用户名密码等；<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring:</span></span><br><span class=\"line\"><span class=\"symbol\">  mail:</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>-<span class=\"string\">encoding:</span> utf<span class=\"number\">-8</span></span><br><span class=\"line\">    host: smtp.exmail.qq.com # 邮箱host，不同的邮箱host是不一样的，这个列子是腾讯企业邮的，具体可以google。</span><br><span class=\"line\">    username: service@*.com # 发送邮箱的用户名， 替换为自己的</span><br><span class=\"line\">    password: 123456 # 填写自己邮箱的密码，如果是QQ邮箱，应该是需要填写授权码</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h2><p>现在基本代码洗好了，我们接着写一个测试用例<br>我的项目所用的是springboot，具体情况视自己项目的情况而定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@WebAppConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span>(classes = OverdueApplication.class)</span><br><span class=\"line\"><span class=\"meta\">@ActiveProfiles</span>(<span class=\"string\">\"ubuntu\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Ignore</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MailService mailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSendMail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 模板中的变量</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"hospital\"</span>, <span class=\"string\">\"test hospital\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对应的邮件模板 文件名</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"template\"</span>, <span class=\"string\">\"overdueMail.vm\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mailService.sendMail(map);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"http://www.myluffy.com/wp-content/uploads/2018/06/38dc06f8e7ed4df81bd4867d54192dd0.png\" alt></p>\n<p>这样，一件简单的邮件模板发送就成功了。</p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<p>记录一次在工作使用Spring框架，发送邮件的demo。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>注意一下，我使用的是gradle，使用maven的需要通过maven的方式引入jar包依赖。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">group:</span> <span class=\"string\">'com.sun.mail'</span>, <span class=\"string\">name:</span> <span class=\"string\">'javax.mail'</span>, <span class=\"string\">version:</span> <span class=\"string\">'1.6.0'</span></span><br><span class=\"line\">compile <span class=\"string\">group:</span> <span class=\"string\">'org.apache.velocity'</span>, <span class=\"string\">name:</span> <span class=\"string\">'velocity'</span>, <span class=\"string\">version:</span> <span class=\"string\">'1.7'</span></span><br><span class=\"line\">compile <span class=\"string\">'org.springframework:spring-context-support'</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JavaMailSender mailSender;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> VelocityEngine <span class=\"title\">getVelocityEngine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        VelocityEngine velocityEngine = <span class=\"keyword\">new</span> VelocityEngine();</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"resource.loader\"</span>, <span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"class.resource.loader.class\"</span>, <span class=\"string\">\"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\"</span>);</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"input.encoding\"</span>, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">        velocityEngine.setProperty(<span class=\"string\">\"output.encoding\"</span>, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">        velocityEngine.init();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> velocityEngine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MimeMessageHelper <span class=\"title\">helper</span><span class=\"params\">(MimeMessage mimeMessage)</span><span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        MimeMessageHelper helper = <span class=\"keyword\">new</span> MimeMessageHelper(mimeMessage, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        List&lt;String&gt; tos = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 接收邮件的地址 集合 可以为多个</span></span><br><span class=\"line\"><span class=\"comment\">//        tos.add(\"service@*.com\");</span></span><br><span class=\"line\">        tos.add(<span class=\"string\">\"service2@*.com\"</span>);</span><br><span class=\"line\">        helper.setFrom(<span class=\"string\">\"service@*.com\"</span>);</span><br><span class=\"line\">        String[] strings = (String[])tos.toArray(<span class=\"keyword\">new</span> String[tos.size()]);</span><br><span class=\"line\">        helper.setTo(strings);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMail</span><span class=\"params\">(Map&lt;String, Object&gt; map)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class=\"line\">        MimeMessageHelper helper = helper(mimeMessage);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置邮件主题</span></span><br><span class=\"line\">        helper.setSubject(<span class=\"string\">\"overdue\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 需要填充到模板中的内容</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; model = <span class=\"keyword\">new</span> HashedMap();</span><br><span class=\"line\">        model.put(<span class=\"string\">\"hospital\"</span>, map.get(<span class=\"string\">\"hospital\"</span>));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        String template = (String) map.get(<span class=\"string\">\"template\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 得到模板 并填充内容，模板地址根据自己的实际情况所定</span></span><br><span class=\"line\">        String text = VelocityEngineUtils.mergeTemplateIntoString(</span><br><span class=\"line\">                getVelocityEngine(), <span class=\"string\">\"template/\"</span> + template, <span class=\"string\">\"UTF-8\"</span>, model);</span><br><span class=\"line\">        helper.setText(text, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//  发送邮件</span></span><br><span class=\"line\">        mailSender.send(mimeMessage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板实例\"><a href=\"#模板实例\" class=\"headerlink\" title=\"模板实例\"></a>模板实例</h2><p>在resources目录下，新建一个template文件夹，新建一个 *.vm 文件，注意文件后缀为 <code>.vm</code><br>如图所示：<br><img src=\"http://www.myluffy.com/wp-content/uploads/2018/06/2c30c54a83059f6cde42ee9e04a56a2e.png\" alt></p>\n<p>模板中内容为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    test</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hospital: $&#123;hospital&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>** 注意 <code>${hospital}</code> 和service中model字段相对应。</p>\n<h2 id=\"配置发送邮件的密码\"><a href=\"#配置发送邮件的密码\" class=\"headerlink\" title=\"配置发送邮件的密码\"></a>配置发送邮件的密码</h2><p>基本代码写好之后，我们需要在 <code>application.yml</code> 中配置一下邮件的用户名密码等；<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring:</span></span><br><span class=\"line\"><span class=\"symbol\">  mail:</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>-<span class=\"string\">encoding:</span> utf<span class=\"number\">-8</span></span><br><span class=\"line\">    host: smtp.exmail.qq.com # 邮箱host，不同的邮箱host是不一样的，这个列子是腾讯企业邮的，具体可以google。</span><br><span class=\"line\">    username: service@*.com # 发送邮箱的用户名， 替换为自己的</span><br><span class=\"line\">    password: 123456 # 填写自己邮箱的密码，如果是QQ邮箱，应该是需要填写授权码</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h2><p>现在基本代码洗好了，我们接着写一个测试用例<br>我的项目所用的是springboot，具体情况视自己项目的情况而定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@WebAppConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span>(classes = OverdueApplication.class)</span><br><span class=\"line\"><span class=\"meta\">@ActiveProfiles</span>(<span class=\"string\">\"ubuntu\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Ignore</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MailService mailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSendMail</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 模板中的变量</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"hospital\"</span>, <span class=\"string\">\"test hospital\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 对应的邮件模板 文件名</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"template\"</span>, <span class=\"string\">\"overdueMail.vm\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mailService.sendMail(map);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"http://www.myluffy.com/wp-content/uploads/2018/06/38dc06f8e7ed4df81bd4867d54192dd0.png\" alt></p>\n<p>这样，一件简单的邮件模板发送就成功了。</p>\n"},{"title":"SpringBoot2.0 新特性","abbrlink":"aaed1c03","date":"2018-03-08T16:00:00.000Z","_content":"## SpringBoot 2.0 新特性\n在 2018 年 3 月 1 日早上，Spring Boot 2.0 发布，在Spring Boot的官网中，2.0.0已经是最新的Spring Boot推荐版本，并提供了 Maven 中央仓库地址。\n\n官方表示，这个版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。该版本是自 4 年前发布 Spring Boot 1.0 以来的第一次重大修订，也是首个提供对 Spring Framework 5.0 支持的 GA 稳定版本。\n\nSpring Boot 2.0 主要有以下特性（详见：[Spring Boot 2.0 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes)）。\n## 支持Java 8和Java 9\nSpringBooot 2.0最低支持Java 8 版本，许多现有的API更新，以利用Java 8 的特性，例如：接口的默认方法，函数回调和新的APIs,如：javax.time。如果你当前使用的是Java 7或者更早的版本，在你开发Springboot 2.0程序之前，你需要升级你的Java版本\n\n<br />Spring Boot 2.0也可以很好地工作，并且已经通过JDK 9进行了测试。\n\n## 第三方库的升级\nSpring Boot 2.0建立在Spring Framework 5之上，并且需要Spring Framework 5\n\nSpring Boot 2.0已尽可能升级到其他第三方游戏机的最新稳定版本。本版本中一些值得注意的依赖性升级包括\n<br />Tomcat 8.5\n<br />Flyway 5\n<br />Hibernate 5.2\n<br />Thymeleaf 3\n## 更好的响应式支持\nSpringBoot 2.0通过auto-configuration 和 starter-POMs更好的支持响应式应用。Spring Boot的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是嵌入式服务器支持）\n\n使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持\nSpring Data还为响应式应用程序提供支持。目前Cassandra，MongoDB，Couchbase和Redis都有反应式API支持\n\n## 支持 HTTP/2 \n为Tomcat，Undertow和Jetty提供HTTP / 2支持。是否支持取决于所选的Web服务器和应用程序环境（因为JDK 8不支持该协议）\n## Gradle 插件\nSpring Boot的Gradle插件在很大程度上已被重写，以实现许多重大改进。需要注意：SpringBoot 2.0 现在需要Gradle 4.x 的版本\n## Kotlin\nSpringBoot 2.0对Kotlin 1.2.x 版本的支持，并提供了一个runApplication函数，该函数提供了一种使用惯用Kotlin运行Spring Boot应用程序的方法。\n## 对Quartz调度支持\nSpringBoot 2.0 对Quartz的支持，我们只需要加入 `spring-boot-starter-quartz` starter POM.\n\n支持JobStores或者基于JDBC的存储。 Spring应用程序上下文中的所有JobDetail，Calendar和Trigger bean将自动注册到Scheduler中\n## Testing 测试\n新版本对测试做了一些改变。\n* 一个新的`@WebFluxTest`注解，以支持WebFlux应用程序的“slice”测试。\n* 现在使用`@WebMvcTest`和`@WebFluxTest`自动扫描Converter和GenericConverter bean\n## 动画ASCII艺术\n最后，为了好玩，Spring Boot 2.0现在支持动画GIF横幅。\n[![](http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif)](http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif)","source":"_posts/springboot2-new-featrues.md","raw":"---\ntitle: SpringBoot2.0 新特性\ncategory:\n  - Spring\ntags:\n  - springboot\nabbrlink: aaed1c03\ndate: 2018-03-09 00:00:00\n---\n## SpringBoot 2.0 新特性\n在 2018 年 3 月 1 日早上，Spring Boot 2.0 发布，在Spring Boot的官网中，2.0.0已经是最新的Spring Boot推荐版本，并提供了 Maven 中央仓库地址。\n\n官方表示，这个版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。该版本是自 4 年前发布 Spring Boot 1.0 以来的第一次重大修订，也是首个提供对 Spring Framework 5.0 支持的 GA 稳定版本。\n\nSpring Boot 2.0 主要有以下特性（详见：[Spring Boot 2.0 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes)）。\n## 支持Java 8和Java 9\nSpringBooot 2.0最低支持Java 8 版本，许多现有的API更新，以利用Java 8 的特性，例如：接口的默认方法，函数回调和新的APIs,如：javax.time。如果你当前使用的是Java 7或者更早的版本，在你开发Springboot 2.0程序之前，你需要升级你的Java版本\n\n<br />Spring Boot 2.0也可以很好地工作，并且已经通过JDK 9进行了测试。\n\n## 第三方库的升级\nSpring Boot 2.0建立在Spring Framework 5之上，并且需要Spring Framework 5\n\nSpring Boot 2.0已尽可能升级到其他第三方游戏机的最新稳定版本。本版本中一些值得注意的依赖性升级包括\n<br />Tomcat 8.5\n<br />Flyway 5\n<br />Hibernate 5.2\n<br />Thymeleaf 3\n## 更好的响应式支持\nSpringBoot 2.0通过auto-configuration 和 starter-POMs更好的支持响应式应用。Spring Boot的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是嵌入式服务器支持）\n\n使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持\nSpring Data还为响应式应用程序提供支持。目前Cassandra，MongoDB，Couchbase和Redis都有反应式API支持\n\n## 支持 HTTP/2 \n为Tomcat，Undertow和Jetty提供HTTP / 2支持。是否支持取决于所选的Web服务器和应用程序环境（因为JDK 8不支持该协议）\n## Gradle 插件\nSpring Boot的Gradle插件在很大程度上已被重写，以实现许多重大改进。需要注意：SpringBoot 2.0 现在需要Gradle 4.x 的版本\n## Kotlin\nSpringBoot 2.0对Kotlin 1.2.x 版本的支持，并提供了一个runApplication函数，该函数提供了一种使用惯用Kotlin运行Spring Boot应用程序的方法。\n## 对Quartz调度支持\nSpringBoot 2.0 对Quartz的支持，我们只需要加入 `spring-boot-starter-quartz` starter POM.\n\n支持JobStores或者基于JDBC的存储。 Spring应用程序上下文中的所有JobDetail，Calendar和Trigger bean将自动注册到Scheduler中\n## Testing 测试\n新版本对测试做了一些改变。\n* 一个新的`@WebFluxTest`注解，以支持WebFlux应用程序的“slice”测试。\n* 现在使用`@WebMvcTest`和`@WebFluxTest`自动扫描Converter和GenericConverter bean\n## 动画ASCII艺术\n最后，为了好玩，Spring Boot 2.0现在支持动画GIF横幅。\n[![](http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif)](http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif)","slug":"springboot2-new-featrues","published":1,"updated":"2019-12-23T10:59:48.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphr001zi3sl3z7nrr0q","content":"<h2 id=\"SpringBoot-2-0-新特性\"><a href=\"#SpringBoot-2-0-新特性\" class=\"headerlink\" title=\"SpringBoot 2.0 新特性\"></a>SpringBoot 2.0 新特性</h2><p>在 2018 年 3 月 1 日早上，Spring Boot 2.0 发布，在Spring Boot的官网中，2.0.0已经是最新的Spring Boot推荐版本，并提供了 Maven 中央仓库地址。</p>\n<p>官方表示，这个版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。该版本是自 4 年前发布 Spring Boot 1.0 以来的第一次重大修订，也是首个提供对 Spring Framework 5.0 支持的 GA 稳定版本。</p>\n<p>Spring Boot 2.0 主要有以下特性（详见：<a href=\"https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes\" target=\"_blank\" rel=\"noopener\">Spring Boot 2.0 Release Notes</a>）。</p>\n<h2 id=\"支持Java-8和Java-9\"><a href=\"#支持Java-8和Java-9\" class=\"headerlink\" title=\"支持Java 8和Java 9\"></a>支持Java 8和Java 9</h2><p>SpringBooot 2.0最低支持Java 8 版本，许多现有的API更新，以利用Java 8 的特性，例如：接口的默认方法，函数回调和新的APIs,如：javax.time。如果你当前使用的是Java 7或者更早的版本，在你开发Springboot 2.0程序之前，你需要升级你的Java版本</p>\n<p><br>Spring Boot 2.0也可以很好地工作，并且已经通过JDK 9进行了测试。</p>\n<h2 id=\"第三方库的升级\"><a href=\"#第三方库的升级\" class=\"headerlink\" title=\"第三方库的升级\"></a>第三方库的升级</h2><p>Spring Boot 2.0建立在Spring Framework 5之上，并且需要Spring Framework 5</p>\n<p>Spring Boot 2.0已尽可能升级到其他第三方游戏机的最新稳定版本。本版本中一些值得注意的依赖性升级包括<br><br>Tomcat 8.5<br><br>Flyway 5<br><br>Hibernate 5.2<br><br>Thymeleaf 3</p>\n<h2 id=\"更好的响应式支持\"><a href=\"#更好的响应式支持\" class=\"headerlink\" title=\"更好的响应式支持\"></a>更好的响应式支持</h2><p>SpringBoot 2.0通过auto-configuration 和 starter-POMs更好的支持响应式应用。Spring Boot的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是嵌入式服务器支持）</p>\n<p>使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持<br>Spring Data还为响应式应用程序提供支持。目前Cassandra，MongoDB，Couchbase和Redis都有反应式API支持</p>\n<h2 id=\"支持-HTTP-2\"><a href=\"#支持-HTTP-2\" class=\"headerlink\" title=\"支持 HTTP/2\"></a>支持 HTTP/2</h2><p>为Tomcat，Undertow和Jetty提供HTTP / 2支持。是否支持取决于所选的Web服务器和应用程序环境（因为JDK 8不支持该协议）</p>\n<h2 id=\"Gradle-插件\"><a href=\"#Gradle-插件\" class=\"headerlink\" title=\"Gradle 插件\"></a>Gradle 插件</h2><p>Spring Boot的Gradle插件在很大程度上已被重写，以实现许多重大改进。需要注意：SpringBoot 2.0 现在需要Gradle 4.x 的版本</p>\n<h2 id=\"Kotlin\"><a href=\"#Kotlin\" class=\"headerlink\" title=\"Kotlin\"></a>Kotlin</h2><p>SpringBoot 2.0对Kotlin 1.2.x 版本的支持，并提供了一个runApplication函数，该函数提供了一种使用惯用Kotlin运行Spring Boot应用程序的方法。</p>\n<h2 id=\"对Quartz调度支持\"><a href=\"#对Quartz调度支持\" class=\"headerlink\" title=\"对Quartz调度支持\"></a>对Quartz调度支持</h2><p>SpringBoot 2.0 对Quartz的支持，我们只需要加入 <code>spring-boot-starter-quartz</code> starter POM.</p>\n<p>支持JobStores或者基于JDBC的存储。 Spring应用程序上下文中的所有JobDetail，Calendar和Trigger bean将自动注册到Scheduler中</p>\n<h2 id=\"Testing-测试\"><a href=\"#Testing-测试\" class=\"headerlink\" title=\"Testing 测试\"></a>Testing 测试</h2><p>新版本对测试做了一些改变。</p>\n<ul>\n<li>一个新的<code>@WebFluxTest</code>注解，以支持WebFlux应用程序的“slice”测试。</li>\n<li>现在使用<code>@WebMvcTest</code>和<code>@WebFluxTest</code>自动扫描Converter和GenericConverter bean<h2 id=\"动画ASCII艺术\"><a href=\"#动画ASCII艺术\" class=\"headerlink\" title=\"动画ASCII艺术\"></a>动画ASCII艺术</h2>最后，为了好玩，Spring Boot 2.0现在支持动画GIF横幅。<br><a href=\"http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif\" alt></a></li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h2 id=\"SpringBoot-2-0-新特性\"><a href=\"#SpringBoot-2-0-新特性\" class=\"headerlink\" title=\"SpringBoot 2.0 新特性\"></a>SpringBoot 2.0 新特性</h2><p>在 2018 年 3 月 1 日早上，Spring Boot 2.0 发布，在Spring Boot的官网中，2.0.0已经是最新的Spring Boot推荐版本，并提供了 Maven 中央仓库地址。</p>\n<p>官方表示，这个版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。该版本是自 4 年前发布 Spring Boot 1.0 以来的第一次重大修订，也是首个提供对 Spring Framework 5.0 支持的 GA 稳定版本。</p>\n<p>Spring Boot 2.0 主要有以下特性（详见：<a href=\"https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes\" target=\"_blank\" rel=\"noopener\">Spring Boot 2.0 Release Notes</a>）。</p>\n<h2 id=\"支持Java-8和Java-9\"><a href=\"#支持Java-8和Java-9\" class=\"headerlink\" title=\"支持Java 8和Java 9\"></a>支持Java 8和Java 9</h2><p>SpringBooot 2.0最低支持Java 8 版本，许多现有的API更新，以利用Java 8 的特性，例如：接口的默认方法，函数回调和新的APIs,如：javax.time。如果你当前使用的是Java 7或者更早的版本，在你开发Springboot 2.0程序之前，你需要升级你的Java版本</p>\n<p><br>Spring Boot 2.0也可以很好地工作，并且已经通过JDK 9进行了测试。</p>\n<h2 id=\"第三方库的升级\"><a href=\"#第三方库的升级\" class=\"headerlink\" title=\"第三方库的升级\"></a>第三方库的升级</h2><p>Spring Boot 2.0建立在Spring Framework 5之上，并且需要Spring Framework 5</p>\n<p>Spring Boot 2.0已尽可能升级到其他第三方游戏机的最新稳定版本。本版本中一些值得注意的依赖性升级包括<br><br>Tomcat 8.5<br><br>Flyway 5<br><br>Hibernate 5.2<br><br>Thymeleaf 3</p>\n<h2 id=\"更好的响应式支持\"><a href=\"#更好的响应式支持\" class=\"headerlink\" title=\"更好的响应式支持\"></a>更好的响应式支持</h2><p>SpringBoot 2.0通过auto-configuration 和 starter-POMs更好的支持响应式应用。Spring Boot的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是嵌入式服务器支持）</p>\n<p>使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持<br>Spring Data还为响应式应用程序提供支持。目前Cassandra，MongoDB，Couchbase和Redis都有反应式API支持</p>\n<h2 id=\"支持-HTTP-2\"><a href=\"#支持-HTTP-2\" class=\"headerlink\" title=\"支持 HTTP/2\"></a>支持 HTTP/2</h2><p>为Tomcat，Undertow和Jetty提供HTTP / 2支持。是否支持取决于所选的Web服务器和应用程序环境（因为JDK 8不支持该协议）</p>\n<h2 id=\"Gradle-插件\"><a href=\"#Gradle-插件\" class=\"headerlink\" title=\"Gradle 插件\"></a>Gradle 插件</h2><p>Spring Boot的Gradle插件在很大程度上已被重写，以实现许多重大改进。需要注意：SpringBoot 2.0 现在需要Gradle 4.x 的版本</p>\n<h2 id=\"Kotlin\"><a href=\"#Kotlin\" class=\"headerlink\" title=\"Kotlin\"></a>Kotlin</h2><p>SpringBoot 2.0对Kotlin 1.2.x 版本的支持，并提供了一个runApplication函数，该函数提供了一种使用惯用Kotlin运行Spring Boot应用程序的方法。</p>\n<h2 id=\"对Quartz调度支持\"><a href=\"#对Quartz调度支持\" class=\"headerlink\" title=\"对Quartz调度支持\"></a>对Quartz调度支持</h2><p>SpringBoot 2.0 对Quartz的支持，我们只需要加入 <code>spring-boot-starter-quartz</code> starter POM.</p>\n<p>支持JobStores或者基于JDBC的存储。 Spring应用程序上下文中的所有JobDetail，Calendar和Trigger bean将自动注册到Scheduler中</p>\n<h2 id=\"Testing-测试\"><a href=\"#Testing-测试\" class=\"headerlink\" title=\"Testing 测试\"></a>Testing 测试</h2><p>新版本对测试做了一些改变。</p>\n<ul>\n<li>一个新的<code>@WebFluxTest</code>注解，以支持WebFlux应用程序的“slice”测试。</li>\n<li>现在使用<code>@WebMvcTest</code>和<code>@WebFluxTest</code>自动扫描Converter和GenericConverter bean<h2 id=\"动画ASCII艺术\"><a href=\"#动画ASCII艺术\" class=\"headerlink\" title=\"动画ASCII艺术\"></a>动画ASCII艺术</h2>最后，为了好玩，Spring Boot 2.0现在支持动画GIF横幅。<br><a href=\"http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif\" target=\"_blank\" rel=\"noopener\"><img src=\"http://myluffy.com/wp-content/uploads/2018/03/animated-ascii-art-1.gif\" alt></a></li>\n</ul>\n"},{"title":"使用ajax传递参数，后台使用对象接收。报400错误。","abbrlink":"571a3817","date":"2017-11-21T16:00:00.000Z","_content":"\n* 在ajax的传递Json格式的数据到后台，后台使用SpringBoot。\n\n\t**前台Json格式如下:**\n\n    ``` java\n    [\n    {\n        \"age\": 1,\n        \"name\": \"test\",\n        \"gender\": null,\n        \"order\": 1\n    }\n    ]\n    ```\n   **后台接收对象格式如下:**\n\n    ``` java\n    public class User{\n    \tprivate Integer age;\n        private String name;\n        private Gender gender; // Gender 为枚举类型\n        private Integer order;\n\n\t}\n    ```\n    因为gender为枚举类型，所以有个Gender Enum 类:\n    ``` java\n    public Enum Gender{\n    \tMALE,\n        FEMALE;\n    }\n    ```\n    **注意**：\n\n    前台Json格式中 ‘gender’ 为 null，后台使用对象接收，因为 接收对象中属性Gender为枚举类型。所以前台会报‘400’ 错误，后台因为看见枚举值为 null，或者枚举值不存在，就会报错。\n* 所以在使用有枚举类型对象接收Json格式参数的时候，应该保证传输的值和枚举中对应的属性值一样。\n","source":"_posts/use-ajax-question.md","raw":"---\ntitle: 使用ajax传递参数，后台使用对象接收。报400错误。\ncategory: Web\ntags:\n  - ajax\nabbrlink: 571a3817\ndate: 2017-11-22 00:00:00\n---\n\n* 在ajax的传递Json格式的数据到后台，后台使用SpringBoot。\n\n\t**前台Json格式如下:**\n\n    ``` java\n    [\n    {\n        \"age\": 1,\n        \"name\": \"test\",\n        \"gender\": null,\n        \"order\": 1\n    }\n    ]\n    ```\n   **后台接收对象格式如下:**\n\n    ``` java\n    public class User{\n    \tprivate Integer age;\n        private String name;\n        private Gender gender; // Gender 为枚举类型\n        private Integer order;\n\n\t}\n    ```\n    因为gender为枚举类型，所以有个Gender Enum 类:\n    ``` java\n    public Enum Gender{\n    \tMALE,\n        FEMALE;\n    }\n    ```\n    **注意**：\n\n    前台Json格式中 ‘gender’ 为 null，后台使用对象接收，因为 接收对象中属性Gender为枚举类型。所以前台会报‘400’ 错误，后台因为看见枚举值为 null，或者枚举值不存在，就会报错。\n* 所以在使用有枚举类型对象接收Json格式参数的时候，应该保证传输的值和枚举中对应的属性值一样。\n","slug":"use-ajax-question","published":1,"updated":"2020-03-12T06:06:23.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhphs0022i3slhbrx7fih","content":"<ul>\n<li><p>在ajax的传递Json格式的数据到后台，后台使用SpringBoot。</p>\n<p>  <strong>前台Json格式如下:</strong></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gender\"</span>: <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"order\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p> <strong>后台接收对象格式如下:</strong></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> Gender gender; <span class=\"comment\">// Gender 为枚举类型</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> Integer order;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  因为gender为枚举类型，所以有个Gender Enum 类:</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Enum Gender&#123;</span><br><span class=\"line\">\tMALE,</span><br><span class=\"line\">    FEMALE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>注意</strong>：</p>\n<p>  前台Json格式中 ‘gender’ 为 null，后台使用对象接收，因为 接收对象中属性Gender为枚举类型。所以前台会报‘400’ 错误，后台因为看见枚举值为 null，或者枚举值不存在，就会报错。</p>\n</li>\n<li>所以在使用有枚举类型对象接收Json格式参数的时候，应该保证传输的值和枚举中对应的属性值一样。</li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<ul>\n<li><p>在ajax的传递Json格式的数据到后台，后台使用SpringBoot。</p>\n<p>  <strong>前台Json格式如下:</strong></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"gender\"</span>: <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"order\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p> <strong>后台接收对象格式如下:</strong></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">       <span class=\"keyword\">private</span> Gender gender; <span class=\"comment\">// Gender 为枚举类型</span></span><br><span class=\"line\">       <span class=\"keyword\">private</span> Integer order;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  因为gender为枚举类型，所以有个Gender Enum 类:</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Enum Gender&#123;</span><br><span class=\"line\">\tMALE,</span><br><span class=\"line\">    FEMALE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>注意</strong>：</p>\n<p>  前台Json格式中 ‘gender’ 为 null，后台使用对象接收，因为 接收对象中属性Gender为枚举类型。所以前台会报‘400’ 错误，后台因为看见枚举值为 null，或者枚举值不存在，就会报错。</p>\n</li>\n<li>所以在使用有枚举类型对象接收Json格式参数的时候，应该保证传输的值和枚举中对应的属性值一样。</li>\n</ul>\n"},{"title":"JDK8源码学习：LinkedList","abbrlink":"e3ffdb91","date":"2018-11-14T02:29:02.000Z","_content":"# 概述\nLinkedList是允许元素为null的**双向链表**，LinkedList是**线程不安全**的，底层是基于链表的实现。\n因为底层是链表的原因，说明，插入、删除比较方便，只需要移动对应的指针即可。但是在处理随机访问的数据，就会要比ArrayList慢了。\n# 属性\nLinkedList的属性相对比较少，只有下面的三个属性。\n``` java\n// 集合元素的数量\ntransient int size = 0;\n// 链表的第一个指针元素\ntransient Node<E> first;\n// 链表最后一个元素\ntransient Node<E> last;\n```\n# 构造方法\nLinkedList只有两个构造方法，一个时默认的构造方法，另一个是将集合初始化到LinkedList。\n``` java\n/**\n * 初始化一个空的LinkedList\n */\npublic LinkedList() {\n}\n\n/**\n * 初始化一个包含集合元素的LinkedList\n */\npublic LinkedList(Collection<? extends E> c) {\n    this();  // 调用默认构造方法\n    addAll(c); // 将元素全部添加到LinkedList\n}\n```\n在看 `addAll()`方法前，先看看Node节点结构\n``` java\nprivate static class Node<E> {\n    E item; // 节点值\n    Node<E> next; // 下一个节点\n    Node<E> prev; // 前一个节点\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n看完了Node的结构，随便把`node(int)`方法给看了，该方法在文中会多次遇到。\n``` java\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n    // size >> 1 等价于 size/2 。通过将LinkedList折半，增加查询效率。\n    if (index < (size >> 1)) {\n        Node<E> x = first; // 保存第一个节点，因为需要从第一个节点开始循环查找\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n`node(int index)`的实现是一个一个循环遍历得到的值，虽然说用到了缩小范围的折半方式优化查询。但是还是不可避免的导致获取效率低下。\n\n在初始化有集合元素的构造方法是会调用到 `addAll()` 方法，跟着 `addAll()` 方法一直看下去，核心实现如下：\n``` java\npublic boolean addAll(int index, Collection<? extends E> c) {\n    // 检验index是否在范围内 [0, size]\n    checkPositionIndex(index);\n\n    Object[] a = c.toArray();\n    int numNew = a.length; // 记录传递过来的集合元素个数\n    if (numNew == 0)\n        return false;\n\n    Node<E> pred, succ; // pred: index前置节点, index的后置节点\n    // 在链表尾部添加数据\n    if (index == size) {\n        succ = null;\n        pred = last;\n    } else {\n        succ = node(index); // 获取index节点的值，赋值给succ\n        pred = succ.prev; // succ的前置节点赋值给 pred\n    }\n\n    // 遍历添加元素\n    for (Object o : a) {\n        @SuppressWarnings(\"unchecked\") E e = (E) o;\n         // 根据前置节点和当前元素之构建 node节点\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null) // 没有前置节点\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n\n    // 判断添加元素是否在队尾添加\n    if (succ == null) {\n        last = pred; // 设置队尾节点\n    } else { // 在链表中间添加的元素\n        pred.next = succ; // 设置前置节点的下一个值\n        succ.prev = pred; // 设置后置节点的前一个值\n    }\n\n    size += numNew; // 重新设置LinkedList的元素数量\n    modCount++; // 记录一次结构更改的次数\n    return true;\n}\n```\n`addAll()`方法的实现过程还是容易看懂的。首先检查插入的位置是否在范围之内，接着判断是在链表中间插入数据，还是在链表尾部插入数据，设置根据succ和pred。然后循环遍历添加节点到LinkedList中。整个过程大致就是这样\n# 常用方法\n接下来看看LinkedList中的常用方法\n## add 添加\nLinkedList的添加方法，主要是 `add(E)`、 `add(int, E)`，首先来看看默认的`add(E)`方法的代码：\n``` java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n```\n上面代码没有具体逻辑，具体实现在`linkLast(e)`中，接着进入该方法中。\n``` java\nvoid linkLast(E e) {\n    final Node<E> l = last; // 将末尾节点设置给l节点\n    // 根据末尾节点做前置节点，得到一个新的节点\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode; // 更新末尾节点为新的节点\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n`linkLast`方法实现过程是，首先得到末尾节点`l`，根据`l`做前置节点得到一个新的节点，最后对末尾节点重新赋值。我们可以看出，整个`add`方法在不指定添加位置的情况下，默认将值添加到末尾的。\n看了默认的add方法实现，接着看看在规定位置添加节点的实现\n`add(int, E)`方法的实现\n``` java\npublic void add(int index, E element) {\n    // 校验添加节点的位置是否在 [0, size] 之间\n    checkPositionIndex(index);\n    // 如果添加的位置刚好尾部节点，直接调用默认添加方法的实现。\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n```\n接着进入`linkBefore`方法看看是怎么实现的。e: 待添加元素值，succ: 带添加位置的节点\n``` java\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev; // 保存待添加位置的前置节点\n    final Node<E> newNode = new Node<>(pred, e, succ); // 根据前置节点、当前值、后置节点 得到一个新的节点\n    succ.prev = newNode; // 设置添加位置的前置节点\n    if (pred == null)\n        first = newNode; // 如果前置节点为空，直接设置 第一个节点 （first代表第一个节点）\n    else\n        pred.next = newNode; // 将前面保存的前置节点的下一节点设置为新的节点\n    size++; // 将LinkedList的容量加一\n    modCount++; // 记录一下更改的次数\n}\n```\n整个过程通过代码中的注释，大致都能看的明白。\n在添加方法中还有`addLast`、`addFrist`方法。首先看看`addLast`方法\n``` java\npublic void addLast(E e) {\n    linkLast(e);\n}\n```\n实现过程和默认的add方法一样，唯一的区别就是默认`add`方法有返回值，`addLast`方法没有返回值。\n接下来看看`addFrist(E)`方法。\n``` java\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n// 具体实现\nprivate void linkFirst(E e) {\n    final Node<E> f = first; // 保存原来的第一个节点\n    final Node<E> newNode = new Node<>(null, e, f); // 得到一个新的节点，新节点的下一个节点就是原来的第一个节点\n    first = newNode;\n    if (f == null)\n        last = newNode; // 说明之前为空的LinkedList，直接设置末尾节点为新节点\n    else\n        f.prev = newNode; // 设置原来第一个节点的前置节点为新节点\n    size++; // 容量+1\n    modCount++; // 修改次数 +1\n}\n```\n##  remove 删除\n删除有两个实现，其一是：`remove()`不需要传入指针的位置，默认删除第一个，其二是`remove(int)`方法，该方法是传入一个需要删除的位置，如果删除成功会返回被删除的值。\n`remove()`方法的实现过程和`remove(int)`差不多，也可以理解为`remove()`默认传递了指针为0。这里就不单独介绍了。接下来就看看`remove(int)` 是怎么实现的。\n代码如下：\n``` java\npublic E remove(int index) {\n    // 检验index是否在[0, size]之间\n    checkElementIndex(index);\n    // node(index)：待删除节点\n    return unlink(node(index));\n}\n```\n核心实现在unlink方法中，接下来看看 unlink的实现\n``` java\nE unlink(Node<E> x) {\n    // assert x != null;\n    // x 为待删除节点\n    final E element = x.item; // 保存一下值，删除完成之后，需要返回给调用者。\n    final Node<E> next = x.next; // 保存x的下一个节点\n    final Node<E> prev = x.prev; // 保存x的前一个节点\n    // 如果前置节点为空\n    if (prev == null) {\n        // 直接设置LinkedList的frist节点为 x的下一个节点\n        first = next;\n    } else {\n        // 设置x的前置节点的下一个节点为 x的后置节点\n        prev.next = next;\n        x.prev = null; // 将x的前置节点设置为null，方便gc\n    }\n\n    if (next == null) {\n        last = prev; // 如果x的后置节点为空，LinkedList的末尾节点设置为x的前置节点\n    } else {\n        next.prev = prev; // 设置x的下一个节点的前置节点为 x的前置节点\n        x.next = null; // 将x的后置节点设置为null，方便gc\n    }\n\n    x.item = null; // 将x值设置为null，方便gc\n    size--; // 容量 -1\n    modCount++;\n    return element;\n}\n```\n删除方法的核心就是，将待删除节点的前置节点的下一个节点设置为待删除节点的下一个节点（读起来蛮拗口的，多读几遍就能理解了）。\n## get\n`get(int)`方法，根据位置获取值。\n先贴上代码\n``` java\npublic E get(int index) {\n    // 检验index是否在[0, size]之间\n    checkElementIndex(index);\n    return node(index).item;\n}\n```\n上面已经有对node(index)方法做过解释了，该方法就是得到节点，返回节点的值。\n\n## set\n`set(int, E)`方法是一个根据index替换其原来的值，最后返回原始值。\n``` java\npublic E set(int index, E element) {\n    // 检验index是否在[0, size]之间\n    checkElementIndex(index);\n    // 根据index获取需要设置的节点\n    Node<E> x = node(index);\n    // 保存旧值\n    E oldVal = x.item;\n    // 设置新值\n    x.item = element;\n    // 返回旧值\n    return oldVal;\n}\n```\n## poll\n`poll()`方法是获取并删除第一个元素。其实就是删除第一个元素并返回删除元素的值和`remove()`方法相同。这里也不做过多解释了。\n``` java\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n```\n\n## peek\n`peek()` 获取第一个节点的值。和`poll()`唯一不同的是，`peek`不需要删除第一个节点。\n实现如下：\n``` java\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n```\n\n# 总结\nLinkedList的分析到这里就结束了。\nLinkedList是一个双向列表，在删除，添加元素方面有着比ArrayList更好的体验。但是在查询的时候需要一个一个遍历得到结果，虽说在遍历的时候将LinkedList分为了前一半和后一半遍历，但是和ArrayList的底层动态数组相比，还是差的太多。所以在项目具体使用过程中，还是得按需使用。\n","source":"_posts/java-linkedlist.md","raw":"---\ntitle: JDK8源码学习：LinkedList\ncategory:\n  - Java\ntags:\n  - java\nabbrlink: e3ffdb91\ndate: 2018-11-14 10:29:02\n---\n# 概述\nLinkedList是允许元素为null的**双向链表**，LinkedList是**线程不安全**的，底层是基于链表的实现。\n因为底层是链表的原因，说明，插入、删除比较方便，只需要移动对应的指针即可。但是在处理随机访问的数据，就会要比ArrayList慢了。\n# 属性\nLinkedList的属性相对比较少，只有下面的三个属性。\n``` java\n// 集合元素的数量\ntransient int size = 0;\n// 链表的第一个指针元素\ntransient Node<E> first;\n// 链表最后一个元素\ntransient Node<E> last;\n```\n# 构造方法\nLinkedList只有两个构造方法，一个时默认的构造方法，另一个是将集合初始化到LinkedList。\n``` java\n/**\n * 初始化一个空的LinkedList\n */\npublic LinkedList() {\n}\n\n/**\n * 初始化一个包含集合元素的LinkedList\n */\npublic LinkedList(Collection<? extends E> c) {\n    this();  // 调用默认构造方法\n    addAll(c); // 将元素全部添加到LinkedList\n}\n```\n在看 `addAll()`方法前，先看看Node节点结构\n``` java\nprivate static class Node<E> {\n    E item; // 节点值\n    Node<E> next; // 下一个节点\n    Node<E> prev; // 前一个节点\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n看完了Node的结构，随便把`node(int)`方法给看了，该方法在文中会多次遇到。\n``` java\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n    // size >> 1 等价于 size/2 。通过将LinkedList折半，增加查询效率。\n    if (index < (size >> 1)) {\n        Node<E> x = first; // 保存第一个节点，因为需要从第一个节点开始循环查找\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n`node(int index)`的实现是一个一个循环遍历得到的值，虽然说用到了缩小范围的折半方式优化查询。但是还是不可避免的导致获取效率低下。\n\n在初始化有集合元素的构造方法是会调用到 `addAll()` 方法，跟着 `addAll()` 方法一直看下去，核心实现如下：\n``` java\npublic boolean addAll(int index, Collection<? extends E> c) {\n    // 检验index是否在范围内 [0, size]\n    checkPositionIndex(index);\n\n    Object[] a = c.toArray();\n    int numNew = a.length; // 记录传递过来的集合元素个数\n    if (numNew == 0)\n        return false;\n\n    Node<E> pred, succ; // pred: index前置节点, index的后置节点\n    // 在链表尾部添加数据\n    if (index == size) {\n        succ = null;\n        pred = last;\n    } else {\n        succ = node(index); // 获取index节点的值，赋值给succ\n        pred = succ.prev; // succ的前置节点赋值给 pred\n    }\n\n    // 遍历添加元素\n    for (Object o : a) {\n        @SuppressWarnings(\"unchecked\") E e = (E) o;\n         // 根据前置节点和当前元素之构建 node节点\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null) // 没有前置节点\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n\n    // 判断添加元素是否在队尾添加\n    if (succ == null) {\n        last = pred; // 设置队尾节点\n    } else { // 在链表中间添加的元素\n        pred.next = succ; // 设置前置节点的下一个值\n        succ.prev = pred; // 设置后置节点的前一个值\n    }\n\n    size += numNew; // 重新设置LinkedList的元素数量\n    modCount++; // 记录一次结构更改的次数\n    return true;\n}\n```\n`addAll()`方法的实现过程还是容易看懂的。首先检查插入的位置是否在范围之内，接着判断是在链表中间插入数据，还是在链表尾部插入数据，设置根据succ和pred。然后循环遍历添加节点到LinkedList中。整个过程大致就是这样\n# 常用方法\n接下来看看LinkedList中的常用方法\n## add 添加\nLinkedList的添加方法，主要是 `add(E)`、 `add(int, E)`，首先来看看默认的`add(E)`方法的代码：\n``` java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n```\n上面代码没有具体逻辑，具体实现在`linkLast(e)`中，接着进入该方法中。\n``` java\nvoid linkLast(E e) {\n    final Node<E> l = last; // 将末尾节点设置给l节点\n    // 根据末尾节点做前置节点，得到一个新的节点\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode; // 更新末尾节点为新的节点\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n`linkLast`方法实现过程是，首先得到末尾节点`l`，根据`l`做前置节点得到一个新的节点，最后对末尾节点重新赋值。我们可以看出，整个`add`方法在不指定添加位置的情况下，默认将值添加到末尾的。\n看了默认的add方法实现，接着看看在规定位置添加节点的实现\n`add(int, E)`方法的实现\n``` java\npublic void add(int index, E element) {\n    // 校验添加节点的位置是否在 [0, size] 之间\n    checkPositionIndex(index);\n    // 如果添加的位置刚好尾部节点，直接调用默认添加方法的实现。\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n```\n接着进入`linkBefore`方法看看是怎么实现的。e: 待添加元素值，succ: 带添加位置的节点\n``` java\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev; // 保存待添加位置的前置节点\n    final Node<E> newNode = new Node<>(pred, e, succ); // 根据前置节点、当前值、后置节点 得到一个新的节点\n    succ.prev = newNode; // 设置添加位置的前置节点\n    if (pred == null)\n        first = newNode; // 如果前置节点为空，直接设置 第一个节点 （first代表第一个节点）\n    else\n        pred.next = newNode; // 将前面保存的前置节点的下一节点设置为新的节点\n    size++; // 将LinkedList的容量加一\n    modCount++; // 记录一下更改的次数\n}\n```\n整个过程通过代码中的注释，大致都能看的明白。\n在添加方法中还有`addLast`、`addFrist`方法。首先看看`addLast`方法\n``` java\npublic void addLast(E e) {\n    linkLast(e);\n}\n```\n实现过程和默认的add方法一样，唯一的区别就是默认`add`方法有返回值，`addLast`方法没有返回值。\n接下来看看`addFrist(E)`方法。\n``` java\npublic void addFirst(E e) {\n    linkFirst(e);\n}\n// 具体实现\nprivate void linkFirst(E e) {\n    final Node<E> f = first; // 保存原来的第一个节点\n    final Node<E> newNode = new Node<>(null, e, f); // 得到一个新的节点，新节点的下一个节点就是原来的第一个节点\n    first = newNode;\n    if (f == null)\n        last = newNode; // 说明之前为空的LinkedList，直接设置末尾节点为新节点\n    else\n        f.prev = newNode; // 设置原来第一个节点的前置节点为新节点\n    size++; // 容量+1\n    modCount++; // 修改次数 +1\n}\n```\n##  remove 删除\n删除有两个实现，其一是：`remove()`不需要传入指针的位置，默认删除第一个，其二是`remove(int)`方法，该方法是传入一个需要删除的位置，如果删除成功会返回被删除的值。\n`remove()`方法的实现过程和`remove(int)`差不多，也可以理解为`remove()`默认传递了指针为0。这里就不单独介绍了。接下来就看看`remove(int)` 是怎么实现的。\n代码如下：\n``` java\npublic E remove(int index) {\n    // 检验index是否在[0, size]之间\n    checkElementIndex(index);\n    // node(index)：待删除节点\n    return unlink(node(index));\n}\n```\n核心实现在unlink方法中，接下来看看 unlink的实现\n``` java\nE unlink(Node<E> x) {\n    // assert x != null;\n    // x 为待删除节点\n    final E element = x.item; // 保存一下值，删除完成之后，需要返回给调用者。\n    final Node<E> next = x.next; // 保存x的下一个节点\n    final Node<E> prev = x.prev; // 保存x的前一个节点\n    // 如果前置节点为空\n    if (prev == null) {\n        // 直接设置LinkedList的frist节点为 x的下一个节点\n        first = next;\n    } else {\n        // 设置x的前置节点的下一个节点为 x的后置节点\n        prev.next = next;\n        x.prev = null; // 将x的前置节点设置为null，方便gc\n    }\n\n    if (next == null) {\n        last = prev; // 如果x的后置节点为空，LinkedList的末尾节点设置为x的前置节点\n    } else {\n        next.prev = prev; // 设置x的下一个节点的前置节点为 x的前置节点\n        x.next = null; // 将x的后置节点设置为null，方便gc\n    }\n\n    x.item = null; // 将x值设置为null，方便gc\n    size--; // 容量 -1\n    modCount++;\n    return element;\n}\n```\n删除方法的核心就是，将待删除节点的前置节点的下一个节点设置为待删除节点的下一个节点（读起来蛮拗口的，多读几遍就能理解了）。\n## get\n`get(int)`方法，根据位置获取值。\n先贴上代码\n``` java\npublic E get(int index) {\n    // 检验index是否在[0, size]之间\n    checkElementIndex(index);\n    return node(index).item;\n}\n```\n上面已经有对node(index)方法做过解释了，该方法就是得到节点，返回节点的值。\n\n## set\n`set(int, E)`方法是一个根据index替换其原来的值，最后返回原始值。\n``` java\npublic E set(int index, E element) {\n    // 检验index是否在[0, size]之间\n    checkElementIndex(index);\n    // 根据index获取需要设置的节点\n    Node<E> x = node(index);\n    // 保存旧值\n    E oldVal = x.item;\n    // 设置新值\n    x.item = element;\n    // 返回旧值\n    return oldVal;\n}\n```\n## poll\n`poll()`方法是获取并删除第一个元素。其实就是删除第一个元素并返回删除元素的值和`remove()`方法相同。这里也不做过多解释了。\n``` java\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n```\n\n## peek\n`peek()` 获取第一个节点的值。和`poll()`唯一不同的是，`peek`不需要删除第一个节点。\n实现如下：\n``` java\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n```\n\n# 总结\nLinkedList的分析到这里就结束了。\nLinkedList是一个双向列表，在删除，添加元素方面有着比ArrayList更好的体验。但是在查询的时候需要一个一个遍历得到结果，虽说在遍历的时候将LinkedList分为了前一半和后一半遍历，但是和ArrayList的底层动态数组相比，还是差的太多。所以在项目具体使用过程中，还是得按需使用。\n","slug":"java-linkedlist","published":1,"updated":"2019-12-23T10:59:48.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpiz003li3sl0z508i7b","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>LinkedList是允许元素为null的<strong>双向链表</strong>，LinkedList是<strong>线程不安全</strong>的，底层是基于链表的实现。<br>因为底层是链表的原因，说明，插入、删除比较方便，只需要移动对应的指针即可。但是在处理随机访问的数据，就会要比ArrayList慢了。</p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><p>LinkedList的属性相对比较少，只有下面的三个属性。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 集合元素的数量</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 链表的第一个指针元素</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"><span class=\"comment\">// 链表最后一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><p>LinkedList只有两个构造方法，一个时默认的构造方法，另一个是将集合初始化到LinkedList。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化一个空的LinkedList</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化一个包含集合元素的LinkedList</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();  <span class=\"comment\">// 调用默认构造方法</span></span><br><span class=\"line\">    addAll(c); <span class=\"comment\">// 将元素全部添加到LinkedList</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在看 <code>addAll()</code>方法前，先看看Node节点结构<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item; <span class=\"comment\">// 节点值</span></span><br><span class=\"line\">    Node&lt;E&gt; next; <span class=\"comment\">// 下一个节点</span></span><br><span class=\"line\">    Node&lt;E&gt; prev; <span class=\"comment\">// 前一个节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看完了Node的结构，随便把<code>node(int)</code>方法给看了，该方法在文中会多次遇到。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\">    <span class=\"comment\">// size &gt;&gt; 1 等价于 size/2 。通过将LinkedList折半，增加查询效率。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first; <span class=\"comment\">// 保存第一个节点，因为需要从第一个节点开始循环查找</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>node(int index)</code>的实现是一个一个循环遍历得到的值，虽然说用到了缩小范围的折半方式优化查询。但是还是不可避免的导致获取效率低下。</p>\n<p>在初始化有集合元素的构造方法是会调用到 <code>addAll()</code> 方法，跟着 <code>addAll()</code> 方法一直看下去，核心实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在范围内 [0, size]</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length; <span class=\"comment\">// 记录传递过来的集合元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node&lt;E&gt; pred, succ; <span class=\"comment\">// pred: index前置节点, index的后置节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 在链表尾部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">        succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        pred = last;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        succ = node(index); <span class=\"comment\">// 获取index节点的值，赋值给succ</span></span><br><span class=\"line\">        pred = succ.prev; <span class=\"comment\">// succ的前置节点赋值给 pred</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历添加元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) E e = (E) o;</span><br><span class=\"line\">         <span class=\"comment\">// 根据前置节点和当前元素之构建 node节点</span></span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>) <span class=\"comment\">// 没有前置节点</span></span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        pred = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断添加元素是否在队尾添加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        last = pred; <span class=\"comment\">// 设置队尾节点</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 在链表中间添加的元素</span></span><br><span class=\"line\">        pred.next = succ; <span class=\"comment\">// 设置前置节点的下一个值</span></span><br><span class=\"line\">        succ.prev = pred; <span class=\"comment\">// 设置后置节点的前一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    size += numNew; <span class=\"comment\">// 重新设置LinkedList的元素数量</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 记录一次结构更改的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>addAll()</code>方法的实现过程还是容易看懂的。首先检查插入的位置是否在范围之内，接着判断是在链表中间插入数据，还是在链表尾部插入数据，设置根据succ和pred。然后循环遍历添加节点到LinkedList中。整个过程大致就是这样</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><p>接下来看看LinkedList中的常用方法</p>\n<h2 id=\"add-添加\"><a href=\"#add-添加\" class=\"headerlink\" title=\"add 添加\"></a>add 添加</h2><p>LinkedList的添加方法，主要是 <code>add(E)</code>、 <code>add(int, E)</code>，首先来看看默认的<code>add(E)</code>方法的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码没有具体逻辑，具体实现在<code>linkLast(e)</code>中，接着进入该方法中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last; <span class=\"comment\">// 将末尾节点设置给l节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据末尾节点做前置节点，得到一个新的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    last = newNode; <span class=\"comment\">// 更新末尾节点为新的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>linkLast</code>方法实现过程是，首先得到末尾节点<code>l</code>，根据<code>l</code>做前置节点得到一个新的节点，最后对末尾节点重新赋值。我们可以看出，整个<code>add</code>方法在不指定添加位置的情况下，默认将值添加到末尾的。<br>看了默认的add方法实现，接着看看在规定位置添加节点的实现<br><code>add(int, E)</code>方法的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 校验添加节点的位置是否在 [0, size] 之间</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// 如果添加的位置刚好尾部节点，直接调用默认添加方法的实现。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">        linkLast(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着进入<code>linkBefore</code>方法看看是怎么实现的。e: 待添加元素值，succ: 带添加位置的节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert succ != null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev; <span class=\"comment\">// 保存待添加位置的前置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ); <span class=\"comment\">// 根据前置节点、当前值、后置节点 得到一个新的节点</span></span><br><span class=\"line\">    succ.prev = newNode; <span class=\"comment\">// 设置添加位置的前置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode; <span class=\"comment\">// 如果前置节点为空，直接设置 第一个节点 （first代表第一个节点）</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pred.next = newNode; <span class=\"comment\">// 将前面保存的前置节点的下一节点设置为新的节点</span></span><br><span class=\"line\">    size++; <span class=\"comment\">// 将LinkedList的容量加一</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 记录一下更改的次数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>整个过程通过代码中的注释，大致都能看的明白。<br>在添加方法中还有<code>addLast</code>、<code>addFrist</code>方法。首先看看<code>addLast</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现过程和默认的add方法一样，唯一的区别就是默认<code>add</code>方法有返回值，<code>addLast</code>方法没有返回值。<br>接下来看看<code>addFrist(E)</code>方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first; <span class=\"comment\">// 保存原来的第一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f); <span class=\"comment\">// 得到一个新的节点，新节点的下一个节点就是原来的第一个节点</span></span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        last = newNode; <span class=\"comment\">// 说明之前为空的LinkedList，直接设置末尾节点为新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        f.prev = newNode; <span class=\"comment\">// 设置原来第一个节点的前置节点为新节点</span></span><br><span class=\"line\">    size++; <span class=\"comment\">// 容量+1</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 修改次数 +1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove-删除\"><a href=\"#remove-删除\" class=\"headerlink\" title=\"remove 删除\"></a>remove 删除</h2><p>删除有两个实现，其一是：<code>remove()</code>不需要传入指针的位置，默认删除第一个，其二是<code>remove(int)</code>方法，该方法是传入一个需要删除的位置，如果删除成功会返回被删除的值。<br><code>remove()</code>方法的实现过程和<code>remove(int)</code>差不多，也可以理解为<code>remove()</code>默认传递了指针为0。这里就不单独介绍了。接下来就看看<code>remove(int)</code> 是怎么实现的。<br>代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在[0, size]之间</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// node(index)：待删除节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心实现在unlink方法中，接下来看看 unlink的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">    <span class=\"comment\">// x 为待删除节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item; <span class=\"comment\">// 保存一下值，删除完成之后，需要返回给调用者。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next; <span class=\"comment\">// 保存x的下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev; <span class=\"comment\">// 保存x的前一个节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果前置节点为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 直接设置LinkedList的frist节点为 x的下一个节点</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置x的前置节点的下一个节点为 x的后置节点</span></span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将x的前置节点设置为null，方便gc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        last = prev; <span class=\"comment\">// 如果x的后置节点为空，LinkedList的末尾节点设置为x的前置节点</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev; <span class=\"comment\">// 设置x的下一个节点的前置节点为 x的前置节点</span></span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将x的后置节点设置为null，方便gc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将x值设置为null，方便gc</span></span><br><span class=\"line\">    size--; <span class=\"comment\">// 容量 -1</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>删除方法的核心就是，将待删除节点的前置节点的下一个节点设置为待删除节点的下一个节点（读起来蛮拗口的，多读几遍就能理解了）。</p>\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><p><code>get(int)</code>方法，根据位置获取值。<br>先贴上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在[0, size]之间</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面已经有对node(index)方法做过解释了，该方法就是得到节点，返回节点的值。</p>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p><code>set(int, E)</code>方法是一个根据index替换其原来的值，最后返回原始值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在[0, size]之间</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据index获取需要设置的节点</span></span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    <span class=\"comment\">// 保存旧值</span></span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    <span class=\"comment\">// 设置新值</span></span><br><span class=\"line\">    x.item = element;</span><br><span class=\"line\">    <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2><p><code>poll()</code>方法是获取并删除第一个元素。其实就是删除第一个元素并返回删除元素的值和<code>remove()</code>方法相同。这里也不做过多解释了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"peek\"><a href=\"#peek\" class=\"headerlink\" title=\"peek\"></a>peek</h2><p><code>peek()</code> 获取第一个节点的值。和<code>poll()</code>唯一不同的是，<code>peek</code>不需要删除第一个节点。<br>实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>LinkedList的分析到这里就结束了。<br>LinkedList是一个双向列表，在删除，添加元素方面有着比ArrayList更好的体验。但是在查询的时候需要一个一个遍历得到结果，虽说在遍历的时候将LinkedList分为了前一半和后一半遍历，但是和ArrayList的底层动态数组相比，还是差的太多。所以在项目具体使用过程中，还是得按需使用。</p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>LinkedList是允许元素为null的<strong>双向链表</strong>，LinkedList是<strong>线程不安全</strong>的，底层是基于链表的实现。<br>因为底层是链表的原因，说明，插入、删除比较方便，只需要移动对应的指针即可。但是在处理随机访问的数据，就会要比ArrayList慢了。</p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><p>LinkedList的属性相对比较少，只有下面的三个属性。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 集合元素的数量</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 链表的第一个指针元素</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"><span class=\"comment\">// 链表最后一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><p>LinkedList只有两个构造方法，一个时默认的构造方法，另一个是将集合初始化到LinkedList。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化一个空的LinkedList</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化一个包含集合元素的LinkedList</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();  <span class=\"comment\">// 调用默认构造方法</span></span><br><span class=\"line\">    addAll(c); <span class=\"comment\">// 将元素全部添加到LinkedList</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在看 <code>addAll()</code>方法前，先看看Node节点结构<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item; <span class=\"comment\">// 节点值</span></span><br><span class=\"line\">    Node&lt;E&gt; next; <span class=\"comment\">// 下一个节点</span></span><br><span class=\"line\">    Node&lt;E&gt; prev; <span class=\"comment\">// 前一个节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看完了Node的结构，随便把<code>node(int)</code>方法给看了，该方法在文中会多次遇到。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\">    <span class=\"comment\">// size &gt;&gt; 1 等价于 size/2 。通过将LinkedList折半，增加查询效率。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first; <span class=\"comment\">// 保存第一个节点，因为需要从第一个节点开始循环查找</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>node(int index)</code>的实现是一个一个循环遍历得到的值，虽然说用到了缩小范围的折半方式优化查询。但是还是不可避免的导致获取效率低下。</p>\n<p>在初始化有集合元素的构造方法是会调用到 <code>addAll()</code> 方法，跟着 <code>addAll()</code> 方法一直看下去，核心实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在范围内 [0, size]</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length; <span class=\"comment\">// 记录传递过来的集合元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node&lt;E&gt; pred, succ; <span class=\"comment\">// pred: index前置节点, index的后置节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 在链表尾部添加数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">        succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        pred = last;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        succ = node(index); <span class=\"comment\">// 获取index节点的值，赋值给succ</span></span><br><span class=\"line\">        pred = succ.prev; <span class=\"comment\">// succ的前置节点赋值给 pred</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历添加元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) E e = (E) o;</span><br><span class=\"line\">         <span class=\"comment\">// 根据前置节点和当前元素之构建 node节点</span></span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>) <span class=\"comment\">// 没有前置节点</span></span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        pred = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断添加元素是否在队尾添加</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        last = pred; <span class=\"comment\">// 设置队尾节点</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 在链表中间添加的元素</span></span><br><span class=\"line\">        pred.next = succ; <span class=\"comment\">// 设置前置节点的下一个值</span></span><br><span class=\"line\">        succ.prev = pred; <span class=\"comment\">// 设置后置节点的前一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    size += numNew; <span class=\"comment\">// 重新设置LinkedList的元素数量</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 记录一次结构更改的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>addAll()</code>方法的实现过程还是容易看懂的。首先检查插入的位置是否在范围之内，接着判断是在链表中间插入数据，还是在链表尾部插入数据，设置根据succ和pred。然后循环遍历添加节点到LinkedList中。整个过程大致就是这样</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><p>接下来看看LinkedList中的常用方法</p>\n<h2 id=\"add-添加\"><a href=\"#add-添加\" class=\"headerlink\" title=\"add 添加\"></a>add 添加</h2><p>LinkedList的添加方法，主要是 <code>add(E)</code>、 <code>add(int, E)</code>，首先来看看默认的<code>add(E)</code>方法的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码没有具体逻辑，具体实现在<code>linkLast(e)</code>中，接着进入该方法中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last; <span class=\"comment\">// 将末尾节点设置给l节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据末尾节点做前置节点，得到一个新的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    last = newNode; <span class=\"comment\">// 更新末尾节点为新的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>linkLast</code>方法实现过程是，首先得到末尾节点<code>l</code>，根据<code>l</code>做前置节点得到一个新的节点，最后对末尾节点重新赋值。我们可以看出，整个<code>add</code>方法在不指定添加位置的情况下，默认将值添加到末尾的。<br>看了默认的add方法实现，接着看看在规定位置添加节点的实现<br><code>add(int, E)</code>方法的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 校验添加节点的位置是否在 [0, size] 之间</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// 如果添加的位置刚好尾部节点，直接调用默认添加方法的实现。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">        linkLast(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着进入<code>linkBefore</code>方法看看是怎么实现的。e: 待添加元素值，succ: 带添加位置的节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert succ != null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev; <span class=\"comment\">// 保存待添加位置的前置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ); <span class=\"comment\">// 根据前置节点、当前值、后置节点 得到一个新的节点</span></span><br><span class=\"line\">    succ.prev = newNode; <span class=\"comment\">// 设置添加位置的前置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        first = newNode; <span class=\"comment\">// 如果前置节点为空，直接设置 第一个节点 （first代表第一个节点）</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pred.next = newNode; <span class=\"comment\">// 将前面保存的前置节点的下一节点设置为新的节点</span></span><br><span class=\"line\">    size++; <span class=\"comment\">// 将LinkedList的容量加一</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 记录一下更改的次数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>整个过程通过代码中的注释，大致都能看的明白。<br>在添加方法中还有<code>addLast</code>、<code>addFrist</code>方法。首先看看<code>addLast</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现过程和默认的add方法一样，唯一的区别就是默认<code>add</code>方法有返回值，<code>addLast</code>方法没有返回值。<br>接下来看看<code>addFrist(E)</code>方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    linkFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first; <span class=\"comment\">// 保存原来的第一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f); <span class=\"comment\">// 得到一个新的节点，新节点的下一个节点就是原来的第一个节点</span></span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        last = newNode; <span class=\"comment\">// 说明之前为空的LinkedList，直接设置末尾节点为新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        f.prev = newNode; <span class=\"comment\">// 设置原来第一个节点的前置节点为新节点</span></span><br><span class=\"line\">    size++; <span class=\"comment\">// 容量+1</span></span><br><span class=\"line\">    modCount++; <span class=\"comment\">// 修改次数 +1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"remove-删除\"><a href=\"#remove-删除\" class=\"headerlink\" title=\"remove 删除\"></a>remove 删除</h2><p>删除有两个实现，其一是：<code>remove()</code>不需要传入指针的位置，默认删除第一个，其二是<code>remove(int)</code>方法，该方法是传入一个需要删除的位置，如果删除成功会返回被删除的值。<br><code>remove()</code>方法的实现过程和<code>remove(int)</code>差不多，也可以理解为<code>remove()</code>默认传递了指针为0。这里就不单独介绍了。接下来就看看<code>remove(int)</code> 是怎么实现的。<br>代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在[0, size]之间</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// node(index)：待删除节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>核心实现在unlink方法中，接下来看看 unlink的实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">    <span class=\"comment\">// x 为待删除节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> E element = x.item; <span class=\"comment\">// 保存一下值，删除完成之后，需要返回给调用者。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next; <span class=\"comment\">// 保存x的下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev; <span class=\"comment\">// 保存x的前一个节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果前置节点为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 直接设置LinkedList的frist节点为 x的下一个节点</span></span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置x的前置节点的下一个节点为 x的后置节点</span></span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将x的前置节点设置为null，方便gc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        last = prev; <span class=\"comment\">// 如果x的后置节点为空，LinkedList的末尾节点设置为x的前置节点</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev; <span class=\"comment\">// 设置x的下一个节点的前置节点为 x的前置节点</span></span><br><span class=\"line\">        x.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将x的后置节点设置为null，方便gc</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    x.item = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将x值设置为null，方便gc</span></span><br><span class=\"line\">    size--; <span class=\"comment\">// 容量 -1</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>删除方法的核心就是，将待删除节点的前置节点的下一个节点设置为待删除节点的下一个节点（读起来蛮拗口的，多读几遍就能理解了）。</p>\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><p><code>get(int)</code>方法，根据位置获取值。<br>先贴上代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在[0, size]之间</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面已经有对node(index)方法做过解释了，该方法就是得到节点，返回节点的值。</p>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p><code>set(int, E)</code>方法是一个根据index替换其原来的值，最后返回原始值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检验index是否在[0, size]之间</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据index获取需要设置的节点</span></span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    <span class=\"comment\">// 保存旧值</span></span><br><span class=\"line\">    E oldVal = x.item;</span><br><span class=\"line\">    <span class=\"comment\">// 设置新值</span></span><br><span class=\"line\">    x.item = element;</span><br><span class=\"line\">    <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2><p><code>poll()</code>方法是获取并删除第一个元素。其实就是删除第一个元素并返回删除元素的值和<code>remove()</code>方法相同。这里也不做过多解释了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"peek\"><a href=\"#peek\" class=\"headerlink\" title=\"peek\"></a>peek</h2><p><code>peek()</code> 获取第一个节点的值。和<code>poll()</code>唯一不同的是，<code>peek</code>不需要删除第一个节点。<br>实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>LinkedList的分析到这里就结束了。<br>LinkedList是一个双向列表，在删除，添加元素方面有着比ArrayList更好的体验。但是在查询的时候需要一个一个遍历得到结果，虽说在遍历的时候将LinkedList分为了前一半和后一半遍历，但是和ArrayList的底层动态数组相比，还是差的太多。所以在项目具体使用过程中，还是得按需使用。</p>\n"},{"title":"Java8源码学习-String","abbrlink":"e440274b","date":"2019-04-18T13:22:08.000Z","_content":"\n# 介绍\nString是开发中比较常用的类了。String表示字符串，比如\"abc\"等。String实现了序列化（Serializable）、排序（Comparable）、字符串(CharSequence)等方法。 String是不可变的，String在定义的时候使用了final，也就是说一旦创建，就不可更改。\n``` java\npublic final class String\nextends Object\nimplements Serializable, Comparable<String>, CharSequence\n```\n# 属性\n## value\n它使用字符存储，私有变量，并且为不可变的char类型，定义如下：\n``` java \nprivate final char value[];\n```\n## hash\n缓存String的hash code值，默认为0\n``` java\nprivate int hash; // Default to 0\n```\n\n# 构造方法\n下面介绍几个常用的构造方法\n## 空初始化 \n创建一个`\"\"`字符串。\n``` java\npublic String() {\n    this.value = \"\".value;\n}\n```\n## String类型初始化\n在使用使用`new`关键字的时候，我们一般会使用 `new String(\"str\")`来新建一个String。调用构造方法如下：\n``` java\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n```\n## 字符型（char）类型初始化\n通过`Arrays.copyOf`方法（底层实现调用了 `System.arraycopy()`）得到一个char[]赋值给value\n```\npublic String(char value[]) {\n    this.value = Arrays.copyOf(value, value.length);\n}\n```\n在使用String的使用中，`public String(char value[], int offset, int count)`方法在内部调用会常用到，比如：`subString`方法等。下面注意分析一下该方法的实现。\n``` java\n// offset：可以理解为偏移量，从什么位置开始。\n// count：字符串的长度\npublic String(char value[], int offset, int count) {\n    if (offset < 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count <= 0) {\n        if (count < 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        // 上面就是常规判断参数合法性\n        // 到这里，说明count=0； 返回一个空字符串\n        if (offset <= value.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1>>>1.\n    if (offset > value.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    // 调用 Arrays.copyOfRange方法 下面会说明\n    this.value = Arrays.copyOfRange(value, offset, offset+count);\n}\n\n```\n``` java\n// copyOfRange方法底层是调用了 `native`方法， `native`是一个原生函数，是由c++实现的。具体实现就不说了。\npublic static char[] copyOfRange(char[] original, int from, int to) {\n    // 新字符串的长度\n    int newLength = to - from;\n    if (newLength < 0)\n        throw new IllegalArgumentException(from + \" > \" + to);\n    // 新建一个char数组\n    char[] copy = new char[newLength];\n    // System.arraycopy 是一个native方法\n    // original： 原来的字符串， from： 复制的开始位置 \n    // copy：新的存储字符串数组， 0：表示从索引0位置开始， Math.min(original.length - from, newLength)： 复制的元素数量\n    System.arraycopy(original, from, copy, 0,\n                     Math.min(original.length - from, newLength));\n    return copy;\n}\n```\n另外的 int、byte类型初始化不常用，就不说了。\n## StringBuffer、StringBuilder类型初始化\n一般不使用，需要注意一下，StringBuffer是线程安全的，如果在不考虑线程安全的情况下，拼接字符串不使用StringBuffer，原因是线程同步所带来的开销太大。不考虑线程安全，推荐使用StringBuilder。\n``` java\npublic String(StringBuffer buffer) {\n    synchronized(buffer) {\n        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());\n    }\n}\npublic String(StringBuilder builder) {\n    this.value = Arrays.copyOf(builder.getValue(), builder.length());\n}\n```\n\n# 常用方法\n\n## equals 方法\nString的equals方法是重写了Object的equals方法。\n相关注释，写在代码之中，代码如下：\n``` java\npublic boolean equals(Object anObject) {\n    // 判断地址相等\n    if (this == anObject) {\n        return true;\n    }\n    // instanceof 关键字，用来判断传入参数类型\n    // 判断如果不为String类型，直接返回false。\n    if (anObject instanceof String) {\n        // 向下转型\n        String anotherString = (String)anObject;\n        int n = value.length;\n        // 判断anObject的长度和自身的长度是否相等\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            // 接着一个一个字符比较\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n总结一下，上面的大概流程。\n* 判断比较参数的地址是否相等，如果相等，直接返回true。\n* 判断anObject的长度和自身的长度是否相等，如果相等，循环遍历两个char[], 一个个比较char字符是否相等。\n使用例子：`\"abc\".equals(\"abc\")`\n\n## hashcode 方法\n通过hashcode方法会返回一个int类型的数值。\n实现如下：\n``` java\npublic int hashCode() {\n    int h = hash;\n    if (h == 0 && value.length > 0) {\n        char val[] = value;\n\n        for (int i = 0; i < value.length; i++) {\n            // val[i] 是获取 ASCII 码 比如 a ->97 , b ->98\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\nhashcode方法比较简单，首先获取value的长度，然后根据长度遍历，反复计算h的值。比如：`\"abc\".hashCode()`的返回值为：96354，\nh默认为0。字符对应的ASCII码，可以自行Google。\n第一次遍历： h = 31 * 0 + 97 ，所以 h = 97 \n第二次遍历： h = 31 * 97 + 98, h = 3105\n第三次遍历： h = 31 * 3105 + 99, h = 96,354\n还是比较容易理解的。\n\n## indexOf 方法\n`indexOf`可以接收`int`、`String`、`char`类型的参数, 该方法的作用是判断字符串是否包含传入参数。下面只介绍String的使用。\n`indexOf(Strinf str)` 方法如下：\n``` java\npublic int indexOf(String str) {\n    return indexOf(str, 0);\n}\npublic int indexOf(String str, int fromIndex) {\n    return indexOf(value, 0, value.length,\n            str.value, 0, str.value.length, fromIndex);\n}\n// 主要实现逻辑在这里。\n// source: 字符串本身 、 sourceOffset：字符串从什么位置比较,、 target: 待比较的字符串、 targetOffset: 待比较的字符串比较起始位置、 fromIndex： 从什么位置开始，默认为0\nstatic int indexOf(char[] source, int sourceOffset, int sourceCount,\n            char[] target, int targetOffset, int targetCount,\n            int fromIndex) {\n    if (fromIndex >= sourceCount) {\n        // 开始比较的位置大于等于了本身字符串的长度\n        // 待比较值为空，直接返回本身字符串长度，反之返回-1\n        return (targetCount == 0 ? sourceCount : -1);\n    }\n    if (fromIndex < 0) {\n        // 防止设置参数错误\n        fromIndex = 0;\n    }\n    if (targetCount == 0) {\n        // 相当于传递了一个空字符串， 直接返回 fromIndex\n        return fromIndex;\n    }\n    // 获取第一个待比较值的value , 比如 ”abc“, first = 'a'\n    char first = target[targetOffset];\n    // 计算循环结束的位置 比如： \"abc\".indexOf(\"b\") max为 0+(3-1) = 2;\n    int max = sourceOffset + (sourceCount - targetCount);\n    \n    for (int i = sourceOffset + fromIndex; i <= max; i++) {\n        /* Look for first character. */\n        // 找出第一个值与本身值相等的位置 i\n        if (source[i] != first) {\n            while (++i <= max && source[i] != first);\n        }\n\n        /* Found first character, now look at the rest of v2 */\n        // 前面主要是找出了第一个相等字符的位置，接着需要匹配后面的字符\n        if (i <= max) {\n            // j: 待比较第二个后面字符的开始位置\n            int j = i + 1;\n            // end：待比较字符的最后一个位置+1\n            int end = j + targetCount - 1;\n            // 依次比较后面字符 是否相等\n            for (int k = targetOffset + 1; j < end && source[j]\n                    == target[k]; j++, k++);\n            // 如果j 不等于 end ，说明 target 的其中一个字符不在source中。\n            if (j == end) {\n                /* Found whole string. */\n                // 返回第一个字符相等的位置\n                return i - sourceOffset;\n            }\n        }\n    }\n    return -1;\n}\n```\nindexOf方法，相对而言长一点，但是整体来说，还是不难理解。相应的注释已经写得差不多了，这里大概总结一下。\n* 首先比较第一个字符，如果第一个字符都不等，直接返回-1，表示没有找到。\n* 接着比较后面的字符，如果依次全等。返回第一个字符相等的位置。\n\n## substring 方法\n`substring`的功能是截取字符串，使用方式是指定一个起始位置`beginIndex`和结束位置`endIndex`(endIndex 可以不指定，默认为字符串最后一位)，代码实现如下：\n``` java\npublic String substring(int beginIndex) {\n    if (beginIndex < 0) {\n        // 传入参数不合格，抛出字符串索引越界异常\n        throw new StringIndexOutOfBoundsException(beginIndex);\n    }\n    // 需要截取的长度\n    int subLen = value.length - beginIndex;\n    if (subLen < 0) {\n        // 小于0，说明传入beginIndex大于了字符串本身的长度，抛出异常\n        throw new StringIndexOutOfBoundsException(subLen);\n    }\n    // 因为String是不可变的，所以返回一个新的字符串, new String()的具体实现，在构造方法里面已经说过了。\n    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);\n}\n```\n\n## replace 方法\n`replace()`方法的功能是替换字符串，比如 `\"hello world !\".replace(\" \", \"-\")` 变成了 `hello-world-!`\n```java\n// target：被替换的字符，replacement：替换的字符\npublic String replace(CharSequence target, CharSequence replacement) {\n    return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(\n            this).replaceAll(Matcher.quoteReplacement(replacement.toString()));\n}\n```\n`replaceFirst()`方法功能是替换第一个匹配的字符串，比如 `\"hello world !\".replaceFrist(\" \", \"-\")` 变成了 `hello-world !`\n``` java\npublic String replaceFirst(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n}\n```\n\n`replaceAll()`方法功能是替换第一个匹配的字符串，比如 `\"hello world !\".replaceAll(\" \", \"-\")` 变成了 `hello-world-!`\n```java\npublic String replaceAll(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n}\n```\n这三个方法主要区别是 `replaceFirst()`调用了`Matcher#replaceFirst`， `replace()`和`replaceAll()`调用了`Matcher#replaceAll`方法。\nMatcher的`replaceAll()`和`replaceFirst()`方法区别在对于`appendReplacement(sb, replacement);`的调用次数，`replaceFirst()`只调用一次，表示只替换第一个匹配的值\n```java\npublic String replaceAll(String replacement) {\n    reset();\n    boolean result = find();\n    if (result) {\n        StringBuffer sb = new StringBuffer();\n        do {\n            // 实现太复杂，不讨论了。\n            appendReplacement(sb, replacement);\n            result = find();\n        } while (result);\n        appendTail(sb);\n        return sb.toString();\n    }\n    return text.toString();\n}\n```\n\n## join 方法\n`join()`是1.8之后才有的新方法。功能是：将多个字符或者集合元素连接起来。例如：\n```java\nString message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n// message returned is: \"Java-is-cool\"\n\nList<String> strings = List.of(\"Java\", \"is\", \"cool\");\nString message = String.join(\" \", strings);\n//message returned is: \"Java is cool\"\n\nSet<String> strings =\n new LinkedHashSet<>(List.of(\"Java\", \"is\", \"very\", \"cool\"));\nString message = String.join(\"-\", strings);\n//message returned is: \"Java-is-very-cool\"\n```\n上面的例子表明了`String#join`方法可以接收 可变数组格式的字符、List、Set格式参数。下面来看看join的实现。\n```java\npublic static String join(CharSequence delimiter, CharSequence... elements) {\n    // 非空验证\n    Objects.requireNonNull(delimiter);\n    Objects.requireNonNull(elements);\n    // Number of elements not likely worth Arrays.stream overhead.\n    StringJoiner joiner = new StringJoiner(delimiter);\n    for (CharSequence cs: elements) {\n        joiner.add(cs);\n    }\n    return joiner.toString();\n}\n```\n上面的方法我们会看见有一个新的class出现了，`StringJoiner`也是1.8之后的才有的。主要参数有：`delimiter`：分隔符，`value`：定义类型是`StringBuilder`，由此可以看出来具体拼接还是通过`StringBuilder`实现的，另外还有`prefix`、`suffix`。\n``` java\npublic StringJoiner add(CharSequence newElement) {\n    prepareBuilder().append(newElement);\n    return this;\n}\n// 主要实现在prepareBuilder()这里\nprivate StringBuilder prepareBuilder() {\n    if (value != null) {\n        // 添加 连接字符\n        value.append(delimiter);\n    } else {\n        // 新建一个StringBulider, 如果有前缀也加上。\n        value = new StringBuilder().append(prefix);\n    }\n    return value;\n}\n```\n`prepareBuilder()`执行完之后，才会去添加新的元素。\n\n# 结束\n到了这里也差不多了， `String`中还有很多方法，就不去一一解析了，当然我们需要知道怎么使用，具体功能是什么，下面做个功能总结：\n\n* `trim` 去掉首尾的空格\n* `toLowerCase` 将字符串大写字母转为小写\n* `toUpperCase` 将字符串小写字母转为大写\n* `split` 根据特定字符拆分成一个数组\n* `toString` 这个方法使用频率很高，需要注意它和`String#valueOf`的区别。如果`null`调用了`toString`会抛出`NullException`，而`null`调用了`valueOf`,会返回`\"null\"`字符。\n\n","source":"_posts/jdk8-source-String.md","raw":"---\ntitle: Java8源码学习-String\ncategory:\n  - Java\ntags:\n  - java\n  - 源码\nabbrlink: e440274b\ndate: 2019-04-18 21:22:08\n---\n\n# 介绍\nString是开发中比较常用的类了。String表示字符串，比如\"abc\"等。String实现了序列化（Serializable）、排序（Comparable）、字符串(CharSequence)等方法。 String是不可变的，String在定义的时候使用了final，也就是说一旦创建，就不可更改。\n``` java\npublic final class String\nextends Object\nimplements Serializable, Comparable<String>, CharSequence\n```\n# 属性\n## value\n它使用字符存储，私有变量，并且为不可变的char类型，定义如下：\n``` java \nprivate final char value[];\n```\n## hash\n缓存String的hash code值，默认为0\n``` java\nprivate int hash; // Default to 0\n```\n\n# 构造方法\n下面介绍几个常用的构造方法\n## 空初始化 \n创建一个`\"\"`字符串。\n``` java\npublic String() {\n    this.value = \"\".value;\n}\n```\n## String类型初始化\n在使用使用`new`关键字的时候，我们一般会使用 `new String(\"str\")`来新建一个String。调用构造方法如下：\n``` java\npublic String(String original) {\n    this.value = original.value;\n    this.hash = original.hash;\n}\n```\n## 字符型（char）类型初始化\n通过`Arrays.copyOf`方法（底层实现调用了 `System.arraycopy()`）得到一个char[]赋值给value\n```\npublic String(char value[]) {\n    this.value = Arrays.copyOf(value, value.length);\n}\n```\n在使用String的使用中，`public String(char value[], int offset, int count)`方法在内部调用会常用到，比如：`subString`方法等。下面注意分析一下该方法的实现。\n``` java\n// offset：可以理解为偏移量，从什么位置开始。\n// count：字符串的长度\npublic String(char value[], int offset, int count) {\n    if (offset < 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count <= 0) {\n        if (count < 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        // 上面就是常规判断参数合法性\n        // 到这里，说明count=0； 返回一个空字符串\n        if (offset <= value.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1>>>1.\n    if (offset > value.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    // 调用 Arrays.copyOfRange方法 下面会说明\n    this.value = Arrays.copyOfRange(value, offset, offset+count);\n}\n\n```\n``` java\n// copyOfRange方法底层是调用了 `native`方法， `native`是一个原生函数，是由c++实现的。具体实现就不说了。\npublic static char[] copyOfRange(char[] original, int from, int to) {\n    // 新字符串的长度\n    int newLength = to - from;\n    if (newLength < 0)\n        throw new IllegalArgumentException(from + \" > \" + to);\n    // 新建一个char数组\n    char[] copy = new char[newLength];\n    // System.arraycopy 是一个native方法\n    // original： 原来的字符串， from： 复制的开始位置 \n    // copy：新的存储字符串数组， 0：表示从索引0位置开始， Math.min(original.length - from, newLength)： 复制的元素数量\n    System.arraycopy(original, from, copy, 0,\n                     Math.min(original.length - from, newLength));\n    return copy;\n}\n```\n另外的 int、byte类型初始化不常用，就不说了。\n## StringBuffer、StringBuilder类型初始化\n一般不使用，需要注意一下，StringBuffer是线程安全的，如果在不考虑线程安全的情况下，拼接字符串不使用StringBuffer，原因是线程同步所带来的开销太大。不考虑线程安全，推荐使用StringBuilder。\n``` java\npublic String(StringBuffer buffer) {\n    synchronized(buffer) {\n        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());\n    }\n}\npublic String(StringBuilder builder) {\n    this.value = Arrays.copyOf(builder.getValue(), builder.length());\n}\n```\n\n# 常用方法\n\n## equals 方法\nString的equals方法是重写了Object的equals方法。\n相关注释，写在代码之中，代码如下：\n``` java\npublic boolean equals(Object anObject) {\n    // 判断地址相等\n    if (this == anObject) {\n        return true;\n    }\n    // instanceof 关键字，用来判断传入参数类型\n    // 判断如果不为String类型，直接返回false。\n    if (anObject instanceof String) {\n        // 向下转型\n        String anotherString = (String)anObject;\n        int n = value.length;\n        // 判断anObject的长度和自身的长度是否相等\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            // 接着一个一个字符比较\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n总结一下，上面的大概流程。\n* 判断比较参数的地址是否相等，如果相等，直接返回true。\n* 判断anObject的长度和自身的长度是否相等，如果相等，循环遍历两个char[], 一个个比较char字符是否相等。\n使用例子：`\"abc\".equals(\"abc\")`\n\n## hashcode 方法\n通过hashcode方法会返回一个int类型的数值。\n实现如下：\n``` java\npublic int hashCode() {\n    int h = hash;\n    if (h == 0 && value.length > 0) {\n        char val[] = value;\n\n        for (int i = 0; i < value.length; i++) {\n            // val[i] 是获取 ASCII 码 比如 a ->97 , b ->98\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\nhashcode方法比较简单，首先获取value的长度，然后根据长度遍历，反复计算h的值。比如：`\"abc\".hashCode()`的返回值为：96354，\nh默认为0。字符对应的ASCII码，可以自行Google。\n第一次遍历： h = 31 * 0 + 97 ，所以 h = 97 \n第二次遍历： h = 31 * 97 + 98, h = 3105\n第三次遍历： h = 31 * 3105 + 99, h = 96,354\n还是比较容易理解的。\n\n## indexOf 方法\n`indexOf`可以接收`int`、`String`、`char`类型的参数, 该方法的作用是判断字符串是否包含传入参数。下面只介绍String的使用。\n`indexOf(Strinf str)` 方法如下：\n``` java\npublic int indexOf(String str) {\n    return indexOf(str, 0);\n}\npublic int indexOf(String str, int fromIndex) {\n    return indexOf(value, 0, value.length,\n            str.value, 0, str.value.length, fromIndex);\n}\n// 主要实现逻辑在这里。\n// source: 字符串本身 、 sourceOffset：字符串从什么位置比较,、 target: 待比较的字符串、 targetOffset: 待比较的字符串比较起始位置、 fromIndex： 从什么位置开始，默认为0\nstatic int indexOf(char[] source, int sourceOffset, int sourceCount,\n            char[] target, int targetOffset, int targetCount,\n            int fromIndex) {\n    if (fromIndex >= sourceCount) {\n        // 开始比较的位置大于等于了本身字符串的长度\n        // 待比较值为空，直接返回本身字符串长度，反之返回-1\n        return (targetCount == 0 ? sourceCount : -1);\n    }\n    if (fromIndex < 0) {\n        // 防止设置参数错误\n        fromIndex = 0;\n    }\n    if (targetCount == 0) {\n        // 相当于传递了一个空字符串， 直接返回 fromIndex\n        return fromIndex;\n    }\n    // 获取第一个待比较值的value , 比如 ”abc“, first = 'a'\n    char first = target[targetOffset];\n    // 计算循环结束的位置 比如： \"abc\".indexOf(\"b\") max为 0+(3-1) = 2;\n    int max = sourceOffset + (sourceCount - targetCount);\n    \n    for (int i = sourceOffset + fromIndex; i <= max; i++) {\n        /* Look for first character. */\n        // 找出第一个值与本身值相等的位置 i\n        if (source[i] != first) {\n            while (++i <= max && source[i] != first);\n        }\n\n        /* Found first character, now look at the rest of v2 */\n        // 前面主要是找出了第一个相等字符的位置，接着需要匹配后面的字符\n        if (i <= max) {\n            // j: 待比较第二个后面字符的开始位置\n            int j = i + 1;\n            // end：待比较字符的最后一个位置+1\n            int end = j + targetCount - 1;\n            // 依次比较后面字符 是否相等\n            for (int k = targetOffset + 1; j < end && source[j]\n                    == target[k]; j++, k++);\n            // 如果j 不等于 end ，说明 target 的其中一个字符不在source中。\n            if (j == end) {\n                /* Found whole string. */\n                // 返回第一个字符相等的位置\n                return i - sourceOffset;\n            }\n        }\n    }\n    return -1;\n}\n```\nindexOf方法，相对而言长一点，但是整体来说，还是不难理解。相应的注释已经写得差不多了，这里大概总结一下。\n* 首先比较第一个字符，如果第一个字符都不等，直接返回-1，表示没有找到。\n* 接着比较后面的字符，如果依次全等。返回第一个字符相等的位置。\n\n## substring 方法\n`substring`的功能是截取字符串，使用方式是指定一个起始位置`beginIndex`和结束位置`endIndex`(endIndex 可以不指定，默认为字符串最后一位)，代码实现如下：\n``` java\npublic String substring(int beginIndex) {\n    if (beginIndex < 0) {\n        // 传入参数不合格，抛出字符串索引越界异常\n        throw new StringIndexOutOfBoundsException(beginIndex);\n    }\n    // 需要截取的长度\n    int subLen = value.length - beginIndex;\n    if (subLen < 0) {\n        // 小于0，说明传入beginIndex大于了字符串本身的长度，抛出异常\n        throw new StringIndexOutOfBoundsException(subLen);\n    }\n    // 因为String是不可变的，所以返回一个新的字符串, new String()的具体实现，在构造方法里面已经说过了。\n    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);\n}\n```\n\n## replace 方法\n`replace()`方法的功能是替换字符串，比如 `\"hello world !\".replace(\" \", \"-\")` 变成了 `hello-world-!`\n```java\n// target：被替换的字符，replacement：替换的字符\npublic String replace(CharSequence target, CharSequence replacement) {\n    return Pattern.compile(target.toString(), Pattern.LITERAL).matcher(\n            this).replaceAll(Matcher.quoteReplacement(replacement.toString()));\n}\n```\n`replaceFirst()`方法功能是替换第一个匹配的字符串，比如 `\"hello world !\".replaceFrist(\" \", \"-\")` 变成了 `hello-world !`\n``` java\npublic String replaceFirst(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n}\n```\n\n`replaceAll()`方法功能是替换第一个匹配的字符串，比如 `\"hello world !\".replaceAll(\" \", \"-\")` 变成了 `hello-world-!`\n```java\npublic String replaceAll(String regex, String replacement) {\n    return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n}\n```\n这三个方法主要区别是 `replaceFirst()`调用了`Matcher#replaceFirst`， `replace()`和`replaceAll()`调用了`Matcher#replaceAll`方法。\nMatcher的`replaceAll()`和`replaceFirst()`方法区别在对于`appendReplacement(sb, replacement);`的调用次数，`replaceFirst()`只调用一次，表示只替换第一个匹配的值\n```java\npublic String replaceAll(String replacement) {\n    reset();\n    boolean result = find();\n    if (result) {\n        StringBuffer sb = new StringBuffer();\n        do {\n            // 实现太复杂，不讨论了。\n            appendReplacement(sb, replacement);\n            result = find();\n        } while (result);\n        appendTail(sb);\n        return sb.toString();\n    }\n    return text.toString();\n}\n```\n\n## join 方法\n`join()`是1.8之后才有的新方法。功能是：将多个字符或者集合元素连接起来。例如：\n```java\nString message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n// message returned is: \"Java-is-cool\"\n\nList<String> strings = List.of(\"Java\", \"is\", \"cool\");\nString message = String.join(\" \", strings);\n//message returned is: \"Java is cool\"\n\nSet<String> strings =\n new LinkedHashSet<>(List.of(\"Java\", \"is\", \"very\", \"cool\"));\nString message = String.join(\"-\", strings);\n//message returned is: \"Java-is-very-cool\"\n```\n上面的例子表明了`String#join`方法可以接收 可变数组格式的字符、List、Set格式参数。下面来看看join的实现。\n```java\npublic static String join(CharSequence delimiter, CharSequence... elements) {\n    // 非空验证\n    Objects.requireNonNull(delimiter);\n    Objects.requireNonNull(elements);\n    // Number of elements not likely worth Arrays.stream overhead.\n    StringJoiner joiner = new StringJoiner(delimiter);\n    for (CharSequence cs: elements) {\n        joiner.add(cs);\n    }\n    return joiner.toString();\n}\n```\n上面的方法我们会看见有一个新的class出现了，`StringJoiner`也是1.8之后的才有的。主要参数有：`delimiter`：分隔符，`value`：定义类型是`StringBuilder`，由此可以看出来具体拼接还是通过`StringBuilder`实现的，另外还有`prefix`、`suffix`。\n``` java\npublic StringJoiner add(CharSequence newElement) {\n    prepareBuilder().append(newElement);\n    return this;\n}\n// 主要实现在prepareBuilder()这里\nprivate StringBuilder prepareBuilder() {\n    if (value != null) {\n        // 添加 连接字符\n        value.append(delimiter);\n    } else {\n        // 新建一个StringBulider, 如果有前缀也加上。\n        value = new StringBuilder().append(prefix);\n    }\n    return value;\n}\n```\n`prepareBuilder()`执行完之后，才会去添加新的元素。\n\n# 结束\n到了这里也差不多了， `String`中还有很多方法，就不去一一解析了，当然我们需要知道怎么使用，具体功能是什么，下面做个功能总结：\n\n* `trim` 去掉首尾的空格\n* `toLowerCase` 将字符串大写字母转为小写\n* `toUpperCase` 将字符串小写字母转为大写\n* `split` 根据特定字符拆分成一个数组\n* `toString` 这个方法使用频率很高，需要注意它和`String#valueOf`的区别。如果`null`调用了`toString`会抛出`NullException`，而`null`调用了`valueOf`,会返回`\"null\"`字符。\n\n","slug":"jdk8-source-String","published":1,"updated":"2019-12-23T10:59:48.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpj1003ni3slhjkfed4b","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>String是开发中比较常用的类了。String表示字符串，比如”abc”等。String实现了序列化（Serializable）、排序（Comparable）、字符串(CharSequence)等方法。 String是不可变的，String在定义的时候使用了final，也就是说一旦创建，就不可更改。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extends</span> <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span></span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><h2 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"value\"></a>value</h2><p>它使用字符存储，私有变量，并且为不可变的char类型，定义如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h2><p>缓存String的hash code值，默认为0<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// Default to 0</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><p>下面介绍几个常用的构造方法</p>\n<h2 id=\"空初始化\"><a href=\"#空初始化\" class=\"headerlink\" title=\"空初始化\"></a>空初始化</h2><p>创建一个<code>&quot;&quot;</code>字符串。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"string\">\"\"</span>.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"String类型初始化\"><a href=\"#String类型初始化\" class=\"headerlink\" title=\"String类型初始化\"></a>String类型初始化</h2><p>在使用使用<code>new</code>关键字的时候，我们一般会使用 <code>new String(&quot;str&quot;)</code>来新建一个String。调用构造方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(String original)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = original.value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash = original.hash;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符型（char）类型初始化\"><a href=\"#字符型（char）类型初始化\" class=\"headerlink\" title=\"字符型（char）类型初始化\"></a>字符型（char）类型初始化</h2><p>通过<code>Arrays.copyOf</code>方法（底层实现调用了 <code>System.arraycopy()</code>）得到一个char[]赋值给value<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String(char value[]) &#123;</span><br><span class=\"line\">    this.value = Arrays.copyOf(value, value.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用String的使用中，<code>public String(char value[], int offset, int count)</code>方法在内部调用会常用到，比如：<code>subString</code>方法等。下面注意分析一下该方法的实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// offset：可以理解为偏移量，从什么位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">// count：字符串的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(<span class=\"keyword\">char</span> value[], <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 上面就是常规判断参数合法性</span></span><br><span class=\"line\">        <span class=\"comment\">// 到这里，说明count=0； 返回一个空字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (offset &lt;= value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = <span class=\"string\">\"\"</span>.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &gt; value.length - count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Arrays.copyOfRange方法 下面会说明</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// copyOfRange方法底层是调用了 `native`方法， `native`是一个原生函数，是由c++实现的。具体实现就不说了。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">char</span>[] copyOfRange(<span class=\"keyword\">char</span>[] original, <span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> to) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLength = to - from;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newLength &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(from + <span class=\"string\">\" &gt; \"</span> + to);</span><br><span class=\"line\">    <span class=\"comment\">// 新建一个char数组</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] copy = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[newLength];</span><br><span class=\"line\">    <span class=\"comment\">// System.arraycopy 是一个native方法</span></span><br><span class=\"line\">    <span class=\"comment\">// original： 原来的字符串， from： 复制的开始位置 </span></span><br><span class=\"line\">    <span class=\"comment\">// copy：新的存储字符串数组， 0：表示从索引0位置开始， Math.min(original.length - from, newLength)： 复制的元素数量</span></span><br><span class=\"line\">    System.arraycopy(original, from, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                     Math.min(original.length - from, newLength));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外的 int、byte类型初始化不常用，就不说了。</p>\n<h2 id=\"StringBuffer、StringBuilder类型初始化\"><a href=\"#StringBuffer、StringBuilder类型初始化\" class=\"headerlink\" title=\"StringBuffer、StringBuilder类型初始化\"></a>StringBuffer、StringBuilder类型初始化</h2><p>一般不使用，需要注意一下，StringBuffer是线程安全的，如果在不考虑线程安全的情况下，拼接字符串不使用StringBuffer，原因是线程同步所带来的开销太大。不考虑线程安全，推荐使用StringBuilder。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuffer buffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(buffer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"equals-方法\"><a href=\"#equals-方法\" class=\"headerlink\" title=\"equals 方法\"></a>equals 方法</h2><p>String的equals方法是重写了Object的equals方法。<br>相关注释，写在代码之中，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断地址相等</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// instanceof 关键字，用来判断传入参数类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 判断如果不为String类型，直接返回false。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 向下转型</span></span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"comment\">// 判断anObject的长度和自身的长度是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 接着一个一个字符比较</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总结一下，上面的大概流程。</p>\n<ul>\n<li>判断比较参数的地址是否相等，如果相等，直接返回true。</li>\n<li>判断anObject的长度和自身的长度是否相等，如果相等，循环遍历两个char[], 一个个比较char字符是否相等。<br>使用例子：<code>&quot;abc&quot;.equals(&quot;abc&quot;)</code></li>\n</ul>\n<h2 id=\"hashcode-方法\"><a href=\"#hashcode-方法\" class=\"headerlink\" title=\"hashcode 方法\"></a>hashcode 方法</h2><p>通过hashcode方法会返回一个int类型的数值。<br>实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// val[i] 是获取 ASCII 码 比如 a -&gt;97 , b -&gt;98</span></span><br><span class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hashcode方法比较简单，首先获取value的长度，然后根据长度遍历，反复计算h的值。比如：<code>&quot;abc&quot;.hashCode()</code>的返回值为：96354，<br>h默认为0。字符对应的ASCII码，可以自行Google。<br>第一次遍历： h = 31 <em> 0 + 97 ，所以 h = 97<br>第二次遍历： h = 31 </em> 97 + 98, h = 3105<br>第三次遍历： h = 31 * 3105 + 99, h = 96,354<br>还是比较容易理解的。</p>\n<h2 id=\"indexOf-方法\"><a href=\"#indexOf-方法\" class=\"headerlink\" title=\"indexOf 方法\"></a>indexOf 方法</h2><p><code>indexOf</code>可以接收<code>int</code>、<code>String</code>、<code>char</code>类型的参数, 该方法的作用是判断字符串是否包含传入参数。下面只介绍String的使用。<br><code>indexOf(Strinf str)</code> 方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(str, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(String str, <span class=\"keyword\">int</span> fromIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(value, <span class=\"number\">0</span>, value.length,</span><br><span class=\"line\">            str.value, <span class=\"number\">0</span>, str.value.length, fromIndex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 主要实现逻辑在这里。</span></span><br><span class=\"line\"><span class=\"comment\">// source: 字符串本身 、 sourceOffset：字符串从什么位置比较,、 target: 待比较的字符串、 targetOffset: 待比较的字符串比较起始位置、 fromIndex： 从什么位置开始，默认为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(<span class=\"keyword\">char</span>[] source, <span class=\"keyword\">int</span> sourceOffset, <span class=\"keyword\">int</span> sourceCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">char</span>[] target, <span class=\"keyword\">int</span> targetOffset, <span class=\"keyword\">int</span> targetCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> fromIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始比较的位置大于等于了本身字符串的长度</span></span><br><span class=\"line\">        <span class=\"comment\">// 待比较值为空，直接返回本身字符串长度，反之返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (targetCount == <span class=\"number\">0</span> ? sourceCount : -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止设置参数错误</span></span><br><span class=\"line\">        fromIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相当于传递了一个空字符串， 直接返回 fromIndex</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fromIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取第一个待比较值的value , 比如 ”abc“, first = 'a'</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> first = target[targetOffset];</span><br><span class=\"line\">    <span class=\"comment\">// 计算循环结束的位置 比如： \"abc\".indexOf(\"b\") max为 0+(3-1) = 2;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Look for first character. */</span></span><br><span class=\"line\">        <span class=\"comment\">// 找出第一个值与本身值相等的位置 i</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source[i] != first) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Found first character, now look at the rest of v2 */</span></span><br><span class=\"line\">        <span class=\"comment\">// 前面主要是找出了第一个相等字符的位置，接着需要匹配后面的字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= max) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// j: 待比较第二个后面字符的开始位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// end：待比较字符的最后一个位置+1</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = j + targetCount - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 依次比较后面字符 是否相等</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = targetOffset + <span class=\"number\">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class=\"line\">                    == target[k]; j++, k++);</span><br><span class=\"line\">            <span class=\"comment\">// 如果j 不等于 end ，说明 target 的其中一个字符不在source中。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == end) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* Found whole string. */</span></span><br><span class=\"line\">                <span class=\"comment\">// 返回第一个字符相等的位置</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - sourceOffset;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>indexOf方法，相对而言长一点，但是整体来说，还是不难理解。相应的注释已经写得差不多了，这里大概总结一下。</p>\n<ul>\n<li>首先比较第一个字符，如果第一个字符都不等，直接返回-1，表示没有找到。</li>\n<li>接着比较后面的字符，如果依次全等。返回第一个字符相等的位置。</li>\n</ul>\n<h2 id=\"substring-方法\"><a href=\"#substring-方法\" class=\"headerlink\" title=\"substring 方法\"></a>substring 方法</h2><p><code>substring</code>的功能是截取字符串，使用方式是指定一个起始位置<code>beginIndex</code>和结束位置<code>endIndex</code>(endIndex 可以不指定，默认为字符串最后一位)，代码实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">substring</span><span class=\"params\">(<span class=\"keyword\">int</span> beginIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beginIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入参数不合格，抛出字符串索引越界异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 需要截取的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> subLen = value.length - beginIndex;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (subLen &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 小于0，说明传入beginIndex大于了字符串本身的长度，抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为String是不可变的，所以返回一个新的字符串, new String()的具体实现，在构造方法里面已经说过了。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (beginIndex == <span class=\"number\">0</span>) ? <span class=\"keyword\">this</span> : <span class=\"keyword\">new</span> String(value, beginIndex, subLen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"replace-方法\"><a href=\"#replace-方法\" class=\"headerlink\" title=\"replace 方法\"></a>replace 方法</h2><p><code>replace()</code>方法的功能是替换字符串，比如 <code>&quot;hello world !&quot;.replace(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world-!</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// target：被替换的字符，replacement：替换的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replace</span><span class=\"params\">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class=\"line\">            <span class=\"keyword\">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>replaceFirst()</code>方法功能是替换第一个匹配的字符串，比如 <code>&quot;hello world !&quot;.replaceFrist(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world !</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceFirst</span><span class=\"params\">(String regex, String replacement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(regex).matcher(<span class=\"keyword\">this</span>).replaceFirst(replacement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>replaceAll()</code>方法功能是替换第一个匹配的字符串，比如 <code>&quot;hello world !&quot;.replaceAll(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world-!</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceAll</span><span class=\"params\">(String regex, String replacement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(regex).matcher(<span class=\"keyword\">this</span>).replaceAll(replacement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这三个方法主要区别是 <code>replaceFirst()</code>调用了<code>Matcher#replaceFirst</code>， <code>replace()</code>和<code>replaceAll()</code>调用了<code>Matcher#replaceAll</code>方法。<br>Matcher的<code>replaceAll()</code>和<code>replaceFirst()</code>方法区别在对于<code>appendReplacement(sb, replacement);</code>的调用次数，<code>replaceFirst()</code>只调用一次，表示只替换第一个匹配的值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceAll</span><span class=\"params\">(String replacement)</span> </span>&#123;</span><br><span class=\"line\">    reset();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = find();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实现太复杂，不讨论了。</span></span><br><span class=\"line\">            appendReplacement(sb, replacement);</span><br><span class=\"line\">            result = find();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (result);</span><br><span class=\"line\">        appendTail(sb);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"join-方法\"><a href=\"#join-方法\" class=\"headerlink\" title=\"join 方法\"></a>join 方法</h2><p><code>join()</code>是1.8之后才有的新方法。功能是：将多个字符或者集合元素连接起来。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String message = String.join(<span class=\"string\">\"-\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"cool\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// message returned is: \"Java-is-cool\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; strings = List.of(<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"cool\"</span>);</span><br><span class=\"line\">String message = String.join(<span class=\"string\">\" \"</span>, strings);</span><br><span class=\"line\"><span class=\"comment\">//message returned is: \"Java is cool\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Set&lt;String&gt; strings =</span><br><span class=\"line\"> <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;(List.of(<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"very\"</span>, <span class=\"string\">\"cool\"</span>));</span><br><span class=\"line\">String message = String.join(<span class=\"string\">\"-\"</span>, strings);</span><br><span class=\"line\"><span class=\"comment\">//message returned is: \"Java-is-very-cool\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的例子表明了<code>String#join</code>方法可以接收 可变数组格式的字符、List、Set格式参数。下面来看看join的实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">join</span><span class=\"params\">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 非空验证</span></span><br><span class=\"line\">    Objects.requireNonNull(delimiter);</span><br><span class=\"line\">    Objects.requireNonNull(elements);</span><br><span class=\"line\">    <span class=\"comment\">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class=\"line\">    StringJoiner joiner = <span class=\"keyword\">new</span> StringJoiner(delimiter);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (CharSequence cs: elements) &#123;</span><br><span class=\"line\">        joiner.add(cs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> joiner.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法我们会看见有一个新的class出现了，<code>StringJoiner</code>也是1.8之后的才有的。主要参数有：<code>delimiter</code>：分隔符，<code>value</code>：定义类型是<code>StringBuilder</code>，由此可以看出来具体拼接还是通过<code>StringBuilder</code>实现的，另外还有<code>prefix</code>、<code>suffix</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringJoiner <span class=\"title\">add</span><span class=\"params\">(CharSequence newElement)</span> </span>&#123;</span><br><span class=\"line\">    prepareBuilder().append(newElement);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 主要实现在prepareBuilder()这里</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> StringBuilder <span class=\"title\">prepareBuilder</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加 连接字符</span></span><br><span class=\"line\">        value.append(delimiter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新建一个StringBulider, 如果有前缀也加上。</span></span><br><span class=\"line\">        value = <span class=\"keyword\">new</span> StringBuilder().append(prefix);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>prepareBuilder()</code>执行完之后，才会去添加新的元素。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>到了这里也差不多了， <code>String</code>中还有很多方法，就不去一一解析了，当然我们需要知道怎么使用，具体功能是什么，下面做个功能总结：</p>\n<ul>\n<li><code>trim</code> 去掉首尾的空格</li>\n<li><code>toLowerCase</code> 将字符串大写字母转为小写</li>\n<li><code>toUpperCase</code> 将字符串小写字母转为大写</li>\n<li><code>split</code> 根据特定字符拆分成一个数组</li>\n<li><code>toString</code> 这个方法使用频率很高，需要注意它和<code>String#valueOf</code>的区别。如果<code>null</code>调用了<code>toString</code>会抛出<code>NullException</code>，而<code>null</code>调用了<code>valueOf</code>,会返回<code>&quot;null&quot;</code>字符。</li>\n</ul>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>String是开发中比较常用的类了。String表示字符串，比如”abc”等。String实现了序列化（Serializable）、排序（Comparable）、字符串(CharSequence)等方法。 String是不可变的，String在定义的时候使用了final，也就是说一旦创建，就不可更改。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extends</span> <span class=\"title\">Object</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span></span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><h2 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"value\"></a>value</h2><p>它使用字符存储，私有变量，并且为不可变的char类型，定义如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h2><p>缓存String的hash code值，默认为0<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// Default to 0</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><p>下面介绍几个常用的构造方法</p>\n<h2 id=\"空初始化\"><a href=\"#空初始化\" class=\"headerlink\" title=\"空初始化\"></a>空初始化</h2><p>创建一个<code>&quot;&quot;</code>字符串。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"string\">\"\"</span>.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"String类型初始化\"><a href=\"#String类型初始化\" class=\"headerlink\" title=\"String类型初始化\"></a>String类型初始化</h2><p>在使用使用<code>new</code>关键字的时候，我们一般会使用 <code>new String(&quot;str&quot;)</code>来新建一个String。调用构造方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(String original)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = original.value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash = original.hash;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符型（char）类型初始化\"><a href=\"#字符型（char）类型初始化\" class=\"headerlink\" title=\"字符型（char）类型初始化\"></a>字符型（char）类型初始化</h2><p>通过<code>Arrays.copyOf</code>方法（底层实现调用了 <code>System.arraycopy()</code>）得到一个char[]赋值给value<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String(char value[]) &#123;</span><br><span class=\"line\">    this.value = Arrays.copyOf(value, value.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用String的使用中，<code>public String(char value[], int offset, int count)</code>方法在内部调用会常用到，比如：<code>subString</code>方法等。下面注意分析一下该方法的实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// offset：可以理解为偏移量，从什么位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">// count：字符串的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(<span class=\"keyword\">char</span> value[], <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 上面就是常规判断参数合法性</span></span><br><span class=\"line\">        <span class=\"comment\">// 到这里，说明count=0； 返回一个空字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (offset &lt;= value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = <span class=\"string\">\"\"</span>.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset &gt; value.length - count) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Arrays.copyOfRange方法 下面会说明</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// copyOfRange方法底层是调用了 `native`方法， `native`是一个原生函数，是由c++实现的。具体实现就不说了。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">char</span>[] copyOfRange(<span class=\"keyword\">char</span>[] original, <span class=\"keyword\">int</span> from, <span class=\"keyword\">int</span> to) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLength = to - from;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newLength &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(from + <span class=\"string\">\" &gt; \"</span> + to);</span><br><span class=\"line\">    <span class=\"comment\">// 新建一个char数组</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] copy = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[newLength];</span><br><span class=\"line\">    <span class=\"comment\">// System.arraycopy 是一个native方法</span></span><br><span class=\"line\">    <span class=\"comment\">// original： 原来的字符串， from： 复制的开始位置 </span></span><br><span class=\"line\">    <span class=\"comment\">// copy：新的存储字符串数组， 0：表示从索引0位置开始， Math.min(original.length - from, newLength)： 复制的元素数量</span></span><br><span class=\"line\">    System.arraycopy(original, from, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                     Math.min(original.length - from, newLength));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外的 int、byte类型初始化不常用，就不说了。</p>\n<h2 id=\"StringBuffer、StringBuilder类型初始化\"><a href=\"#StringBuffer、StringBuilder类型初始化\" class=\"headerlink\" title=\"StringBuffer、StringBuilder类型初始化\"></a>StringBuffer、StringBuilder类型初始化</h2><p>一般不使用，需要注意一下，StringBuffer是线程安全的，如果在不考虑线程安全的情况下，拼接字符串不使用StringBuffer，原因是线程同步所带来的开销太大。不考虑线程安全，推荐使用StringBuilder。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuffer buffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(buffer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">String</span><span class=\"params\">(StringBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"equals-方法\"><a href=\"#equals-方法\" class=\"headerlink\" title=\"equals 方法\"></a>equals 方法</h2><p>String的equals方法是重写了Object的equals方法。<br>相关注释，写在代码之中，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断地址相等</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// instanceof 关键字，用来判断传入参数类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 判断如果不为String类型，直接返回false。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 向下转型</span></span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"comment\">// 判断anObject的长度和自身的长度是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 接着一个一个字符比较</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>总结一下，上面的大概流程。</p>\n<ul>\n<li>判断比较参数的地址是否相等，如果相等，直接返回true。</li>\n<li>判断anObject的长度和自身的长度是否相等，如果相等，循环遍历两个char[], 一个个比较char字符是否相等。<br>使用例子：<code>&quot;abc&quot;.equals(&quot;abc&quot;)</code></li>\n</ul>\n<h2 id=\"hashcode-方法\"><a href=\"#hashcode-方法\" class=\"headerlink\" title=\"hashcode 方法\"></a>hashcode 方法</h2><p>通过hashcode方法会返回一个int类型的数值。<br>实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// val[i] 是获取 ASCII 码 比如 a -&gt;97 , b -&gt;98</span></span><br><span class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hashcode方法比较简单，首先获取value的长度，然后根据长度遍历，反复计算h的值。比如：<code>&quot;abc&quot;.hashCode()</code>的返回值为：96354，<br>h默认为0。字符对应的ASCII码，可以自行Google。<br>第一次遍历： h = 31 <em> 0 + 97 ，所以 h = 97<br>第二次遍历： h = 31 </em> 97 + 98, h = 3105<br>第三次遍历： h = 31 * 3105 + 99, h = 96,354<br>还是比较容易理解的。</p>\n<h2 id=\"indexOf-方法\"><a href=\"#indexOf-方法\" class=\"headerlink\" title=\"indexOf 方法\"></a>indexOf 方法</h2><p><code>indexOf</code>可以接收<code>int</code>、<code>String</code>、<code>char</code>类型的参数, 该方法的作用是判断字符串是否包含传入参数。下面只介绍String的使用。<br><code>indexOf(Strinf str)</code> 方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(str, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(String str, <span class=\"keyword\">int</span> fromIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> indexOf(value, <span class=\"number\">0</span>, value.length,</span><br><span class=\"line\">            str.value, <span class=\"number\">0</span>, str.value.length, fromIndex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 主要实现逻辑在这里。</span></span><br><span class=\"line\"><span class=\"comment\">// source: 字符串本身 、 sourceOffset：字符串从什么位置比较,、 target: 待比较的字符串、 targetOffset: 待比较的字符串比较起始位置、 fromIndex： 从什么位置开始，默认为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(<span class=\"keyword\">char</span>[] source, <span class=\"keyword\">int</span> sourceOffset, <span class=\"keyword\">int</span> sourceCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">char</span>[] target, <span class=\"keyword\">int</span> targetOffset, <span class=\"keyword\">int</span> targetCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> fromIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始比较的位置大于等于了本身字符串的长度</span></span><br><span class=\"line\">        <span class=\"comment\">// 待比较值为空，直接返回本身字符串长度，反之返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (targetCount == <span class=\"number\">0</span> ? sourceCount : -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止设置参数错误</span></span><br><span class=\"line\">        fromIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相当于传递了一个空字符串， 直接返回 fromIndex</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fromIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取第一个待比较值的value , 比如 ”abc“, first = 'a'</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> first = target[targetOffset];</span><br><span class=\"line\">    <span class=\"comment\">// 计算循环结束的位置 比如： \"abc\".indexOf(\"b\") max为 0+(3-1) = 2;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Look for first character. */</span></span><br><span class=\"line\">        <span class=\"comment\">// 找出第一个值与本身值相等的位置 i</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source[i] != first) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Found first character, now look at the rest of v2 */</span></span><br><span class=\"line\">        <span class=\"comment\">// 前面主要是找出了第一个相等字符的位置，接着需要匹配后面的字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= max) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// j: 待比较第二个后面字符的开始位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// end：待比较字符的最后一个位置+1</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = j + targetCount - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 依次比较后面字符 是否相等</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = targetOffset + <span class=\"number\">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class=\"line\">                    == target[k]; j++, k++);</span><br><span class=\"line\">            <span class=\"comment\">// 如果j 不等于 end ，说明 target 的其中一个字符不在source中。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == end) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* Found whole string. */</span></span><br><span class=\"line\">                <span class=\"comment\">// 返回第一个字符相等的位置</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - sourceOffset;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>indexOf方法，相对而言长一点，但是整体来说，还是不难理解。相应的注释已经写得差不多了，这里大概总结一下。</p>\n<ul>\n<li>首先比较第一个字符，如果第一个字符都不等，直接返回-1，表示没有找到。</li>\n<li>接着比较后面的字符，如果依次全等。返回第一个字符相等的位置。</li>\n</ul>\n<h2 id=\"substring-方法\"><a href=\"#substring-方法\" class=\"headerlink\" title=\"substring 方法\"></a>substring 方法</h2><p><code>substring</code>的功能是截取字符串，使用方式是指定一个起始位置<code>beginIndex</code>和结束位置<code>endIndex</code>(endIndex 可以不指定，默认为字符串最后一位)，代码实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">substring</span><span class=\"params\">(<span class=\"keyword\">int</span> beginIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beginIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入参数不合格，抛出字符串索引越界异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 需要截取的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> subLen = value.length - beginIndex;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (subLen &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 小于0，说明传入beginIndex大于了字符串本身的长度，抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为String是不可变的，所以返回一个新的字符串, new String()的具体实现，在构造方法里面已经说过了。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (beginIndex == <span class=\"number\">0</span>) ? <span class=\"keyword\">this</span> : <span class=\"keyword\">new</span> String(value, beginIndex, subLen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"replace-方法\"><a href=\"#replace-方法\" class=\"headerlink\" title=\"replace 方法\"></a>replace 方法</h2><p><code>replace()</code>方法的功能是替换字符串，比如 <code>&quot;hello world !&quot;.replace(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world-!</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// target：被替换的字符，replacement：替换的字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replace</span><span class=\"params\">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class=\"line\">            <span class=\"keyword\">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>replaceFirst()</code>方法功能是替换第一个匹配的字符串，比如 <code>&quot;hello world !&quot;.replaceFrist(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world !</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceFirst</span><span class=\"params\">(String regex, String replacement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(regex).matcher(<span class=\"keyword\">this</span>).replaceFirst(replacement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>replaceAll()</code>方法功能是替换第一个匹配的字符串，比如 <code>&quot;hello world !&quot;.replaceAll(&quot; &quot;, &quot;-&quot;)</code> 变成了 <code>hello-world-!</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceAll</span><span class=\"params\">(String regex, String replacement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Pattern.compile(regex).matcher(<span class=\"keyword\">this</span>).replaceAll(replacement);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这三个方法主要区别是 <code>replaceFirst()</code>调用了<code>Matcher#replaceFirst</code>， <code>replace()</code>和<code>replaceAll()</code>调用了<code>Matcher#replaceAll</code>方法。<br>Matcher的<code>replaceAll()</code>和<code>replaceFirst()</code>方法区别在对于<code>appendReplacement(sb, replacement);</code>的调用次数，<code>replaceFirst()</code>只调用一次，表示只替换第一个匹配的值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceAll</span><span class=\"params\">(String replacement)</span> </span>&#123;</span><br><span class=\"line\">    reset();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = find();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">        StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实现太复杂，不讨论了。</span></span><br><span class=\"line\">            appendReplacement(sb, replacement);</span><br><span class=\"line\">            result = find();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (result);</span><br><span class=\"line\">        appendTail(sb);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"join-方法\"><a href=\"#join-方法\" class=\"headerlink\" title=\"join 方法\"></a>join 方法</h2><p><code>join()</code>是1.8之后才有的新方法。功能是：将多个字符或者集合元素连接起来。例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String message = String.join(<span class=\"string\">\"-\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"cool\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// message returned is: \"Java-is-cool\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; strings = List.of(<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"cool\"</span>);</span><br><span class=\"line\">String message = String.join(<span class=\"string\">\" \"</span>, strings);</span><br><span class=\"line\"><span class=\"comment\">//message returned is: \"Java is cool\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Set&lt;String&gt; strings =</span><br><span class=\"line\"> <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;(List.of(<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"is\"</span>, <span class=\"string\">\"very\"</span>, <span class=\"string\">\"cool\"</span>));</span><br><span class=\"line\">String message = String.join(<span class=\"string\">\"-\"</span>, strings);</span><br><span class=\"line\"><span class=\"comment\">//message returned is: \"Java-is-very-cool\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的例子表明了<code>String#join</code>方法可以接收 可变数组格式的字符、List、Set格式参数。下面来看看join的实现。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">join</span><span class=\"params\">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 非空验证</span></span><br><span class=\"line\">    Objects.requireNonNull(delimiter);</span><br><span class=\"line\">    Objects.requireNonNull(elements);</span><br><span class=\"line\">    <span class=\"comment\">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class=\"line\">    StringJoiner joiner = <span class=\"keyword\">new</span> StringJoiner(delimiter);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (CharSequence cs: elements) &#123;</span><br><span class=\"line\">        joiner.add(cs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> joiner.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法我们会看见有一个新的class出现了，<code>StringJoiner</code>也是1.8之后的才有的。主要参数有：<code>delimiter</code>：分隔符，<code>value</code>：定义类型是<code>StringBuilder</code>，由此可以看出来具体拼接还是通过<code>StringBuilder</code>实现的，另外还有<code>prefix</code>、<code>suffix</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringJoiner <span class=\"title\">add</span><span class=\"params\">(CharSequence newElement)</span> </span>&#123;</span><br><span class=\"line\">    prepareBuilder().append(newElement);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 主要实现在prepareBuilder()这里</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> StringBuilder <span class=\"title\">prepareBuilder</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加 连接字符</span></span><br><span class=\"line\">        value.append(delimiter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新建一个StringBulider, 如果有前缀也加上。</span></span><br><span class=\"line\">        value = <span class=\"keyword\">new</span> StringBuilder().append(prefix);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>prepareBuilder()</code>执行完之后，才会去添加新的元素。</p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>到了这里也差不多了， <code>String</code>中还有很多方法，就不去一一解析了，当然我们需要知道怎么使用，具体功能是什么，下面做个功能总结：</p>\n<ul>\n<li><code>trim</code> 去掉首尾的空格</li>\n<li><code>toLowerCase</code> 将字符串大写字母转为小写</li>\n<li><code>toUpperCase</code> 将字符串小写字母转为大写</li>\n<li><code>split</code> 根据特定字符拆分成一个数组</li>\n<li><code>toString</code> 这个方法使用频率很高，需要注意它和<code>String#valueOf</code>的区别。如果<code>null</code>调用了<code>toString</code>会抛出<code>NullException</code>，而<code>null</code>调用了<code>valueOf</code>,会返回<code>&quot;null&quot;</code>字符。</li>\n</ul>\n"},{"title":"JDK8源码学习:HashMap","abbrlink":"2da9164","date":"2018-09-02T16:00:00.000Z","_content":"# 概述\nHashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量-->构造方法-->常用方法。\n在JDK7中，HashMap的底层数据结构为：数组+链表的形式。\n在JDK8中，HashMap的底层数据结构为：数组+链表+红黑树（TreeNode），增加红黑树的结构。\n# 变量\n- loadFactor 加载因子\n默认加载因子为`0.75f`,为何是`0.75` 而不是其他的值呢？\n首先理解一下，什么是加载因子。\n加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然\n冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。\n结合前面两条，我们必须在 \"冲突的机会\"与\"空间利用率\"之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的\"时间复杂度-空间复杂度\"矛盾的平衡与折衷。\n加载因子的值是可以大于1的。\n- threshold\nthreshold表示当HashMap的size大于threshold时会执行resize操作。\n- size\n记录数组的长度\n- modCount\nmodCount是记录HashMap发送结构性变化的次数，比如扩容、rehash。\n\n另外大概了解一下HashMap的最大容量 `1<<30`也就是2的30次方，初始化容量为16。\n\n# 构造方法\n- HashMap(int, float)\n为了方便阅读，注释直接写在了代码里面。\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n\tif (initialCapacity < 0)\n\t\tthrow new IllegalArgumentException(\"Illegal initial capacity: \" +\n\t\t\t\t\t\t\t\t\t\t   initialCapacity);\n\t// 初始化容量必须在 1<<30 以内\n\tif (initialCapacity > MAXIMUM_CAPACITY)\n\t\tinitialCapacity = MAXIMUM_CAPACITY;\n\tif (loadFactor <= 0 || Float.isNaN(loadFactor))\n\t\tthrow new IllegalArgumentException(\"Illegal load factor: \" +\n\t\t\t\t\t\t\t\t\t\t   loadFactor);\n\tthis.loadFactor = loadFactor;\n\t\t// 调用了tableSizeFor方法，该方法是返回给定的`initialCapacity`值的向上取最近的2的幂。比如传递的值为12，返回16。\n\tthis.threshold = tableSizeFor(initialCapacity);\n}\n```\n- HashMap(int)\n```java\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n该构造方法，只是指定了初始化容量，使用默认的加载因子，调用`HashMap(int, float)`方法。\n```\n# 常用方法\n## put 插入\nput方法主要的实现过程如下，为了方便阅读，将注释写在了代码中。\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n\tNode<K,V>[] tab; Node<K,V> p; int n, i;\n\tif ((tab = table) == null || (n = tab.length) == 0)\n\t\t// 如果table为空，调用resize()方法，初始化一个table。\n\t\tn = (tab = resize()).length;\n\tif ((p = tab[i = (n - 1) & hash]) == null)\n\t\t// 该节点不存在，新建节点\n\t\ttab[i] = newNode(hash, key, value, null);\n\telse {\n\t\tNode<K,V> e; K k;\n\t\tif (p.hash == hash &&\n\t\t\t((k = p.key) == key || (key != null && key.equals(k))))\n\t\t\te = p;\n\t\telse if (p instanceof TreeNode) // 如果是p节点是红黑树节点，调用红黑树的put方法。\n\t\t\te = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n\t\telse {\n\t\t\tfor (int binCount = 0; ; ++binCount) {\n\t\t\t\tif ((e = p.next) == null) { // 找到链表的最后一个节点，插入新的节点\n\t\t\t\t\tp.next = newNode(hash, key, value, null);\n\t\t\t\t\t// 如果binCount的大小大于等于TREEIFY_THRESHOLD-1（TREEIFY_THRESHOLD默认为8），调用treeifyBin方法，后面单独介绍该方法。\n\t\t\t\t\tif (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n\t\t\t\t\t\ttreeifyBin(tab, hash);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 链表中存在该节点，跳出循环。\n\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\tbreak;\n\t\t\t\tp = e;\n\t\t\t}\n\t\t}\n\t\tif (e != null) { // existing mapping for key\n\t\t\tV oldValue = e.value;\n\t\t\t// 根据oblyIfAbsent是否更新值\n\t\t\tif (!onlyIfAbsent || oldValue == null)\n\t\t\t\te.value = value;\n\t\t\tafterNodeAccess(e);\n\t\t\treturn oldValue;\n\t\t}\n\t}\n\t// 修改 modCount\n\t++modCount;\n\t// 如果table大小大于了阈值，则需要扩容。\n\tif (++size > threshold)\n\t\tresize();\n\tafterNodeInsertion(evict);\n\treturn null;\n}\n```\n上面已经介绍了put方法的主流程，接下来分析一下该方法中留下的几个问题。\n- treeifyBin方法\n\n```java\n    final void treeifyBin(Node<K,V>[] tab, int hash) {\n        int n, index; Node<K,V> e;\n\t\t\t// 判断是否需要扩容，MIN_TREEIFY_CAPACITY的值：64,也就是说在大小为16、 32 的时候，不要进行结构转换\n        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n            resize();\n        else if ((e = tab[index = (n - 1) & hash]) != null) {\n            TreeNode<K,V> hd = null, tl = null;\n            do {\n\t\t\t\t// 将节点转为树节点\n                TreeNode<K,V> p = replacementTreeNode(e, null);\n                if (tl == null)\n                    hd = p; // 将p树节点指向hd树节点\n                else {\n                    p.prev = tl; // 当前p树节点指向 p树节点的前一树节点\n                    tl.next = p;\n                }\n                tl = p;\n            } while ((e = e.next) != null);\n            if ((tab[index] = hd) != null)\n                hd.treeify(tab);\n        }\n    }\n```\ntreeifyBin方法主要是把容器里的元素变成树结构。当HashMap的内部元素数组中某个位置上存在多个hash值相同的键值对，这些Node已经形成了一个链表，当该链表的长度大于等于7的时候，会调用该方法来进行一个特殊处理。\n\n## get 取值\n源码中get方法代码如下，为了方便阅读，在代码中会写上相应的注释。\n\n```java\npublic V get(Object key) {\n\tNode<K,V> e;\n\treturn (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n这段代码比较简单，调用了getNode()方法，并传入`hash(key)`和`key`，所以说取值的过程在`getNode`中，下面看看该方法的具体实现：\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n\t// 定义一个新的table数组、首节点\n\tNode<K,V>[] tab; Node<K,V> first, e; int n; K k;\n\t// 判断table数组是否为空，并且根据hash值算出 tab[(n - 1) & hash]是否为空，其中一个条件为空，说明key没有对应的value值。\n\tif ((tab = table) != null && (n = tab.length) > 0 &&\n\t\t(first = tab[(n - 1) & hash]) != null) {\n\t\t// 判断首节点的hash和key是否都相等，如果都等，直接返回首节点\n\t\tif (first.hash == hash && // always check first node\n\t\t\t((k = first.key) == key || (key != null && key.equals(k))))\n\t\t\treturn first;\n\t\t// 走到这儿，说明是一个链表了或者红黑树了\n\t\tif ((e = first.next) != null) {\n\t\t\t// 判断是否为红黑树\n\t\t\tif (first instanceof TreeNode)\n\t\t\t\t// 调用 红黑树的getTreeNode方法\n\t\t\t\treturn ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\t\t\t// 遍历链表一直找到匹配的值为止\n\t\t\tdo {\n\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\treturn e;\n\t\t\t} while ((e = e.next) != null);\n\t\t}\n\t}\n\treturn null;\n}\n```\n`getNode`方法的过程相对而言是比较简单的，上面注释基本上比较易懂的，在整个流程中，红黑树的取值方法，没有说到，接下来看看`getTreeNode`方法中主要流程。\n```java\nfinal TreeNode<K,V> getTreeNode(int h, Object k) {\n\treturn ((parent != null) ? root() : this).find(h, k, null);\n}\n```\n`getTreeNode`方法的实现过程如下：\n```java\nfinal TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n\tTreeNode<K,V> p = this;\n\tdo {\n\t\t// ph: p节点的hash值，pk:p节点的key值\n\t\tint ph, dir; K pk;\n\t\t// pl: p节点的左节点， pr：p节点的右节点\n\t\tTreeNode<K,V> pl = p.left, pr = p.right, q;\n\t\tif ((ph = p.hash) > h)\n\t\t\t// p节点的hash值大于了 h（h是待get值的hash值），将左节点赋值给p节点\n\t\t\tp = pl;\n\t\telse if (ph < h)\n\t\t\t// p节点的hash值小于了 h（h是待get值的hash值），将右节点赋值给p节点\n\t\t\tp = pr;\n\t\telse if ((pk = p.key) == k || (k != null && k.equals(pk)))\n\t\t\t// 走到了这儿，说明p.hash==h,只需要匹配key是否相等就好了。\n\t\t\treturn p;\n\t\telse if (pl == null)\n\t\t\t// 左节点为空，将右节点赋值给p节点\n\t\t\tp = pr;\n\t\telse if (pr == null)\n\t\t\t// 右节点为空，将左节点赋值给p节点\n\t\t\tp = pl;\n\t\t// kc参数在首次使用比较键时缓存equivalentClassFor（key）。\n\t\t// comparableClassFor方法：只有当传入对象的运行时类型符合“class C implements Cormparable <C>”，则返回k的Class，否则返回null。\n\t\t// compareComparables方法: 如果pk匹配kc（k的筛选可比类），则返回k.compareTo（pk），否则返回0。\n\t\telse if ((kc != null ||\n\t\t\t\t  (kc = comparableClassFor(k)) != null) &&\n\t\t\t\t (dir = compareComparables(kc, k, pk)) != 0)\n\t\t\tp = (dir < 0) ? pl : pr;\n\t\telse if ((q = pr.find(h, k, kc)) != null)\n\t\t\treturn q;\n\t\telse\n\t\t\tp = pl;\n\t} while (p != null);\n\treturn null;\n}\n```\n在本文中，主要是对常用的方法get、put做了一个学习了解。","source":"_posts/jdk8-source-hashmap.md","raw":"---\ntitle: 'JDK8源码学习:HashMap'\ncategory: Java\ntags:\n  - java\n  - 源码\nabbrlink: 2da9164\ndate: 2018-09-03 00:00:00\n---\n# 概述\nHashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量-->构造方法-->常用方法。\n在JDK7中，HashMap的底层数据结构为：数组+链表的形式。\n在JDK8中，HashMap的底层数据结构为：数组+链表+红黑树（TreeNode），增加红黑树的结构。\n# 变量\n- loadFactor 加载因子\n默认加载因子为`0.75f`,为何是`0.75` 而不是其他的值呢？\n首先理解一下，什么是加载因子。\n加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然\n冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。\n结合前面两条，我们必须在 \"冲突的机会\"与\"空间利用率\"之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的\"时间复杂度-空间复杂度\"矛盾的平衡与折衷。\n加载因子的值是可以大于1的。\n- threshold\nthreshold表示当HashMap的size大于threshold时会执行resize操作。\n- size\n记录数组的长度\n- modCount\nmodCount是记录HashMap发送结构性变化的次数，比如扩容、rehash。\n\n另外大概了解一下HashMap的最大容量 `1<<30`也就是2的30次方，初始化容量为16。\n\n# 构造方法\n- HashMap(int, float)\n为了方便阅读，注释直接写在了代码里面。\n```java\npublic HashMap(int initialCapacity, float loadFactor) {\n\tif (initialCapacity < 0)\n\t\tthrow new IllegalArgumentException(\"Illegal initial capacity: \" +\n\t\t\t\t\t\t\t\t\t\t   initialCapacity);\n\t// 初始化容量必须在 1<<30 以内\n\tif (initialCapacity > MAXIMUM_CAPACITY)\n\t\tinitialCapacity = MAXIMUM_CAPACITY;\n\tif (loadFactor <= 0 || Float.isNaN(loadFactor))\n\t\tthrow new IllegalArgumentException(\"Illegal load factor: \" +\n\t\t\t\t\t\t\t\t\t\t   loadFactor);\n\tthis.loadFactor = loadFactor;\n\t\t// 调用了tableSizeFor方法，该方法是返回给定的`initialCapacity`值的向上取最近的2的幂。比如传递的值为12，返回16。\n\tthis.threshold = tableSizeFor(initialCapacity);\n}\n```\n- HashMap(int)\n```java\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n该构造方法，只是指定了初始化容量，使用默认的加载因子，调用`HashMap(int, float)`方法。\n```\n# 常用方法\n## put 插入\nput方法主要的实现过程如下，为了方便阅读，将注释写在了代码中。\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n\tNode<K,V>[] tab; Node<K,V> p; int n, i;\n\tif ((tab = table) == null || (n = tab.length) == 0)\n\t\t// 如果table为空，调用resize()方法，初始化一个table。\n\t\tn = (tab = resize()).length;\n\tif ((p = tab[i = (n - 1) & hash]) == null)\n\t\t// 该节点不存在，新建节点\n\t\ttab[i] = newNode(hash, key, value, null);\n\telse {\n\t\tNode<K,V> e; K k;\n\t\tif (p.hash == hash &&\n\t\t\t((k = p.key) == key || (key != null && key.equals(k))))\n\t\t\te = p;\n\t\telse if (p instanceof TreeNode) // 如果是p节点是红黑树节点，调用红黑树的put方法。\n\t\t\te = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n\t\telse {\n\t\t\tfor (int binCount = 0; ; ++binCount) {\n\t\t\t\tif ((e = p.next) == null) { // 找到链表的最后一个节点，插入新的节点\n\t\t\t\t\tp.next = newNode(hash, key, value, null);\n\t\t\t\t\t// 如果binCount的大小大于等于TREEIFY_THRESHOLD-1（TREEIFY_THRESHOLD默认为8），调用treeifyBin方法，后面单独介绍该方法。\n\t\t\t\t\tif (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n\t\t\t\t\t\ttreeifyBin(tab, hash);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 链表中存在该节点，跳出循环。\n\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\tbreak;\n\t\t\t\tp = e;\n\t\t\t}\n\t\t}\n\t\tif (e != null) { // existing mapping for key\n\t\t\tV oldValue = e.value;\n\t\t\t// 根据oblyIfAbsent是否更新值\n\t\t\tif (!onlyIfAbsent || oldValue == null)\n\t\t\t\te.value = value;\n\t\t\tafterNodeAccess(e);\n\t\t\treturn oldValue;\n\t\t}\n\t}\n\t// 修改 modCount\n\t++modCount;\n\t// 如果table大小大于了阈值，则需要扩容。\n\tif (++size > threshold)\n\t\tresize();\n\tafterNodeInsertion(evict);\n\treturn null;\n}\n```\n上面已经介绍了put方法的主流程，接下来分析一下该方法中留下的几个问题。\n- treeifyBin方法\n\n```java\n    final void treeifyBin(Node<K,V>[] tab, int hash) {\n        int n, index; Node<K,V> e;\n\t\t\t// 判断是否需要扩容，MIN_TREEIFY_CAPACITY的值：64,也就是说在大小为16、 32 的时候，不要进行结构转换\n        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n            resize();\n        else if ((e = tab[index = (n - 1) & hash]) != null) {\n            TreeNode<K,V> hd = null, tl = null;\n            do {\n\t\t\t\t// 将节点转为树节点\n                TreeNode<K,V> p = replacementTreeNode(e, null);\n                if (tl == null)\n                    hd = p; // 将p树节点指向hd树节点\n                else {\n                    p.prev = tl; // 当前p树节点指向 p树节点的前一树节点\n                    tl.next = p;\n                }\n                tl = p;\n            } while ((e = e.next) != null);\n            if ((tab[index] = hd) != null)\n                hd.treeify(tab);\n        }\n    }\n```\ntreeifyBin方法主要是把容器里的元素变成树结构。当HashMap的内部元素数组中某个位置上存在多个hash值相同的键值对，这些Node已经形成了一个链表，当该链表的长度大于等于7的时候，会调用该方法来进行一个特殊处理。\n\n## get 取值\n源码中get方法代码如下，为了方便阅读，在代码中会写上相应的注释。\n\n```java\npublic V get(Object key) {\n\tNode<K,V> e;\n\treturn (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n这段代码比较简单，调用了getNode()方法，并传入`hash(key)`和`key`，所以说取值的过程在`getNode`中，下面看看该方法的具体实现：\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n\t// 定义一个新的table数组、首节点\n\tNode<K,V>[] tab; Node<K,V> first, e; int n; K k;\n\t// 判断table数组是否为空，并且根据hash值算出 tab[(n - 1) & hash]是否为空，其中一个条件为空，说明key没有对应的value值。\n\tif ((tab = table) != null && (n = tab.length) > 0 &&\n\t\t(first = tab[(n - 1) & hash]) != null) {\n\t\t// 判断首节点的hash和key是否都相等，如果都等，直接返回首节点\n\t\tif (first.hash == hash && // always check first node\n\t\t\t((k = first.key) == key || (key != null && key.equals(k))))\n\t\t\treturn first;\n\t\t// 走到这儿，说明是一个链表了或者红黑树了\n\t\tif ((e = first.next) != null) {\n\t\t\t// 判断是否为红黑树\n\t\t\tif (first instanceof TreeNode)\n\t\t\t\t// 调用 红黑树的getTreeNode方法\n\t\t\t\treturn ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\t\t\t// 遍历链表一直找到匹配的值为止\n\t\t\tdo {\n\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\treturn e;\n\t\t\t} while ((e = e.next) != null);\n\t\t}\n\t}\n\treturn null;\n}\n```\n`getNode`方法的过程相对而言是比较简单的，上面注释基本上比较易懂的，在整个流程中，红黑树的取值方法，没有说到，接下来看看`getTreeNode`方法中主要流程。\n```java\nfinal TreeNode<K,V> getTreeNode(int h, Object k) {\n\treturn ((parent != null) ? root() : this).find(h, k, null);\n}\n```\n`getTreeNode`方法的实现过程如下：\n```java\nfinal TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n\tTreeNode<K,V> p = this;\n\tdo {\n\t\t// ph: p节点的hash值，pk:p节点的key值\n\t\tint ph, dir; K pk;\n\t\t// pl: p节点的左节点， pr：p节点的右节点\n\t\tTreeNode<K,V> pl = p.left, pr = p.right, q;\n\t\tif ((ph = p.hash) > h)\n\t\t\t// p节点的hash值大于了 h（h是待get值的hash值），将左节点赋值给p节点\n\t\t\tp = pl;\n\t\telse if (ph < h)\n\t\t\t// p节点的hash值小于了 h（h是待get值的hash值），将右节点赋值给p节点\n\t\t\tp = pr;\n\t\telse if ((pk = p.key) == k || (k != null && k.equals(pk)))\n\t\t\t// 走到了这儿，说明p.hash==h,只需要匹配key是否相等就好了。\n\t\t\treturn p;\n\t\telse if (pl == null)\n\t\t\t// 左节点为空，将右节点赋值给p节点\n\t\t\tp = pr;\n\t\telse if (pr == null)\n\t\t\t// 右节点为空，将左节点赋值给p节点\n\t\t\tp = pl;\n\t\t// kc参数在首次使用比较键时缓存equivalentClassFor（key）。\n\t\t// comparableClassFor方法：只有当传入对象的运行时类型符合“class C implements Cormparable <C>”，则返回k的Class，否则返回null。\n\t\t// compareComparables方法: 如果pk匹配kc（k的筛选可比类），则返回k.compareTo（pk），否则返回0。\n\t\telse if ((kc != null ||\n\t\t\t\t  (kc = comparableClassFor(k)) != null) &&\n\t\t\t\t (dir = compareComparables(kc, k, pk)) != 0)\n\t\t\tp = (dir < 0) ? pl : pr;\n\t\telse if ((q = pr.find(h, k, kc)) != null)\n\t\t\treturn q;\n\t\telse\n\t\t\tp = pl;\n\t} while (p != null);\n\treturn null;\n}\n```\n在本文中，主要是对常用的方法get、put做了一个学习了解。","slug":"jdk8-source-hashmap","published":1,"updated":"2020-03-30T11:07:21.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpj4003pi3slwyfm9k6u","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>HashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量–&gt;构造方法–&gt;常用方法。<br>在JDK7中，HashMap的底层数据结构为：数组+链表的形式。<br>在JDK8中，HashMap的底层数据结构为：数组+链表+红黑树（TreeNode），增加红黑树的结构。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><ul>\n<li>loadFactor 加载因子<br>默认加载因子为<code>0.75f</code>,为何是<code>0.75</code> 而不是其他的值呢？<br>首先理解一下，什么是加载因子。<br>加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然<br>冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。<br>结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。<br>加载因子的值是可以大于1的。</li>\n<li>threshold<br>threshold表示当HashMap的size大于threshold时会执行resize操作。</li>\n<li>size<br>记录数组的长度</li>\n<li>modCount<br>modCount是记录HashMap发送结构性变化的次数，比如扩容、rehash。</li>\n</ul>\n<p>另外大概了解一下HashMap的最大容量 <code>1&lt;&lt;30</code>也就是2的30次方，初始化容量为16。</p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><ul>\n<li><p>HashMap(int, float)<br>为了方便阅读，注释直接写在了代码里面。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   initialCapacity);</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化容量必须在 1&lt;&lt;30 以内</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">\t\tinitialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   loadFactor);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用了tableSizeFor方法，该方法是返回给定的`initialCapacity`值的向上取最近的2的幂。比如传递的值为12，返回16。</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap(int)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">该构造方法，只是指定了初始化容量，使用默认的加载因子，调用`HashMap(<span class=\"keyword\">int</span>, <span class=\"keyword\">float</span>)`方法。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"put-插入\"><a href=\"#put-插入\" class=\"headerlink\" title=\"put 插入\"></a>put 插入</h2><p>put方法主要的实现过程如下，为了方便阅读，将注释写在了代码中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果table为空，调用resize()方法，初始化一个table。</span></span><br><span class=\"line\">\t\tn = (tab = resize()).length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 该节点不存在，新建节点</span></span><br><span class=\"line\">\t\ttab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; e; K k;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\te = p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 如果是p节点是红黑树节点，调用红黑树的put方法。</span></span><br><span class=\"line\">\t\t\te = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 找到链表的最后一个节点，插入新的节点</span></span><br><span class=\"line\">\t\t\t\t\tp.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果binCount的大小大于等于TREEIFY_THRESHOLD-1（TREEIFY_THRESHOLD默认为8），调用treeifyBin方法，后面单独介绍该方法。</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">\t\t\t\t\t\ttreeifyBin(tab, hash);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 链表中存在该节点，跳出循环。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\tp = e;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">\t\t\tV oldValue = e.value;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据oblyIfAbsent是否更新值</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\te.value = value;</span><br><span class=\"line\">\t\t\tafterNodeAccess(e);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 修改 modCount</span></span><br><span class=\"line\">\t++modCount;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果table大小大于了阈值，则需要扩容。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">\t\tresize();</span><br><span class=\"line\">\tafterNodeInsertion(evict);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面已经介绍了put方法的主流程，接下来分析一下该方法中留下的几个问题。</p>\n<ul>\n<li>treeifyBin方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\"><span class=\"comment\">// 判断是否需要扩容，MIN_TREEIFY_CAPACITY的值：64,也就是说在大小为16、 32 的时候，不要进行结构转换</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">         resize();</span><br><span class=\"line\">     <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将节点转为树节点</span></span><br><span class=\"line\">             TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                 hd = p; <span class=\"comment\">// 将p树节点指向hd树节点</span></span><br><span class=\"line\">             <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 p.prev = tl; <span class=\"comment\">// 当前p树节点指向 p树节点的前一树节点</span></span><br><span class=\"line\">                 tl.next = p;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             tl = p;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">             hd.treeify(tab);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>treeifyBin方法主要是把容器里的元素变成树结构。当HashMap的内部元素数组中某个位置上存在多个hash值相同的键值对，这些Node已经形成了一个链表，当该链表的长度大于等于7的时候，会调用该方法来进行一个特殊处理。</p>\n<h2 id=\"get-取值\"><a href=\"#get-取值\" class=\"headerlink\" title=\"get 取值\"></a>get 取值</h2><p>源码中get方法代码如下，为了方便阅读，在代码中会写上相应的注释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码比较简单，调用了getNode()方法，并传入<code>hash(key)</code>和<code>key</code>，所以说取值的过程在<code>getNode</code>中，下面看看该方法的具体实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义一个新的table数组、首节点</span></span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断table数组是否为空，并且根据hash值算出 tab[(n - 1) &amp; hash]是否为空，其中一个条件为空，说明key没有对应的value值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t(first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断首节点的hash和key是否都相等，如果都等，直接返回首节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">\t\t\t((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 走到这儿，说明是一个链表了或者红黑树了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 判断是否为红黑树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 调用 红黑树的getTreeNode方法</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历链表一直找到匹配的值为止</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> e;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>getNode</code>方法的过程相对而言是比较简单的，上面注释基本上比较易懂的，在整个流程中，红黑树的取值方法，没有说到，接下来看看<code>getTreeNode</code>方法中主要流程。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">getTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>).find(h, k, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>getTreeNode</code>方法的实现过程如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; p = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ph: p节点的hash值，pk:p节点的key值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ph, dir; K pk;</span><br><span class=\"line\">\t\t<span class=\"comment\">// pl: p节点的左节点， pr：p节点的右节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// p节点的hash值大于了 h（h是待get值的hash值），将左节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// p节点的hash值小于了 h（h是待get值的hash值），将右节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 走到了这儿，说明p.hash==h,只需要匹配key是否相等就好了。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 左节点为空，将右节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 右节点为空，将左节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pl;</span><br><span class=\"line\">\t\t<span class=\"comment\">// kc参数在首次使用比较键时缓存equivalentClassFor（key）。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// comparableClassFor方法：只有当传入对象的运行时类型符合“class C implements Cormparable &lt;C&gt;”，则返回k的Class，否则返回null。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// compareComparables方法: 如果pk匹配kc（k的筛选可比类），则返回k.compareTo（pk），否则返回0。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">\t\t\t\t  (kc = comparableClassFor(k)) != <span class=\"keyword\">null</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t (dir = compareComparables(kc, k, pk)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tp = (dir &lt; <span class=\"number\">0</span>) ? pl : pr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((q = pr.find(h, k, kc)) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> q;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tp = pl;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在本文中，主要是对常用的方法get、put做了一个学习了解。</p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>HashMap是Java的一个集合类，是我们在开发中经常使用的。本文记录个人阅读源码的一些步骤和理解。阅读步骤大致为：变量–&gt;构造方法–&gt;常用方法。<br>在JDK7中，HashMap的底层数据结构为：数组+链表的形式。<br>在JDK8中，HashMap的底层数据结构为：数组+链表+红黑树（TreeNode），增加红黑树的结构。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><ul>\n<li>loadFactor 加载因子<br>默认加载因子为<code>0.75f</code>,为何是<code>0.75</code> 而不是其他的值呢？<br>首先理解一下，什么是加载因子。<br>加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然<br>冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。<br>结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。<br>加载因子的值是可以大于1的。</li>\n<li>threshold<br>threshold表示当HashMap的size大于threshold时会执行resize操作。</li>\n<li>size<br>记录数组的长度</li>\n<li>modCount<br>modCount是记录HashMap发送结构性变化的次数，比如扩容、rehash。</li>\n</ul>\n<p>另外大概了解一下HashMap的最大容量 <code>1&lt;&lt;30</code>也就是2的30次方，初始化容量为16。</p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><ul>\n<li><p>HashMap(int, float)<br>为了方便阅读，注释直接写在了代码里面。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   initialCapacity);</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化容量必须在 1&lt;&lt;30 以内</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">\t\tinitialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t   loadFactor);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 调用了tableSizeFor方法，该方法是返回给定的`initialCapacity`值的向上取最近的2的幂。比如传递的值为12，返回16。</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap(int)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">该构造方法，只是指定了初始化容量，使用默认的加载因子，调用`HashMap(<span class=\"keyword\">int</span>, <span class=\"keyword\">float</span>)`方法。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"put-插入\"><a href=\"#put-插入\" class=\"headerlink\" title=\"put 插入\"></a>put 插入</h2><p>put方法主要的实现过程如下，为了方便阅读，将注释写在了代码中。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果table为空，调用resize()方法，初始化一个table。</span></span><br><span class=\"line\">\t\tn = (tab = resize()).length;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 该节点不存在，新建节点</span></span><br><span class=\"line\">\t\ttab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; e; K k;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\te = p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode) <span class=\"comment\">// 如果是p节点是红黑树节点，调用红黑树的put方法。</span></span><br><span class=\"line\">\t\t\te = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 找到链表的最后一个节点，插入新的节点</span></span><br><span class=\"line\">\t\t\t\t\tp.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果binCount的大小大于等于TREEIFY_THRESHOLD-1（TREEIFY_THRESHOLD默认为8），调用treeifyBin方法，后面单独介绍该方法。</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">\t\t\t\t\t\ttreeifyBin(tab, hash);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 链表中存在该节点，跳出循环。</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\tp = e;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">\t\t\tV oldValue = e.value;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据oblyIfAbsent是否更新值</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\te.value = value;</span><br><span class=\"line\">\t\t\tafterNodeAccess(e);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 修改 modCount</span></span><br><span class=\"line\">\t++modCount;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果table大小大于了阈值，则需要扩容。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">\t\tresize();</span><br><span class=\"line\">\tafterNodeInsertion(evict);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面已经介绍了put方法的主流程，接下来分析一下该方法中留下的几个问题。</p>\n<ul>\n<li>treeifyBin方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\"><span class=\"comment\">// 判断是否需要扩容，MIN_TREEIFY_CAPACITY的值：64,也就是说在大小为16、 32 的时候，不要进行结构转换</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">         resize();</span><br><span class=\"line\">     <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将节点转为树节点</span></span><br><span class=\"line\">             TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                 hd = p; <span class=\"comment\">// 将p树节点指向hd树节点</span></span><br><span class=\"line\">             <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 p.prev = tl; <span class=\"comment\">// 当前p树节点指向 p树节点的前一树节点</span></span><br><span class=\"line\">                 tl.next = p;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             tl = p;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">             hd.treeify(tab);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>treeifyBin方法主要是把容器里的元素变成树结构。当HashMap的内部元素数组中某个位置上存在多个hash值相同的键值对，这些Node已经形成了一个链表，当该链表的长度大于等于7的时候，会调用该方法来进行一个特殊处理。</p>\n<h2 id=\"get-取值\"><a href=\"#get-取值\" class=\"headerlink\" title=\"get 取值\"></a>get 取值</h2><p>源码中get方法代码如下，为了方便阅读，在代码中会写上相应的注释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码比较简单，调用了getNode()方法，并传入<code>hash(key)</code>和<code>key</code>，所以说取值的过程在<code>getNode</code>中，下面看看该方法的具体实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义一个新的table数组、首节点</span></span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断table数组是否为空，并且根据hash值算出 tab[(n - 1) &amp; hash]是否为空，其中一个条件为空，说明key没有对应的value值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t(first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断首节点的hash和key是否都相等，如果都等，直接返回首节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">\t\t\t((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 走到这儿，说明是一个链表了或者红黑树了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 判断是否为红黑树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 调用 红黑树的getTreeNode方法</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历链表一直找到匹配的值为止</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> e;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>getNode</code>方法的过程相对而言是比较简单的，上面注释基本上比较易懂的，在整个流程中，红黑树的取值方法，没有说到，接下来看看<code>getTreeNode</code>方法中主要流程。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">getTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>).find(h, k, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>getTreeNode</code>方法的实现过程如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; p = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ph: p节点的hash值，pk:p节点的key值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> ph, dir; K pk;</span><br><span class=\"line\">\t\t<span class=\"comment\">// pl: p节点的左节点， pr：p节点的右节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// p节点的hash值大于了 h（h是待get值的hash值），将左节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// p节点的hash值小于了 h（h是待get值的hash值），将右节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 走到了这儿，说明p.hash==h,只需要匹配key是否相等就好了。</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 左节点为空，将右节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 右节点为空，将左节点赋值给p节点</span></span><br><span class=\"line\">\t\t\tp = pl;</span><br><span class=\"line\">\t\t<span class=\"comment\">// kc参数在首次使用比较键时缓存equivalentClassFor（key）。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// comparableClassFor方法：只有当传入对象的运行时类型符合“class C implements Cormparable &lt;C&gt;”，则返回k的Class，否则返回null。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// compareComparables方法: 如果pk匹配kc（k的筛选可比类），则返回k.compareTo（pk），否则返回0。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">\t\t\t\t  (kc = comparableClassFor(k)) != <span class=\"keyword\">null</span>) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t (dir = compareComparables(kc, k, pk)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tp = (dir &lt; <span class=\"number\">0</span>) ? pl : pr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((q = pr.find(h, k, kc)) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> q;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tp = pl;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在本文中，主要是对常用的方法get、put做了一个学习了解。</p>\n"},{"title":"JDK8源码学习:TreeMap","abbrlink":"3a2cad14","date":"2018-09-06T16:00:00.000Z","_content":"# 概述\n本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。\n前面介绍了[HashMap](2da9164.html \"HashMap\")，因为HashMap是一种无序的存储集合，当某些时候需要特定的存储顺序的时候，就只能另寻他法了，在jdk中为我们提供了LinkedHashmap和TreeMap以供我们使用，本文先介绍TreeMap。\nTreeMap和HashMap一样都是继承至AbstractMap，并且实现了NavigableMap()，TreeMap是在NavigableMap基础上基于红黑树的实现，他是一种顺序的存储结构。\nTreeMap数据结构为Entry，Entry简单实现如下：\n```java\nstatic final class Entry<K,V> implements Map.Entry<K,V> {\n\tK key;\n\tV value;\n\tEntry<K,V> left; // 左节点\n\tEntry<K,V> right; // 右节点\n\tEntry<K,V> parent; // 父节点\n\tboolean color = BLACK;\n\t// ... 其他代码省略\n}\n```\n# 常用变量\n- root\nroot的定义为：`private transient Entry<K,V> root`，可以理解为一个短暂的 Entry\n- size\nsize的定义为：`private transient int size = 0`， 记录树中的数量\n- modCount\nmodCount的定义为：`private transient int modCount = 0`，记录结构性发生变化的次数，比如删除节点。\n- comparator\ncomparator的定义为：`private final Comparator<? super K> comparator`,用于维护此树形图中的顺序，如果使用其键的自然顺序，则comparator为空。\n\n# 构造方法\n## 无参\n- public TreeMap()\n代码如下：\n```java\npublic TreeMap() {\n\tcomparator = null;\n}\n```\n构造方法，没有指定comparator，所以使用它的自然顺序排序。\n\n## 有参\n- **public TreeMap(Comparator<? super K> comparator)**\n代码如下：\n```java\npublic TreeMap(Comparator<? super K> comparator) {\n\tthis.comparator = comparator;\n}\n```\n构造方法，使用给定的comparator规则排序\n\n- **public TreeMap(Map<? extends K, ? extends V> m)**\n代码如下：\n```java\npublic TreeMap(Map<? extends K, ? extends V> m) {\n\tcomparator = null;\n\tputAll(m);\n}\n```\n构造一个新的 tree map，其中包含给定map的相同的映射，根据key的自然顺序进行排序，插入的新map的所有key必须实现 Comparable接口\n\n- **public TreeMap(SortedMap<K, ? extends V> m)**\n实现代码如下：\n```java\npublic TreeMap(SortedMap<K, ? extends V> m) {\n\t// 将SoretdMap的排序方法赋给comparator\n\tcomparator = m.comparator();\n\ttry {\n\t\t// 构建 tree map\n\t\tbuildFromSorted(m.size(), m.entrySet().iterator(), null, null);\n\t} catch (java.io.IOException cannotHappen) {\n\t} catch (ClassNotFoundException cannotHappen) {\n\t}\n}\n```\n构造一个新的 tree map，其中包含给定map的相同的映射，并且使用给定的 sorted map 的排序方式进行排序\n\n# 常用方法\n## put() 插入\n插入方法是我们开发常用的方法，接下来看看，TreeMap的put方法具体是怎么实现的，为了方便阅读部分注释直接写在了代码中，代码如下：\n```java\npublic V put(K key, V value) {\n\tEntry<K,V> t = root;\n\tif (t == null) {\n\t\t// 比较两个key值，使用此时正确的compare方法。\n\t\tcompare(key, key); // type (and possibly null) check\n\t\t// new 一个 entry节点\n\t\troot = new Entry<>(key, value, null);\n\t\tsize = 1;\n\t\tmodCount++; // 增加结构变化的次数\n\t\treturn null;\n\t}\n\tint cmp;\n\tEntry<K,V> parent;\n\t// split comparator and comparable paths\n\tComparator<? super K> cpr = comparator;\n\tif (cpr != null) {\n\t\t// 设置value到特定的位置\n\t\tdo {\n\t\t\tparent = t;\n\t\t\tcmp = cpr.compare(key, t.key); // 比较 key 和 t.key\n\t\t\tif (cmp < 0)\n\t\t\t\tt = t.left;\n\t\t\telse if (cmp > 0)\n\t\t\t\tt = t.right;\n\t\t\telse\n\t\t\t\treturn t.setValue(value); // cmp=0，设置value\n\t\t} while (t != null);\n\t}\n\telse {\n\t\tif (key == null) // 不允许key为null\n\t\t\tthrow new NullPointerException();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tComparable<? super K> k = (Comparable<? super K>) key;\n\t\t// 设置value到特定的位置\n\t\tdo {\n\t\t\tparent = t;\n\t\t\tcmp = k.compareTo(t.key);\n\t\t\tif (cmp < 0)\n\t\t\t\tt = t.left;\n\t\t\telse if (cmp > 0)\n\t\t\t\tt = t.right;\n\t\t\telse\n\t\t\t\treturn t.setValue(value);\n\t\t} while (t != null);\n\t}\n\t// 走到了这里， 说明了，cmp != 0，没有找到对应的key值，新建一个entry e，并将e放在相应的parent左右节点下面\n\tEntry<K,V> e = new Entry<>(key, value, parent);\n\tif (cmp < 0)\n\t\tparent.left = e;\n\telse\n\t\tparent.right = e;\n\tfixAfterInsertion(e);\n\tsize++;\n\tmodCount++;\n\treturn null;\n}\n```\nput方法还是比较容易能理解的，首先判断root是否为空，如果没空，直接new Entry即可。不为空，根据comparator的值，查找要设置value的位置。如果没有找到匹配的key，则新建一个Entry e，再根据cmp的值，将Entry e设置到对应的位置即可。\n## get 获取值\n根据key获取一个Entry，具体实现如下：\n```java\nfinal Entry<K,V> getEntry(Object key) {\n\t// Offload comparator-based version for sake of performance\n\tif (comparator != null)\n\t\t// 如果默认comparator不为空，调用getEntryUsingComparator方法\n\t\treturn getEntryUsingComparator(key);\n\tif (key == null) // key不允许为null\n\t\tthrow new NullPointerException();\n\t// 走到了这里，说明comparator为空，使用默认排序方法。\n\t@SuppressWarnings(\"unchecked\")\n\t\tComparable<? super K> k = (Comparable<? super K>) key;\n\t// 将当前root赋值给p\n\tEntry<K,V> p = root;\n\t// 循环遍历p\n\twhile (p != null) {\n\t\t// 通过compareTo方法比较key与p的key\n\t\tint cmp = k.compareTo(p.key);\n\t\tif (cmp < 0)\n\t\t\tp = p.left; // 将p.left赋值给p\n\t\telse if (cmp > 0)\n\t\t\tp = p.right; // 将p.right赋值给p\n\t\telse\n\t\t\treturn p; // 说明key与p.key相等，返回当前p节点\n\t}\n\t// 如果p节点中，没有找到对应的key，返回null\n\treturn null;\n}\n```\n获取Entry的方法的过程大致为：根据comparator获取Entry，其实就是遍历root，查找比较key，有匹配的返回对应的entry即可。注意key值不允许为空，会抛出空指针异常。\n在获取Entry的方法中，如果comparator不为空，则使用getEntryUsingComparator方法获取。实现如下：\n```java\nfinal Entry<K,V> getEntryUsingComparator(Object key) {\n\t@SuppressWarnings(\"unchecked\")\n\tK k = (K) key;\n\tComparator<? super K> cpr = comparator;\n\tif (cpr != null) {\n\t\tEntry<K,V> p = root;\n\t\twhile (p != null) {\n\t\t\t// 通过自定义的compare方法比较key与p的key\n\t\t\tint cmp = cpr.compare(k, p.key);\n\t\t\tif (cmp < 0)\n\t\t\t\tp = p.left; // 将p.left赋值给p\n\t\t\telse if (cmp > 0)\n\t\t\t\tp = p.right; // 将p.right赋值给p\n\t\t\telse\n\t\t\t\treturn p;// 说明key与p.key相等，返回当前p节点\n\t\t}\n\t}\n\t// 如果p节点中，没有找到对应的key，返回null\n\treturn null;\n}\n```\n实现过程和上面差不多，只是比较key值的方法换了而已。\n\n## firstKey \n获取第一个key\n```java\npublic K firstKey() {\n\t// getFirstEntry得到第一个Entry，调用key(),得到key值。\n\treturn key(getFirstEntry());\n}\n该方法比较简单，就不细说了。\n```\n## lastKey \n获取最后一个key\n```java\npublic K lastKey() {\n\t// getLastEntry得到最后一个Entry，调用key(),得到key值。\n\treturn key(getLastEntry());\n}\n```\nlastKey的具体实现过程在getLastEntry中，实现如下：\n```java\nfinal Entry<K,V> getLastEntry() {\n\tEntry<K,V> p = root;\n\tif (p != null)\n\t\twhile (p.right != null)\n\t\t\tp = p.right;\n\treturn p;\n}\n```\n实现方法和firstKey差不多。一直找到最右节点为止。\n\n## remove 删除\n具体代码实现如下：\n```java\n// 根据key删除entry节点，返回value\npublic V remove(Object key) {\n\t// 根据key得到对应entry节点\n\tEntry<K,V> p = getEntry(key);\n\tif (p == null)\n\t\treturn null;\n\n\tV oldValue = p.value;\n\t// 删除entity，后面会介绍\n\tdeleteEntry(p);\n\treturn oldValue;\n}\n```\n首先根据key查找Entry，如果不为空，则调用deleteEntry方法删除。\ndeleteEntry方法是实现如下：\n```java\n/**\n * Delete node p, and then rebalance the tree.\n * 删除节点p，从新平衡树\n */\nprivate void deleteEntry(Entry<K,V> p) {\n\t// 增加一次结构发生变化的次数\n\tmodCount++;\n\t// 此TreeMap节点数量减一\n\tsize--;\n\n\t// If strictly internal, copy successor's element to p and then make p\n\t// point to successor.\n\t// 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点\n\tif (p.left != null && p.right != null) {\n\t\t// successor: 得到p后面的节点\n\t\tEntry<K,V> s = successor(p);\n\t\tp.key = s.key;\n\t\tp.value = s.value;\n\t\tp = s;\n\t} // p has 2 children\n\n\t// Start fixup at replacement node, if it exists.\n\t// replacement为替代节点，如果p的左节点不为空，则为p的左节点，反之为p的右节点\n\tEntry<K,V> replacement = (p.left != null ? p.left : p.right);\n\t// 如果replacement不为空\n\tif (replacement != null) {\n\t\t// Link replacement to parent\n\t\treplacement.parent = p.parent;\n\t\tif (p.parent == null) \n\t\t\t// 如p没有父节点，则根root直接变为替代节点\n\t\t\troot = replacement;\n\t\telse if (p == p.parent.left) //如果P为左节点，则用replacement来替代为左节点\n\t\t\tp.parent.left  = replacement;\n\t\telse\n\t\t\tp.parent.right = replacement; //如果P为右节点，则用replacement来替代为右节点\n\n\t\t// Null out links so they are OK to use by fixAfterDeletion.\n\t\tp.left = p.right = p.parent = null; //去除p节点\n\n\t\t// Fix replacement\n\t\t// 根据节点的颜色，来删除。红色：直接删除，黑色：删除之后，需要平衡树，调整位置。\n\t\tif (p.color == BLACK)\n\t\t\tfixAfterDeletion(replacement);\n\t} else if (p.parent == null) { // return if we are the only node.\n\t\t// 说明是唯一的节点，当前root直接返回 null 即可\n\t\troot = null;\n\t} else { //  No children. Use self as phantom replacement and unlink.\n\t\tif (p.color == BLACK)\n\t\t\tfixAfterDeletion(p);\n\t\t// 删除p节点\n\t\tif (p.parent != null) {\n\t\t\tif (p == p.parent.left)\n\t\t\t\tp.parent.left = null;\n\t\t\telse if (p == p.parent.right)\n\t\t\t\tp.parent.right = null;\n\t\t\tp.parent = null;\n\t\t}\n\t}\n}\n```\n\n# 最后\n本文是对TreeMap做了一个简单的介绍，没有对删除节点之后，红黑树怎么自动平衡做讲解，后面会专门写一篇文章对红黑树做一个学习。\n","source":"_posts/jdk8-source-treemap.md","raw":"---\ntitle: 'JDK8源码学习:TreeMap'\ncategory: Java\ntags:\n  - java\n  - 源码\nabbrlink: 3a2cad14\ndate: 2018-09-07 00:00:00\n---\n# 概述\n本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。\n前面介绍了[HashMap](2da9164.html \"HashMap\")，因为HashMap是一种无序的存储集合，当某些时候需要特定的存储顺序的时候，就只能另寻他法了，在jdk中为我们提供了LinkedHashmap和TreeMap以供我们使用，本文先介绍TreeMap。\nTreeMap和HashMap一样都是继承至AbstractMap，并且实现了NavigableMap()，TreeMap是在NavigableMap基础上基于红黑树的实现，他是一种顺序的存储结构。\nTreeMap数据结构为Entry，Entry简单实现如下：\n```java\nstatic final class Entry<K,V> implements Map.Entry<K,V> {\n\tK key;\n\tV value;\n\tEntry<K,V> left; // 左节点\n\tEntry<K,V> right; // 右节点\n\tEntry<K,V> parent; // 父节点\n\tboolean color = BLACK;\n\t// ... 其他代码省略\n}\n```\n# 常用变量\n- root\nroot的定义为：`private transient Entry<K,V> root`，可以理解为一个短暂的 Entry\n- size\nsize的定义为：`private transient int size = 0`， 记录树中的数量\n- modCount\nmodCount的定义为：`private transient int modCount = 0`，记录结构性发生变化的次数，比如删除节点。\n- comparator\ncomparator的定义为：`private final Comparator<? super K> comparator`,用于维护此树形图中的顺序，如果使用其键的自然顺序，则comparator为空。\n\n# 构造方法\n## 无参\n- public TreeMap()\n代码如下：\n```java\npublic TreeMap() {\n\tcomparator = null;\n}\n```\n构造方法，没有指定comparator，所以使用它的自然顺序排序。\n\n## 有参\n- **public TreeMap(Comparator<? super K> comparator)**\n代码如下：\n```java\npublic TreeMap(Comparator<? super K> comparator) {\n\tthis.comparator = comparator;\n}\n```\n构造方法，使用给定的comparator规则排序\n\n- **public TreeMap(Map<? extends K, ? extends V> m)**\n代码如下：\n```java\npublic TreeMap(Map<? extends K, ? extends V> m) {\n\tcomparator = null;\n\tputAll(m);\n}\n```\n构造一个新的 tree map，其中包含给定map的相同的映射，根据key的自然顺序进行排序，插入的新map的所有key必须实现 Comparable接口\n\n- **public TreeMap(SortedMap<K, ? extends V> m)**\n实现代码如下：\n```java\npublic TreeMap(SortedMap<K, ? extends V> m) {\n\t// 将SoretdMap的排序方法赋给comparator\n\tcomparator = m.comparator();\n\ttry {\n\t\t// 构建 tree map\n\t\tbuildFromSorted(m.size(), m.entrySet().iterator(), null, null);\n\t} catch (java.io.IOException cannotHappen) {\n\t} catch (ClassNotFoundException cannotHappen) {\n\t}\n}\n```\n构造一个新的 tree map，其中包含给定map的相同的映射，并且使用给定的 sorted map 的排序方式进行排序\n\n# 常用方法\n## put() 插入\n插入方法是我们开发常用的方法，接下来看看，TreeMap的put方法具体是怎么实现的，为了方便阅读部分注释直接写在了代码中，代码如下：\n```java\npublic V put(K key, V value) {\n\tEntry<K,V> t = root;\n\tif (t == null) {\n\t\t// 比较两个key值，使用此时正确的compare方法。\n\t\tcompare(key, key); // type (and possibly null) check\n\t\t// new 一个 entry节点\n\t\troot = new Entry<>(key, value, null);\n\t\tsize = 1;\n\t\tmodCount++; // 增加结构变化的次数\n\t\treturn null;\n\t}\n\tint cmp;\n\tEntry<K,V> parent;\n\t// split comparator and comparable paths\n\tComparator<? super K> cpr = comparator;\n\tif (cpr != null) {\n\t\t// 设置value到特定的位置\n\t\tdo {\n\t\t\tparent = t;\n\t\t\tcmp = cpr.compare(key, t.key); // 比较 key 和 t.key\n\t\t\tif (cmp < 0)\n\t\t\t\tt = t.left;\n\t\t\telse if (cmp > 0)\n\t\t\t\tt = t.right;\n\t\t\telse\n\t\t\t\treturn t.setValue(value); // cmp=0，设置value\n\t\t} while (t != null);\n\t}\n\telse {\n\t\tif (key == null) // 不允许key为null\n\t\t\tthrow new NullPointerException();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tComparable<? super K> k = (Comparable<? super K>) key;\n\t\t// 设置value到特定的位置\n\t\tdo {\n\t\t\tparent = t;\n\t\t\tcmp = k.compareTo(t.key);\n\t\t\tif (cmp < 0)\n\t\t\t\tt = t.left;\n\t\t\telse if (cmp > 0)\n\t\t\t\tt = t.right;\n\t\t\telse\n\t\t\t\treturn t.setValue(value);\n\t\t} while (t != null);\n\t}\n\t// 走到了这里， 说明了，cmp != 0，没有找到对应的key值，新建一个entry e，并将e放在相应的parent左右节点下面\n\tEntry<K,V> e = new Entry<>(key, value, parent);\n\tif (cmp < 0)\n\t\tparent.left = e;\n\telse\n\t\tparent.right = e;\n\tfixAfterInsertion(e);\n\tsize++;\n\tmodCount++;\n\treturn null;\n}\n```\nput方法还是比较容易能理解的，首先判断root是否为空，如果没空，直接new Entry即可。不为空，根据comparator的值，查找要设置value的位置。如果没有找到匹配的key，则新建一个Entry e，再根据cmp的值，将Entry e设置到对应的位置即可。\n## get 获取值\n根据key获取一个Entry，具体实现如下：\n```java\nfinal Entry<K,V> getEntry(Object key) {\n\t// Offload comparator-based version for sake of performance\n\tif (comparator != null)\n\t\t// 如果默认comparator不为空，调用getEntryUsingComparator方法\n\t\treturn getEntryUsingComparator(key);\n\tif (key == null) // key不允许为null\n\t\tthrow new NullPointerException();\n\t// 走到了这里，说明comparator为空，使用默认排序方法。\n\t@SuppressWarnings(\"unchecked\")\n\t\tComparable<? super K> k = (Comparable<? super K>) key;\n\t// 将当前root赋值给p\n\tEntry<K,V> p = root;\n\t// 循环遍历p\n\twhile (p != null) {\n\t\t// 通过compareTo方法比较key与p的key\n\t\tint cmp = k.compareTo(p.key);\n\t\tif (cmp < 0)\n\t\t\tp = p.left; // 将p.left赋值给p\n\t\telse if (cmp > 0)\n\t\t\tp = p.right; // 将p.right赋值给p\n\t\telse\n\t\t\treturn p; // 说明key与p.key相等，返回当前p节点\n\t}\n\t// 如果p节点中，没有找到对应的key，返回null\n\treturn null;\n}\n```\n获取Entry的方法的过程大致为：根据comparator获取Entry，其实就是遍历root，查找比较key，有匹配的返回对应的entry即可。注意key值不允许为空，会抛出空指针异常。\n在获取Entry的方法中，如果comparator不为空，则使用getEntryUsingComparator方法获取。实现如下：\n```java\nfinal Entry<K,V> getEntryUsingComparator(Object key) {\n\t@SuppressWarnings(\"unchecked\")\n\tK k = (K) key;\n\tComparator<? super K> cpr = comparator;\n\tif (cpr != null) {\n\t\tEntry<K,V> p = root;\n\t\twhile (p != null) {\n\t\t\t// 通过自定义的compare方法比较key与p的key\n\t\t\tint cmp = cpr.compare(k, p.key);\n\t\t\tif (cmp < 0)\n\t\t\t\tp = p.left; // 将p.left赋值给p\n\t\t\telse if (cmp > 0)\n\t\t\t\tp = p.right; // 将p.right赋值给p\n\t\t\telse\n\t\t\t\treturn p;// 说明key与p.key相等，返回当前p节点\n\t\t}\n\t}\n\t// 如果p节点中，没有找到对应的key，返回null\n\treturn null;\n}\n```\n实现过程和上面差不多，只是比较key值的方法换了而已。\n\n## firstKey \n获取第一个key\n```java\npublic K firstKey() {\n\t// getFirstEntry得到第一个Entry，调用key(),得到key值。\n\treturn key(getFirstEntry());\n}\n该方法比较简单，就不细说了。\n```\n## lastKey \n获取最后一个key\n```java\npublic K lastKey() {\n\t// getLastEntry得到最后一个Entry，调用key(),得到key值。\n\treturn key(getLastEntry());\n}\n```\nlastKey的具体实现过程在getLastEntry中，实现如下：\n```java\nfinal Entry<K,V> getLastEntry() {\n\tEntry<K,V> p = root;\n\tif (p != null)\n\t\twhile (p.right != null)\n\t\t\tp = p.right;\n\treturn p;\n}\n```\n实现方法和firstKey差不多。一直找到最右节点为止。\n\n## remove 删除\n具体代码实现如下：\n```java\n// 根据key删除entry节点，返回value\npublic V remove(Object key) {\n\t// 根据key得到对应entry节点\n\tEntry<K,V> p = getEntry(key);\n\tif (p == null)\n\t\treturn null;\n\n\tV oldValue = p.value;\n\t// 删除entity，后面会介绍\n\tdeleteEntry(p);\n\treturn oldValue;\n}\n```\n首先根据key查找Entry，如果不为空，则调用deleteEntry方法删除。\ndeleteEntry方法是实现如下：\n```java\n/**\n * Delete node p, and then rebalance the tree.\n * 删除节点p，从新平衡树\n */\nprivate void deleteEntry(Entry<K,V> p) {\n\t// 增加一次结构发生变化的次数\n\tmodCount++;\n\t// 此TreeMap节点数量减一\n\tsize--;\n\n\t// If strictly internal, copy successor's element to p and then make p\n\t// point to successor.\n\t// 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点\n\tif (p.left != null && p.right != null) {\n\t\t// successor: 得到p后面的节点\n\t\tEntry<K,V> s = successor(p);\n\t\tp.key = s.key;\n\t\tp.value = s.value;\n\t\tp = s;\n\t} // p has 2 children\n\n\t// Start fixup at replacement node, if it exists.\n\t// replacement为替代节点，如果p的左节点不为空，则为p的左节点，反之为p的右节点\n\tEntry<K,V> replacement = (p.left != null ? p.left : p.right);\n\t// 如果replacement不为空\n\tif (replacement != null) {\n\t\t// Link replacement to parent\n\t\treplacement.parent = p.parent;\n\t\tif (p.parent == null) \n\t\t\t// 如p没有父节点，则根root直接变为替代节点\n\t\t\troot = replacement;\n\t\telse if (p == p.parent.left) //如果P为左节点，则用replacement来替代为左节点\n\t\t\tp.parent.left  = replacement;\n\t\telse\n\t\t\tp.parent.right = replacement; //如果P为右节点，则用replacement来替代为右节点\n\n\t\t// Null out links so they are OK to use by fixAfterDeletion.\n\t\tp.left = p.right = p.parent = null; //去除p节点\n\n\t\t// Fix replacement\n\t\t// 根据节点的颜色，来删除。红色：直接删除，黑色：删除之后，需要平衡树，调整位置。\n\t\tif (p.color == BLACK)\n\t\t\tfixAfterDeletion(replacement);\n\t} else if (p.parent == null) { // return if we are the only node.\n\t\t// 说明是唯一的节点，当前root直接返回 null 即可\n\t\troot = null;\n\t} else { //  No children. Use self as phantom replacement and unlink.\n\t\tif (p.color == BLACK)\n\t\t\tfixAfterDeletion(p);\n\t\t// 删除p节点\n\t\tif (p.parent != null) {\n\t\t\tif (p == p.parent.left)\n\t\t\t\tp.parent.left = null;\n\t\t\telse if (p == p.parent.right)\n\t\t\t\tp.parent.right = null;\n\t\t\tp.parent = null;\n\t\t}\n\t}\n}\n```\n\n# 最后\n本文是对TreeMap做了一个简单的介绍，没有对删除节点之后，红黑树怎么自动平衡做讲解，后面会专门写一篇文章对红黑树做一个学习。\n","slug":"jdk8-source-treemap","published":1,"updated":"2019-12-23T10:59:48.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpj5003ri3slp5lbl7kn","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。<br>前面介绍了<a href=\"2da9164.html\" title=\"HashMap\">HashMap</a>，因为HashMap是一种无序的存储集合，当某些时候需要特定的存储顺序的时候，就只能另寻他法了，在jdk中为我们提供了LinkedHashmap和TreeMap以供我们使用，本文先介绍TreeMap。<br>TreeMap和HashMap一样都是继承至AbstractMap，并且实现了NavigableMap()，TreeMap是在NavigableMap基础上基于红黑树的实现，他是一种顺序的存储结构。<br>TreeMap数据结构为Entry，Entry简单实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\tK key;</span><br><span class=\"line\">\tV value;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; left; <span class=\"comment\">// 左节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; right; <span class=\"comment\">// 右节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; parent; <span class=\"comment\">// 父节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> color = BLACK;</span><br><span class=\"line\">\t<span class=\"comment\">// ... 其他代码省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"常用变量\"><a href=\"#常用变量\" class=\"headerlink\" title=\"常用变量\"></a>常用变量</h1><ul>\n<li>root<br>root的定义为：<code>private transient Entry&lt;K,V&gt; root</code>，可以理解为一个短暂的 Entry</li>\n<li>size<br>size的定义为：<code>private transient int size = 0</code>， 记录树中的数量</li>\n<li>modCount<br>modCount的定义为：<code>private transient int modCount = 0</code>，记录结构性发生变化的次数，比如删除节点。</li>\n<li>comparator<br>comparator的定义为：<code>private final Comparator&lt;? super K&gt; comparator</code>,用于维护此树形图中的顺序，如果使用其键的自然顺序，则comparator为空。</li>\n</ul>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><h2 id=\"无参\"><a href=\"#无参\" class=\"headerlink\" title=\"无参\"></a>无参</h2><ul>\n<li>public TreeMap()<br>代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcomparator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造方法，没有指定comparator，所以使用它的自然顺序排序。</p>\n<h2 id=\"有参\"><a href=\"#有参\" class=\"headerlink\" title=\"有参\"></a>有参</h2><ul>\n<li><strong>public TreeMap(Comparator&lt;? super K&gt; comparator)</strong><br>代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.comparator = comparator;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造方法，使用给定的comparator规则排序</p>\n<ul>\n<li><strong>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</strong><br>代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">\tcomparator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tputAll(m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造一个新的 tree map，其中包含给定map的相同的映射，根据key的自然顺序进行排序，插入的新map的所有key必须实现 Comparable接口</p>\n<ul>\n<li><strong>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</strong><br>实现代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将SoretdMap的排序方法赋给comparator</span></span><br><span class=\"line\">\tcomparator = m.comparator();</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 构建 tree map</span></span><br><span class=\"line\">\t\tbuildFromSorted(m.size(), m.entrySet().iterator(), <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造一个新的 tree map，其中包含给定map的相同的映射，并且使用给定的 sorted map 的排序方式进行排序</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"put-插入\"><a href=\"#put-插入\" class=\"headerlink\" title=\"put() 插入\"></a>put() 插入</h2><p>插入方法是我们开发常用的方法，接下来看看，TreeMap的put方法具体是怎么实现的，为了方便阅读部分注释直接写在了代码中，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; t = root;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 比较两个key值，使用此时正确的compare方法。</span></span><br><span class=\"line\">\t\tcompare(key, key); <span class=\"comment\">// type (and possibly null) check</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// new 一个 entry节点</span></span><br><span class=\"line\">\t\troot = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\tsize = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tmodCount++; <span class=\"comment\">// 增加结构变化的次数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cmp;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; parent;</span><br><span class=\"line\">\t<span class=\"comment\">// split comparator and comparable paths</span></span><br><span class=\"line\">\tComparator&lt;? <span class=\"keyword\">super</span> K&gt; cpr = comparator;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cpr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置value到特定的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tparent = t;</span><br><span class=\"line\">\t\t\tcmp = cpr.compare(key, t.key); <span class=\"comment\">// 比较 key 和 t.key</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.left;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> t.setValue(value); <span class=\"comment\">// cmp=0，设置value</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) <span class=\"comment\">// 不允许key为null</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">\t\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t\t\tComparable&lt;? <span class=\"keyword\">super</span> K&gt; k = (Comparable&lt;? <span class=\"keyword\">super</span> K&gt;) key;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置value到特定的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tparent = t;</span><br><span class=\"line\">\t\t\tcmp = k.compareTo(t.key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.left;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> t.setValue(value);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 走到了这里， 说明了，cmp != 0，没有找到对应的key值，新建一个entry e，并将e放在相应的parent左右节点下面</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; e = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tparent.left = e;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tparent.right = e;</span><br><span class=\"line\">\tfixAfterInsertion(e);</span><br><span class=\"line\">\tsize++;</span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>put方法还是比较容易能理解的，首先判断root是否为空，如果没空，直接new Entry即可。不为空，根据comparator的值，查找要设置value的位置。如果没有找到匹配的key，则新建一个Entry e，再根据cmp的值，将Entry e设置到对应的位置即可。</p>\n<h2 id=\"get-获取值\"><a href=\"#get-获取值\" class=\"headerlink\" title=\"get 获取值\"></a>get 获取值</h2><p>根据key获取一个Entry，具体实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Offload comparator-based version for sake of performance</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果默认comparator不为空，调用getEntryUsingComparator方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> getEntryUsingComparator(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) <span class=\"comment\">// key不允许为null</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">\t<span class=\"comment\">// 走到了这里，说明comparator为空，使用默认排序方法。</span></span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t\tComparable&lt;? <span class=\"keyword\">super</span> K&gt; k = (Comparable&lt;? <span class=\"keyword\">super</span> K&gt;) key;</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前root赋值给p</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; p = root;</span><br><span class=\"line\">\t<span class=\"comment\">// 循环遍历p</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过compareTo方法比较key与p的key</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> cmp = k.compareTo(p.key);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tp = p.left; <span class=\"comment\">// 将p.left赋值给p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tp = p.right; <span class=\"comment\">// 将p.right赋值给p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p; <span class=\"comment\">// 说明key与p.key相等，返回当前p节点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果p节点中，没有找到对应的key，返回null</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取Entry的方法的过程大致为：根据comparator获取Entry，其实就是遍历root，查找比较key，有匹配的返回对应的entry即可。注意key值不允许为空，会抛出空指针异常。<br>在获取Entry的方法中，如果comparator不为空，则使用getEntryUsingComparator方法获取。实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntryUsingComparator</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\tK k = (K) key;</span><br><span class=\"line\">\tComparator&lt;? <span class=\"keyword\">super</span> K&gt; cpr = comparator;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cpr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tEntry&lt;K,V&gt; p = root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过自定义的compare方法比较key与p的key</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> cmp = cpr.compare(k, p.key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tp = p.left; <span class=\"comment\">// 将p.left赋值给p</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tp = p.right; <span class=\"comment\">// 将p.right赋值给p</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> p;<span class=\"comment\">// 说明key与p.key相等，返回当前p节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果p节点中，没有找到对应的key，返回null</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现过程和上面差不多，只是比较key值的方法换了而已。</p>\n<h2 id=\"firstKey\"><a href=\"#firstKey\" class=\"headerlink\" title=\"firstKey\"></a>firstKey</h2><p>获取第一个key<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">firstKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// getFirstEntry得到第一个Entry，调用key(),得到key值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> key(getFirstEntry());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">该方法比较简单，就不细说了。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"lastKey\"><a href=\"#lastKey\" class=\"headerlink\" title=\"lastKey\"></a>lastKey</h2><p>获取最后一个key<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">lastKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// getLastEntry得到最后一个Entry，调用key(),得到key值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> key(getLastEntry());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>lastKey的具体实现过程在getLastEntry中，实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getLastEntry</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; p = root;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p.right != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\tp = p.right;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现方法和firstKey差不多。一直找到最右节点为止。</p>\n<h2 id=\"remove-删除\"><a href=\"#remove-删除\" class=\"headerlink\" title=\"remove 删除\"></a>remove 删除</h2><p>具体代码实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据key删除entry节点，返回value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据key得到对应entry节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; p = getEntry(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tV oldValue = p.value;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除entity，后面会介绍</span></span><br><span class=\"line\">\tdeleteEntry(p);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先根据key查找Entry，如果不为空，则调用deleteEntry方法删除。<br>deleteEntry方法是实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Delete node p, and then rebalance the tree.</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除节点p，从新平衡树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteEntry</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 增加一次结构发生变化的次数</span></span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\t<span class=\"comment\">// 此TreeMap节点数量减一</span></span><br><span class=\"line\">\tsize--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class=\"line\">\t<span class=\"comment\">// point to successor.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p.left != <span class=\"keyword\">null</span> &amp;&amp; p.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// successor: 得到p后面的节点</span></span><br><span class=\"line\">\t\tEntry&lt;K,V&gt; s = successor(p);</span><br><span class=\"line\">\t\tp.key = s.key;</span><br><span class=\"line\">\t\tp.value = s.value;</span><br><span class=\"line\">\t\tp = s;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">// p has 2 children</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Start fixup at replacement node, if it exists.</span></span><br><span class=\"line\">\t<span class=\"comment\">// replacement为替代节点，如果p的左节点不为空，则为p的左节点，反之为p的右节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; replacement = (p.left != <span class=\"keyword\">null</span> ? p.left : p.right);</span><br><span class=\"line\">\t<span class=\"comment\">// 如果replacement不为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (replacement != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Link replacement to parent</span></span><br><span class=\"line\">\t\treplacement.parent = p.parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如p没有父节点，则根root直接变为替代节点</span></span><br><span class=\"line\">\t\t\troot = replacement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.left) <span class=\"comment\">//如果P为左节点，则用replacement来替代为左节点</span></span><br><span class=\"line\">\t\t\tp.parent.left  = replacement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tp.parent.right = replacement; <span class=\"comment\">//如果P为右节点，则用replacement来替代为右节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class=\"line\">\t\tp.left = p.right = p.parent = <span class=\"keyword\">null</span>; <span class=\"comment\">//去除p节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Fix replacement</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 根据节点的颜色，来删除。红色：直接删除，黑色：删除之后，需要平衡树，调整位置。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.color == BLACK)</span><br><span class=\"line\">\t\t\tfixAfterDeletion(replacement);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// return if we are the only node.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 说明是唯一的节点，当前root直接返回 null 即可</span></span><br><span class=\"line\">\t\troot = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.color == BLACK)</span><br><span class=\"line\">\t\t\tfixAfterDeletion(p);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 删除p节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p == p.parent.left)</span><br><span class=\"line\">\t\t\t\tp.parent.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.right)</span><br><span class=\"line\">\t\t\t\tp.parent.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tp.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>本文是对TreeMap做了一个简单的介绍，没有对删除节点之后，红黑树怎么自动平衡做讲解，后面会专门写一篇文章对红黑树做一个学习。</p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本文是记录学习，文中有理解错误的地方，请指出共同探讨改正。<br>前面介绍了<a href=\"2da9164.html\" title=\"HashMap\">HashMap</a>，因为HashMap是一种无序的存储集合，当某些时候需要特定的存储顺序的时候，就只能另寻他法了，在jdk中为我们提供了LinkedHashmap和TreeMap以供我们使用，本文先介绍TreeMap。<br>TreeMap和HashMap一样都是继承至AbstractMap，并且实现了NavigableMap()，TreeMap是在NavigableMap基础上基于红黑树的实现，他是一种顺序的存储结构。<br>TreeMap数据结构为Entry，Entry简单实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\tK key;</span><br><span class=\"line\">\tV value;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; left; <span class=\"comment\">// 左节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; right; <span class=\"comment\">// 右节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; parent; <span class=\"comment\">// 父节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> color = BLACK;</span><br><span class=\"line\">\t<span class=\"comment\">// ... 其他代码省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"常用变量\"><a href=\"#常用变量\" class=\"headerlink\" title=\"常用变量\"></a>常用变量</h1><ul>\n<li>root<br>root的定义为：<code>private transient Entry&lt;K,V&gt; root</code>，可以理解为一个短暂的 Entry</li>\n<li>size<br>size的定义为：<code>private transient int size = 0</code>， 记录树中的数量</li>\n<li>modCount<br>modCount的定义为：<code>private transient int modCount = 0</code>，记录结构性发生变化的次数，比如删除节点。</li>\n<li>comparator<br>comparator的定义为：<code>private final Comparator&lt;? super K&gt; comparator</code>,用于维护此树形图中的顺序，如果使用其键的自然顺序，则comparator为空。</li>\n</ul>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><h2 id=\"无参\"><a href=\"#无参\" class=\"headerlink\" title=\"无参\"></a>无参</h2><ul>\n<li>public TreeMap()<br>代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tcomparator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造方法，没有指定comparator，所以使用它的自然顺序排序。</p>\n<h2 id=\"有参\"><a href=\"#有参\" class=\"headerlink\" title=\"有参\"></a>有参</h2><ul>\n<li><strong>public TreeMap(Comparator&lt;? super K&gt; comparator)</strong><br>代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.comparator = comparator;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造方法，使用给定的comparator规则排序</p>\n<ul>\n<li><strong>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</strong><br>代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">\tcomparator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tputAll(m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造一个新的 tree map，其中包含给定map的相同的映射，根据key的自然顺序进行排序，插入的新map的所有key必须实现 Comparable接口</p>\n<ul>\n<li><strong>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</strong><br>实现代码如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeMap</span><span class=\"params\">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将SoretdMap的排序方法赋给comparator</span></span><br><span class=\"line\">\tcomparator = m.comparator();</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 构建 tree map</span></span><br><span class=\"line\">\t\tbuildFromSorted(m.size(), m.entrySet().iterator(), <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>构造一个新的 tree map，其中包含给定map的相同的映射，并且使用给定的 sorted map 的排序方式进行排序</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"put-插入\"><a href=\"#put-插入\" class=\"headerlink\" title=\"put() 插入\"></a>put() 插入</h2><p>插入方法是我们开发常用的方法，接下来看看，TreeMap的put方法具体是怎么实现的，为了方便阅读部分注释直接写在了代码中，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; t = root;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 比较两个key值，使用此时正确的compare方法。</span></span><br><span class=\"line\">\t\tcompare(key, key); <span class=\"comment\">// type (and possibly null) check</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// new 一个 entry节点</span></span><br><span class=\"line\">\t\troot = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\tsize = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tmodCount++; <span class=\"comment\">// 增加结构变化的次数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> cmp;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; parent;</span><br><span class=\"line\">\t<span class=\"comment\">// split comparator and comparable paths</span></span><br><span class=\"line\">\tComparator&lt;? <span class=\"keyword\">super</span> K&gt; cpr = comparator;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cpr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置value到特定的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tparent = t;</span><br><span class=\"line\">\t\t\tcmp = cpr.compare(key, t.key); <span class=\"comment\">// 比较 key 和 t.key</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.left;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> t.setValue(value); <span class=\"comment\">// cmp=0，设置value</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) <span class=\"comment\">// 不允许key为null</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">\t\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t\t\tComparable&lt;? <span class=\"keyword\">super</span> K&gt; k = (Comparable&lt;? <span class=\"keyword\">super</span> K&gt;) key;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置value到特定的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\tparent = t;</span><br><span class=\"line\">\t\t\tcmp = k.compareTo(t.key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.left;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tt = t.right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> t.setValue(value);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 走到了这里， 说明了，cmp != 0，没有找到对应的key值，新建一个entry e，并将e放在相应的parent左右节点下面</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; e = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tparent.left = e;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tparent.right = e;</span><br><span class=\"line\">\tfixAfterInsertion(e);</span><br><span class=\"line\">\tsize++;</span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>put方法还是比较容易能理解的，首先判断root是否为空，如果没空，直接new Entry即可。不为空，根据comparator的值，查找要设置value的位置。如果没有找到匹配的key，则新建一个Entry e，再根据cmp的值，将Entry e设置到对应的位置即可。</p>\n<h2 id=\"get-获取值\"><a href=\"#get-获取值\" class=\"headerlink\" title=\"get 获取值\"></a>get 获取值</h2><p>根据key获取一个Entry，具体实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Offload comparator-based version for sake of performance</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果默认comparator不为空，调用getEntryUsingComparator方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> getEntryUsingComparator(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) <span class=\"comment\">// key不允许为null</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">\t<span class=\"comment\">// 走到了这里，说明comparator为空，使用默认排序方法。</span></span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t\tComparable&lt;? <span class=\"keyword\">super</span> K&gt; k = (Comparable&lt;? <span class=\"keyword\">super</span> K&gt;) key;</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前root赋值给p</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; p = root;</span><br><span class=\"line\">\t<span class=\"comment\">// 循环遍历p</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过compareTo方法比较key与p的key</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> cmp = k.compareTo(p.key);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tp = p.left; <span class=\"comment\">// 将p.left赋值给p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tp = p.right; <span class=\"comment\">// 将p.right赋值给p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p; <span class=\"comment\">// 说明key与p.key相等，返回当前p节点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果p节点中，没有找到对应的key，返回null</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取Entry的方法的过程大致为：根据comparator获取Entry，其实就是遍历root，查找比较key，有匹配的返回对应的entry即可。注意key值不允许为空，会抛出空指针异常。<br>在获取Entry的方法中，如果comparator不为空，则使用getEntryUsingComparator方法获取。实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntryUsingComparator</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\tK k = (K) key;</span><br><span class=\"line\">\tComparator&lt;? <span class=\"keyword\">super</span> K&gt; cpr = comparator;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cpr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tEntry&lt;K,V&gt; p = root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过自定义的compare方法比较key与p的key</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> cmp = cpr.compare(k, p.key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tp = p.left; <span class=\"comment\">// 将p.left赋值给p</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tp = p.right; <span class=\"comment\">// 将p.right赋值给p</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> p;<span class=\"comment\">// 说明key与p.key相等，返回当前p节点</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果p节点中，没有找到对应的key，返回null</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现过程和上面差不多，只是比较key值的方法换了而已。</p>\n<h2 id=\"firstKey\"><a href=\"#firstKey\" class=\"headerlink\" title=\"firstKey\"></a>firstKey</h2><p>获取第一个key<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">firstKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// getFirstEntry得到第一个Entry，调用key(),得到key值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> key(getFirstEntry());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">该方法比较简单，就不细说了。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"lastKey\"><a href=\"#lastKey\" class=\"headerlink\" title=\"lastKey\"></a>lastKey</h2><p>获取最后一个key<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">lastKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// getLastEntry得到最后一个Entry，调用key(),得到key值。</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> key(getLastEntry());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>lastKey的具体实现过程在getLastEntry中，实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getLastEntry</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tEntry&lt;K,V&gt; p = root;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (p.right != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\tp = p.right;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现方法和firstKey差不多。一直找到最右节点为止。</p>\n<h2 id=\"remove-删除\"><a href=\"#remove-删除\" class=\"headerlink\" title=\"remove 删除\"></a>remove 删除</h2><p>具体代码实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据key删除entry节点，返回value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据key得到对应entry节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; p = getEntry(key);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tV oldValue = p.value;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除entity，后面会介绍</span></span><br><span class=\"line\">\tdeleteEntry(p);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先根据key查找Entry，如果不为空，则调用deleteEntry方法删除。<br>deleteEntry方法是实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Delete node p, and then rebalance the tree.</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除节点p，从新平衡树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteEntry</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 增加一次结构发生变化的次数</span></span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\t<span class=\"comment\">// 此TreeMap节点数量减一</span></span><br><span class=\"line\">\tsize--;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class=\"line\">\t<span class=\"comment\">// point to successor.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p.left != <span class=\"keyword\">null</span> &amp;&amp; p.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// successor: 得到p后面的节点</span></span><br><span class=\"line\">\t\tEntry&lt;K,V&gt; s = successor(p);</span><br><span class=\"line\">\t\tp.key = s.key;</span><br><span class=\"line\">\t\tp.value = s.value;</span><br><span class=\"line\">\t\tp = s;</span><br><span class=\"line\">\t&#125; <span class=\"comment\">// p has 2 children</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Start fixup at replacement node, if it exists.</span></span><br><span class=\"line\">\t<span class=\"comment\">// replacement为替代节点，如果p的左节点不为空，则为p的左节点，反之为p的右节点</span></span><br><span class=\"line\">\tEntry&lt;K,V&gt; replacement = (p.left != <span class=\"keyword\">null</span> ? p.left : p.right);</span><br><span class=\"line\">\t<span class=\"comment\">// 如果replacement不为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (replacement != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Link replacement to parent</span></span><br><span class=\"line\">\t\treplacement.parent = p.parent;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如p没有父节点，则根root直接变为替代节点</span></span><br><span class=\"line\">\t\t\troot = replacement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.left) <span class=\"comment\">//如果P为左节点，则用replacement来替代为左节点</span></span><br><span class=\"line\">\t\t\tp.parent.left  = replacement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tp.parent.right = replacement; <span class=\"comment\">//如果P为右节点，则用replacement来替代为右节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class=\"line\">\t\tp.left = p.right = p.parent = <span class=\"keyword\">null</span>; <span class=\"comment\">//去除p节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Fix replacement</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 根据节点的颜色，来删除。红色：直接删除，黑色：删除之后，需要平衡树，调整位置。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.color == BLACK)</span><br><span class=\"line\">\t\t\tfixAfterDeletion(replacement);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// return if we are the only node.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 说明是唯一的节点，当前root直接返回 null 即可</span></span><br><span class=\"line\">\t\troot = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.color == BLACK)</span><br><span class=\"line\">\t\t\tfixAfterDeletion(p);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 删除p节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.parent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p == p.parent.left)</span><br><span class=\"line\">\t\t\t\tp.parent.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.right)</span><br><span class=\"line\">\t\t\t\tp.parent.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tp.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>本文是对TreeMap做了一个简单的介绍，没有对删除节点之后，红黑树怎么自动平衡做讲解，后面会专门写一篇文章对红黑树做一个学习。</p>\n"},{"title":"jdk8源码学习：ConcurrentHashMap","abbrlink":"3250641","date":"2018-10-10T02:43:50.000Z","_content":"# 概述\nConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的安全，但是HashTable的同步机制颗粒度太粗（实现机制是将put、size等各种方法加上‘synchronized’，导致了所有并发操作需要竞争同一把锁），导致性能低下,现在已经很少被推荐使用。\n在jdk8中，ConcurrentHashMap底层实现使用了数组+链表+红黑树的数据结构\n# 常用变量\n## LOAD_FACTOR 加载因子\nLOAD_FACTOR的默认大小是`0.75f`。为何是`0.75`\t而不是其他的值呢？\n首先理解一下，什么是加载因子。\n- 加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然\n- 冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。\n- 结合前面两条，我们必须在 \"冲突的机会\"与\"空间利用率\"之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的\"时间复杂度-空间复杂度\"矛盾的平衡与折衷。\n\n## DEFAULT_CAPACITY 默认容量\nDEFAULT_CAPACITY的默认值为16，可以通过构造方法定义该值，但是需要注意的是，DEFAULT_CAPACITY的值是2的幂次方。结合前面的加载因子，可以得出，ConcurrentHashMap的初始化容量为:`0.75*16=12`,当size大于12的时候，就会发生扩容。\n\n# 构造方法\n```java\n// 使用默认初始化表大小（16）创建一个空的map\npublic ConcurrentHashMap() {\n}\n```\n\n```java\n// 创建一个新的空map，初始化表大小容纳指定数量的元素，不需要动态调转大小。\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n```\n该构造方法 就是设置 sizeCtl; 首先计算`initialCapacity + (initialCapacity >>> 1` （可以简写为： `1.5*initialCapacity + 1`）, 再调用`tableSizeFor` 方法，该方法的作用是：对`1.5*initialCapacity + 1 `向上取最近的2的n次方。比如：初始化大小为：10，计算结果为16。 初始化大小为：15，计算结果为32.\n\n# 常用方法\n## put 方法\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n```\n该方法主要是调用了 `putVal()`,接下来是实现具体实现方法\n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n     // key 和 value 都不能为空\n    if (key == null || value == null) throw new NullPointerException();\n     // 计算 hash\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n\t\t// 如果数组为空，则初始化数组\n        if (tab == null || (n = tab.length) == 0)\n\t\t\t// 初始化数组方法 后面单独介绍\n            tab = initTable();\n\t\t// 通过hash值找到数组对应的节点f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n\t\t\t// f节点为空，调用casTabAt方法\n\t\t\t//casTabAt 具体执行过程是，底层通过sun.misc.Unsafe 调用了compareAndSwapObject。该方法是无锁算法，将值插入数组中。\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n\t\t// MOVED : 转换节点的hash值\n        else if ((fh = f.hash) == MOVED)\n\t\t\t// 帮助数据迁移。并发情况下。\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n\t\t\t\t\t// 头结点的 hash 值大于 0，说明是链表。\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n\t\t\t\t\t\t\t// 根据hash判断是否有相等的key， 如果有匹配成功，通过onlyIfAbsent 判断是否需要覆盖该key对应的值。然后break。\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n\t\t\t\t\t\t\t// 到了这儿，说明没有匹配的key，如果该节点的下一个节点为空，说明已经到了链表的末端，将值给放在该链表的最末端即可，然后break。\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n\t\t\t\t\t// 判断是否为红黑树\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n\t\t\t\t\t\t// 调用红黑树的put方法，根据onlyIfAbsent判断是否覆盖该值。\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n\t\t\t// 如果 binCount不等于0，则在进行链表操作。\n            if (binCount != 0) {\n\t\t\t\t// TREEIFY_THRESHOLD 默认为8\n\t\t\t\t// 如果binCount的值大于等于8，则调用treeifyBin方法\n                if (binCount >= TREEIFY_THRESHOLD)\n\t\t\t\t\t// 后面单独介绍该方法\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\nput方法的主要流程就是这样，接下来看看，put流程中遗留的几个问题。\n## 初始化数组 initTable\n```java\n    /**\n     * Initializes table, using the size recorded in sizeCtl.\n\t * 使用sizeCtl中记录的大小初始化表。\n     */\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {\n\t\t\t// 初始化‘线程’竞争失败。等待。\n            if ((sc = sizeCtl) < 0)\n                Thread.yield(); // lost initialization race; just spin\n\t\t\t// 利用CAS操作， 并设置sizeCtl的值。\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if ((tab = table) == null || tab.length == 0) {\n\t\t\t\t\t\t// 三目运算，DEFAULT_CAPACITY默认为16\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n\t\t\t\t\t\t// 如果n的值为16，则sc计算结果为12\n                        sc = n - (n >>> 2);\n                    }\n                } finally {\n\t\t\t\t\t// 设置sizeCtl值\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n\n## 链表转红黑树 treeifyBin\n\n```java\n    private final void treeifyBin(Node<K,V>[] tab, int index) {\n        Node<K,V> b; int n, sc;\n        if (tab != null) {\n\t\t\t// 如果数组的长度小于 MIN_TREEIFY_CAPACITY（64），对数组进行扩容\n            if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n\t\t\t\t// n值翻倍之后传入\n                tryPresize(n << 1);\n            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n                synchronized (b) { // 加锁\n                    if (tabAt(tab, index) == b) {\n                        TreeNode<K,V> hd = null, tl = null;\n\t\t\t\t\t\t// 遍历链表，建立红黑树。\n                        for (Node<K,V> e = b; e != null; e = e.next) {\n                            TreeNode<K,V> p =\n                                new TreeNode<K,V>(e.hash, e.key, e.val,\n                                                  null, null);\n                            if ((p.prev = tl) == null)\n                                hd = p;\n                            else\n                                tl.next = p;\n                            tl = p;\n                        }\n\t\t\t\t\t\t// 将红黑树设置到数组的相应位置\n                        setTabAt(tab, index, new TreeBin<K,V>(hd));\n                    }\n                }\n            }\n        }\n    }\n```\n链表转红黑树方法，在开始的时候回校验数组的长度，如果小于64，会进行扩容，反之，进行转红黑树过程。\n## 扩容 tryPresize\n将ConcurrentHashMap的容量扩展为原来的两倍。\n\n```java\nprivate final void tryPresize(int size) {\n\t// size 在传递过来的时候，已经翻倍了。 如果size大于等于 最大容量的二分之一，c的值就是默认最大容量\n\t// 反之，调用tableSizeFor方法，该方法就是对(size*1.5+1),在向上取2的n次方。\n\tint c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :\n\ttableSizeFor(size + (size >>> 1) + 1);\n\tint sc;\n\twhile ((sc = sizeCtl) >= 0) {\n\t\tNode<K,V>[] tab = table; int n;\n\t\tif (tab == null || (n = tab.length) == 0) {\n\t\t\tn = (sc > c) ? sc : c;\n\t\t\tif (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (table == tab) {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tNode<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n\t\t\t\t\t\ttable = nt;\n\t\t\t\t\t\tsc = n - (n >>> 2);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tsizeCtl = sc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (c <= sc || n >= MAXIMUM_CAPACITY)\n\t\t\tbreak;\n\t\telse if (tab == table) {\n\t\t\tint rs = resizeStamp(n);\n\t\t\tif (sc < 0) {\n\t\t\t\tNode<K,V>[] nt;\n\t\t\t\tif ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n\t\t\t\t\tsc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n\t\t\t\t\ttransferIndex <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n\t\t\t\t\ttransfer(tab, nt);\n\t\t\t}\n\t\t\telse if (U.compareAndSwapInt(this, SIZECTL, sc,\n\t\t\t\t\t\t\t\t\t\t (rs << RESIZE_STAMP_SHIFT) + 2))\n\t\t\t\ttransfer(tab, null);\n\t\t}\n\t}\n}\n```\n\n## get(Object kye) 取值\n接下来看看获取value的方法，get(key)规定了key不能为null，如果为null，则会抛出NPE。实现过程如下：\n\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    // 类似与HashMap中的hash方法\n    int h = spread(key.hashCode());\n    // table为当前对象中存储所有元素的数组，不能为空\n    // tabAt是根据hash值，从table中找到hash为h的这个元素\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断元素的hash是否相等，接着判断key是否相等，如相等直接返回value\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        // 遍历链表，直到找到对应的值为止。\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\nget方法比较简单，没有加锁，只需要根据key直接取值就可以。类似`containsKey(Object key)`方法，其实就是调用了`get`方法，在判断get的返回值是否为空而已。\n\n## remove(Object key) 删除\nremove方法实现如下：\n\n```java\npublic V remove(Object key) {\n    return replaceNode(key, null, null);\n}\n```\n具体实现在`replaceNode`方法中，接来下是该方法的具体实现。`replaceNode`是对`remove/replace`公共方法的实现\n\n```java\nfinal V replaceNode(Object key, V value, Object cv) {\n    // 根据key的hashCode计算出hash值\n    int hash = spread(key.hashCode());\n    // 循环table\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果tab为空或者通过tabAt得到的node节点为空，直接跳出循环\n        if (tab == null || (n = tab.length) == 0 ||\n            (f = tabAt(tab, i = (n - 1) & hash)) == null)\n            break;\n        //如果链表头节点的hash值为-1，说明table可能正在进行扩容，调用helpTransfer方法帮助扩容\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            boolean validated = false;\n            synchronized (f) { // 对链表头节点加锁\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        validated = true;\n                        // 遍历链表查找key值\n                        for (Node<K,V> e = f, pred = null;;) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) { // 判断节点e的key是否相等\n                                V ev = e.val;\n                                if (cv == null || cv == ev ||\n                                    (ev != null && cv.equals(ev))) { // 如果给定的value为null，或者value与cv相等\n                                    oldVal = ev;\n                                    if (value != null) // 如果给定你的value不为null，替换节点e的value\n                                        e.val = value;\n                                    else if (pred != null) // 如果链表的前一个节点不为null，将节点e的下一个节点指向前一个节点的下一个节点。相当于删除当前节点\n                                        pred.next = e.next;\n                                    else\n                                        setTabAt(tab, i, e.next); // 前一个节点为null，说明是链表头节点，插入头节点，next指向原头节点的next\n                                }\n                                break;\n                            }\n                            pred = e;\n                            if ((e = e.next) == null) // 没有找到匹配的key，返回\n                                break;\n                        }\n                    }\n                    // 如果节点为树结构\n                    else if (f instanceof TreeBin) {\n                        validated = true;\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> r, p;\n                        // 调用findTreeNode方法根据key查找节点\n                        if ((r = t.root) != null &&\n                            (p = r.findTreeNode(hash, key, null)) != null) {\n                            V pv = p.val;\n                            if (cv == null || cv == pv ||\n                                (pv != null && cv.equals(pv))) {\n                                oldVal = pv;\n                                if (value != null)\n                                    p.val = value;\n                                //调用树节点removeTreeNode方法删除节点，返回true说明节点太少，转化为链表结构\n                                else if (t.removeTreeNode(p))\n                                    setTabAt(tab, i, untreeify(t.first));\n                            }\n                        }\n                    }\n                }\n            }\n            if (validated) {\n                if (oldVal != null) {\n                    if (value == null)\n                        addCount(-1L, -1);\n                    return oldVal;\n                }\n                break;\n            }\n        }\n    }\n    return null;\n}\n```\n\n# 总结\n\n* 在JDK8中使用了CAS方法保证操作的原子性\n* 与JDK7不同的是，在JDK8中，当链表长度到达一定值时，会自动转为红黑树存储。\n* 与JDK7不同的是，在JDK8中，ConcurrentHashMap不再使用segment结构，而是使用synchronized关键字对table中的链表头节点进行加锁，粒度更小，从而使同时操作的线程数量更多，效率更高。\n\n## 参考\n《Java并发编程实战》\n\n[https://juejin.im/post/5a7844556fb9a06351725263](https://juejin.im/post/5a7844556fb9a06351725263)","source":"_posts/jdk8-source-ConcurrentHashMap.md","raw":"---\ntitle: jdk8源码学习：ConcurrentHashMap\ncategory: Java\ntags:\n  - java\n  - 源码\nabbrlink: '3250641'\ndate: 2018-10-10 10:43:50\n---\n# 概述\nConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的安全，但是HashTable的同步机制颗粒度太粗（实现机制是将put、size等各种方法加上‘synchronized’，导致了所有并发操作需要竞争同一把锁），导致性能低下,现在已经很少被推荐使用。\n在jdk8中，ConcurrentHashMap底层实现使用了数组+链表+红黑树的数据结构\n# 常用变量\n## LOAD_FACTOR 加载因子\nLOAD_FACTOR的默认大小是`0.75f`。为何是`0.75`\t而不是其他的值呢？\n首先理解一下，什么是加载因子。\n- 加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然\n- 冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。\n- 结合前面两条，我们必须在 \"冲突的机会\"与\"空间利用率\"之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的\"时间复杂度-空间复杂度\"矛盾的平衡与折衷。\n\n## DEFAULT_CAPACITY 默认容量\nDEFAULT_CAPACITY的默认值为16，可以通过构造方法定义该值，但是需要注意的是，DEFAULT_CAPACITY的值是2的幂次方。结合前面的加载因子，可以得出，ConcurrentHashMap的初始化容量为:`0.75*16=12`,当size大于12的时候，就会发生扩容。\n\n# 构造方法\n```java\n// 使用默认初始化表大小（16）创建一个空的map\npublic ConcurrentHashMap() {\n}\n```\n\n```java\n// 创建一个新的空map，初始化表大小容纳指定数量的元素，不需要动态调转大小。\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n```\n该构造方法 就是设置 sizeCtl; 首先计算`initialCapacity + (initialCapacity >>> 1` （可以简写为： `1.5*initialCapacity + 1`）, 再调用`tableSizeFor` 方法，该方法的作用是：对`1.5*initialCapacity + 1 `向上取最近的2的n次方。比如：初始化大小为：10，计算结果为16。 初始化大小为：15，计算结果为32.\n\n# 常用方法\n## put 方法\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n```\n该方法主要是调用了 `putVal()`,接下来是实现具体实现方法\n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n     // key 和 value 都不能为空\n    if (key == null || value == null) throw new NullPointerException();\n     // 计算 hash\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n\t\t// 如果数组为空，则初始化数组\n        if (tab == null || (n = tab.length) == 0)\n\t\t\t// 初始化数组方法 后面单独介绍\n            tab = initTable();\n\t\t// 通过hash值找到数组对应的节点f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n\t\t\t// f节点为空，调用casTabAt方法\n\t\t\t//casTabAt 具体执行过程是，底层通过sun.misc.Unsafe 调用了compareAndSwapObject。该方法是无锁算法，将值插入数组中。\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n\t\t// MOVED : 转换节点的hash值\n        else if ((fh = f.hash) == MOVED)\n\t\t\t// 帮助数据迁移。并发情况下。\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n\t\t\t\t\t// 头结点的 hash 值大于 0，说明是链表。\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n\t\t\t\t\t\t\t// 根据hash判断是否有相等的key， 如果有匹配成功，通过onlyIfAbsent 判断是否需要覆盖该key对应的值。然后break。\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n\t\t\t\t\t\t\t// 到了这儿，说明没有匹配的key，如果该节点的下一个节点为空，说明已经到了链表的末端，将值给放在该链表的最末端即可，然后break。\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n\t\t\t\t\t// 判断是否为红黑树\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n\t\t\t\t\t\t// 调用红黑树的put方法，根据onlyIfAbsent判断是否覆盖该值。\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n\t\t\t// 如果 binCount不等于0，则在进行链表操作。\n            if (binCount != 0) {\n\t\t\t\t// TREEIFY_THRESHOLD 默认为8\n\t\t\t\t// 如果binCount的值大于等于8，则调用treeifyBin方法\n                if (binCount >= TREEIFY_THRESHOLD)\n\t\t\t\t\t// 后面单独介绍该方法\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\nput方法的主要流程就是这样，接下来看看，put流程中遗留的几个问题。\n## 初始化数组 initTable\n```java\n    /**\n     * Initializes table, using the size recorded in sizeCtl.\n\t * 使用sizeCtl中记录的大小初始化表。\n     */\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {\n\t\t\t// 初始化‘线程’竞争失败。等待。\n            if ((sc = sizeCtl) < 0)\n                Thread.yield(); // lost initialization race; just spin\n\t\t\t// 利用CAS操作， 并设置sizeCtl的值。\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if ((tab = table) == null || tab.length == 0) {\n\t\t\t\t\t\t// 三目运算，DEFAULT_CAPACITY默认为16\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n\t\t\t\t\t\t// 如果n的值为16，则sc计算结果为12\n                        sc = n - (n >>> 2);\n                    }\n                } finally {\n\t\t\t\t\t// 设置sizeCtl值\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n\n## 链表转红黑树 treeifyBin\n\n```java\n    private final void treeifyBin(Node<K,V>[] tab, int index) {\n        Node<K,V> b; int n, sc;\n        if (tab != null) {\n\t\t\t// 如果数组的长度小于 MIN_TREEIFY_CAPACITY（64），对数组进行扩容\n            if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n\t\t\t\t// n值翻倍之后传入\n                tryPresize(n << 1);\n            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n                synchronized (b) { // 加锁\n                    if (tabAt(tab, index) == b) {\n                        TreeNode<K,V> hd = null, tl = null;\n\t\t\t\t\t\t// 遍历链表，建立红黑树。\n                        for (Node<K,V> e = b; e != null; e = e.next) {\n                            TreeNode<K,V> p =\n                                new TreeNode<K,V>(e.hash, e.key, e.val,\n                                                  null, null);\n                            if ((p.prev = tl) == null)\n                                hd = p;\n                            else\n                                tl.next = p;\n                            tl = p;\n                        }\n\t\t\t\t\t\t// 将红黑树设置到数组的相应位置\n                        setTabAt(tab, index, new TreeBin<K,V>(hd));\n                    }\n                }\n            }\n        }\n    }\n```\n链表转红黑树方法，在开始的时候回校验数组的长度，如果小于64，会进行扩容，反之，进行转红黑树过程。\n## 扩容 tryPresize\n将ConcurrentHashMap的容量扩展为原来的两倍。\n\n```java\nprivate final void tryPresize(int size) {\n\t// size 在传递过来的时候，已经翻倍了。 如果size大于等于 最大容量的二分之一，c的值就是默认最大容量\n\t// 反之，调用tableSizeFor方法，该方法就是对(size*1.5+1),在向上取2的n次方。\n\tint c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :\n\ttableSizeFor(size + (size >>> 1) + 1);\n\tint sc;\n\twhile ((sc = sizeCtl) >= 0) {\n\t\tNode<K,V>[] tab = table; int n;\n\t\tif (tab == null || (n = tab.length) == 0) {\n\t\t\tn = (sc > c) ? sc : c;\n\t\t\tif (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n\t\t\t\ttry {\n\t\t\t\t\tif (table == tab) {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tNode<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n\t\t\t\t\t\ttable = nt;\n\t\t\t\t\t\tsc = n - (n >>> 2);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tsizeCtl = sc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (c <= sc || n >= MAXIMUM_CAPACITY)\n\t\t\tbreak;\n\t\telse if (tab == table) {\n\t\t\tint rs = resizeStamp(n);\n\t\t\tif (sc < 0) {\n\t\t\t\tNode<K,V>[] nt;\n\t\t\t\tif ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n\t\t\t\t\tsc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n\t\t\t\t\ttransferIndex <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n\t\t\t\t\ttransfer(tab, nt);\n\t\t\t}\n\t\t\telse if (U.compareAndSwapInt(this, SIZECTL, sc,\n\t\t\t\t\t\t\t\t\t\t (rs << RESIZE_STAMP_SHIFT) + 2))\n\t\t\t\ttransfer(tab, null);\n\t\t}\n\t}\n}\n```\n\n## get(Object kye) 取值\n接下来看看获取value的方法，get(key)规定了key不能为null，如果为null，则会抛出NPE。实现过程如下：\n\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    // 类似与HashMap中的hash方法\n    int h = spread(key.hashCode());\n    // table为当前对象中存储所有元素的数组，不能为空\n    // tabAt是根据hash值，从table中找到hash为h的这个元素\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断元素的hash是否相等，接着判断key是否相等，如相等直接返回value\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        // 遍历链表，直到找到对应的值为止。\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\nget方法比较简单，没有加锁，只需要根据key直接取值就可以。类似`containsKey(Object key)`方法，其实就是调用了`get`方法，在判断get的返回值是否为空而已。\n\n## remove(Object key) 删除\nremove方法实现如下：\n\n```java\npublic V remove(Object key) {\n    return replaceNode(key, null, null);\n}\n```\n具体实现在`replaceNode`方法中，接来下是该方法的具体实现。`replaceNode`是对`remove/replace`公共方法的实现\n\n```java\nfinal V replaceNode(Object key, V value, Object cv) {\n    // 根据key的hashCode计算出hash值\n    int hash = spread(key.hashCode());\n    // 循环table\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果tab为空或者通过tabAt得到的node节点为空，直接跳出循环\n        if (tab == null || (n = tab.length) == 0 ||\n            (f = tabAt(tab, i = (n - 1) & hash)) == null)\n            break;\n        //如果链表头节点的hash值为-1，说明table可能正在进行扩容，调用helpTransfer方法帮助扩容\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            boolean validated = false;\n            synchronized (f) { // 对链表头节点加锁\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        validated = true;\n                        // 遍历链表查找key值\n                        for (Node<K,V> e = f, pred = null;;) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) { // 判断节点e的key是否相等\n                                V ev = e.val;\n                                if (cv == null || cv == ev ||\n                                    (ev != null && cv.equals(ev))) { // 如果给定的value为null，或者value与cv相等\n                                    oldVal = ev;\n                                    if (value != null) // 如果给定你的value不为null，替换节点e的value\n                                        e.val = value;\n                                    else if (pred != null) // 如果链表的前一个节点不为null，将节点e的下一个节点指向前一个节点的下一个节点。相当于删除当前节点\n                                        pred.next = e.next;\n                                    else\n                                        setTabAt(tab, i, e.next); // 前一个节点为null，说明是链表头节点，插入头节点，next指向原头节点的next\n                                }\n                                break;\n                            }\n                            pred = e;\n                            if ((e = e.next) == null) // 没有找到匹配的key，返回\n                                break;\n                        }\n                    }\n                    // 如果节点为树结构\n                    else if (f instanceof TreeBin) {\n                        validated = true;\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> r, p;\n                        // 调用findTreeNode方法根据key查找节点\n                        if ((r = t.root) != null &&\n                            (p = r.findTreeNode(hash, key, null)) != null) {\n                            V pv = p.val;\n                            if (cv == null || cv == pv ||\n                                (pv != null && cv.equals(pv))) {\n                                oldVal = pv;\n                                if (value != null)\n                                    p.val = value;\n                                //调用树节点removeTreeNode方法删除节点，返回true说明节点太少，转化为链表结构\n                                else if (t.removeTreeNode(p))\n                                    setTabAt(tab, i, untreeify(t.first));\n                            }\n                        }\n                    }\n                }\n            }\n            if (validated) {\n                if (oldVal != null) {\n                    if (value == null)\n                        addCount(-1L, -1);\n                    return oldVal;\n                }\n                break;\n            }\n        }\n    }\n    return null;\n}\n```\n\n# 总结\n\n* 在JDK8中使用了CAS方法保证操作的原子性\n* 与JDK7不同的是，在JDK8中，当链表长度到达一定值时，会自动转为红黑树存储。\n* 与JDK7不同的是，在JDK8中，ConcurrentHashMap不再使用segment结构，而是使用synchronized关键字对table中的链表头节点进行加锁，粒度更小，从而使同时操作的线程数量更多，效率更高。\n\n## 参考\n《Java并发编程实战》\n\n[https://juejin.im/post/5a7844556fb9a06351725263](https://juejin.im/post/5a7844556fb9a06351725263)","slug":"jdk8-source-ConcurrentHashMap","published":1,"updated":"2020-03-12T06:06:38.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8edhpk00041i3slgfbnajt6","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>ConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的安全，但是HashTable的同步机制颗粒度太粗（实现机制是将put、size等各种方法加上‘synchronized’，导致了所有并发操作需要竞争同一把锁），导致性能低下,现在已经很少被推荐使用。<br>在jdk8中，ConcurrentHashMap底层实现使用了数组+链表+红黑树的数据结构</p>\n<h1 id=\"常用变量\"><a href=\"#常用变量\" class=\"headerlink\" title=\"常用变量\"></a>常用变量</h1><h2 id=\"LOAD-FACTOR-加载因子\"><a href=\"#LOAD-FACTOR-加载因子\" class=\"headerlink\" title=\"LOAD_FACTOR 加载因子\"></a>LOAD_FACTOR 加载因子</h2><p>LOAD_FACTOR的默认大小是<code>0.75f</code>。为何是<code>0.75</code>    而不是其他的值呢？<br>首先理解一下，什么是加载因子。</p>\n<ul>\n<li>加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然</li>\n<li>冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。</li>\n<li>结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。</li>\n</ul>\n<h2 id=\"DEFAULT-CAPACITY-默认容量\"><a href=\"#DEFAULT-CAPACITY-默认容量\" class=\"headerlink\" title=\"DEFAULT_CAPACITY 默认容量\"></a>DEFAULT_CAPACITY 默认容量</h2><p>DEFAULT_CAPACITY的默认值为16，可以通过构造方法定义该值，但是需要注意的是，DEFAULT_CAPACITY的值是2的幂次方。结合前面的加载因子，可以得出，ConcurrentHashMap的初始化容量为:<code>0.75*16=12</code>,当size大于12的时候，就会发生扩容。</p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认初始化表大小（16）创建一个空的map</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个新的空map，初始化表大小容纳指定数量的元素，不需要动态调转大小。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class=\"number\">1</span>)) ?</span><br><span class=\"line\">               MAXIMUM_CAPACITY :</span><br><span class=\"line\">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sizeCtl = cap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该构造方法 就是设置 sizeCtl; 首先计算<code>initialCapacity + (initialCapacity &gt;&gt;&gt; 1</code> （可以简写为： <code>1.5*initialCapacity + 1</code>）, 再调用<code>tableSizeFor</code> 方法，该方法的作用是：对<code>1.5*initialCapacity + 1</code>向上取最近的2的n次方。比如：初始化大小为：10，计算结果为16。 初始化大小为：15，计算结果为32.</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"put-方法\"><a href=\"#put-方法\" class=\"headerlink\" title=\"put 方法\"></a>put 方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要是调用了 <code>putVal()</code>,接下来是实现具体实现方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// key 和 value 都不能为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">     <span class=\"comment\">// 计算 hash</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果数组为空，则初始化数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 初始化数组方法 后面单独介绍</span></span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过hash值找到数组对应的节点f</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// f节点为空，调用casTabAt方法</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//casTabAt 具体执行过程是，底层通过sun.misc.Unsafe 调用了compareAndSwapObject。该方法是无锁算法，将值插入数组中。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// MOVED : 转换节点的hash值</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 帮助数据迁移。并发情况下。</span></span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 头结点的 hash 值大于 0，说明是链表。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// 根据hash判断是否有相等的key， 如果有匹配成功，通过onlyIfAbsent 判断是否需要覆盖该key对应的值。然后break。</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// 到了这儿，说明没有匹配的key，如果该节点的下一个节点为空，说明已经到了链表的末端，将值给放在该链表的最末端即可，然后break。</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 判断是否为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 调用红黑树的put方法，根据onlyIfAbsent判断是否覆盖该值。</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果 binCount不等于0，则在进行链表操作。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TREEIFY_THRESHOLD 默认为8</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果binCount的值大于等于8，则调用treeifyBin方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 后面单独介绍该方法</span></span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>put方法的主要流程就是这样，接下来看看，put流程中遗留的几个问题。</p>\n<h2 id=\"初始化数组-initTable\"><a href=\"#初始化数组-initTable\" class=\"headerlink\" title=\"初始化数组 initTable\"></a>初始化数组 initTable</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class=\"line\"><span class=\"comment\">* 使用sizeCtl中记录的大小初始化表。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化‘线程’竞争失败。等待。</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">              Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">\t<span class=\"comment\">// 利用CAS操作， 并设置sizeCtl的值。</span></span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 三目运算，DEFAULT_CAPACITY默认为16</span></span><br><span class=\"line\">                      <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                      <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                      Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                      table = tab = nt;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果n的值为16，则sc计算结果为12</span></span><br><span class=\"line\">                      sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 设置sizeCtl值</span></span><br><span class=\"line\">                  sizeCtl = sc;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"链表转红黑树-treeifyBin\"><a href=\"#链表转红黑树-treeifyBin\" class=\"headerlink\" title=\"链表转红黑树 treeifyBin\"></a>链表转红黑树 treeifyBin</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">     Node&lt;K,V&gt; b; <span class=\"keyword\">int</span> n, sc;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (tab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 如果数组的长度小于 MIN_TREEIFY_CAPACITY（64），对数组进行扩容</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">\t<span class=\"comment\">// n值翻倍之后传入</span></span><br><span class=\"line\">             tryPresize(n &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((b = tabAt(tab, index)) != <span class=\"keyword\">null</span> &amp;&amp; b.hash &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">synchronized</span> (b) &#123; <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class=\"line\">                     TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历链表，建立红黑树。</span></span><br><span class=\"line\">                     <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = b; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                         TreeNode&lt;K,V&gt; p =</span><br><span class=\"line\">                             <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class=\"line\">                                               <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                         <span class=\"keyword\">if</span> ((p.prev = tl) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                             hd = p;</span><br><span class=\"line\">                         <span class=\"keyword\">else</span></span><br><span class=\"line\">                             tl.next = p;</span><br><span class=\"line\">                         tl = p;</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将红黑树设置到数组的相应位置</span></span><br><span class=\"line\">                     setTabAt(tab, index, <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>链表转红黑树方法，在开始的时候回校验数组的长度，如果小于64，会进行扩容，反之，进行转红黑树过程。</p>\n<h2 id=\"扩容-tryPresize\"><a href=\"#扩容-tryPresize\" class=\"headerlink\" title=\"扩容 tryPresize\"></a>扩容 tryPresize</h2><p>将ConcurrentHashMap的容量扩展为原来的两倍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryPresize</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// size 在传递过来的时候，已经翻倍了。 如果size大于等于 最大容量的二分之一，c的值就是默认最大容量</span></span><br><span class=\"line\">\t<span class=\"comment\">// 反之，调用tableSizeFor方法，该方法就是对(size*1.5+1),在向上取2的n次方。</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class=\"number\">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class=\"line\">\ttableSizeFor(size + (size &gt;&gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((sc = sizeCtl) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt;[] tab = table; <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tn = (sc &gt; c) ? sc : c;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (table == tab) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t\t\t\t\t\tNode&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">\t\t\t\t\t\ttable = nt;</span><br><span class=\"line\">\t\t\t\t\t\tsc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tsizeCtl = sc;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tab == table) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> rs = resizeStamp(n);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sc &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tNode&lt;K,V&gt;[] nt;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class=\"number\">1</span> ||</span><br><span class=\"line\">\t\t\t\t\tsc == rs + MAX_RESIZERS || (nt = nextTable) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">\t\t\t\t\ttransferIndex &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, sc + <span class=\"number\">1</span>))</span><br><span class=\"line\">\t\t\t\t\ttransfer(tab, nt);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class=\"number\">2</span>))</span><br><span class=\"line\">\t\t\t\ttransfer(tab, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"get-Object-kye-取值\"><a href=\"#get-Object-kye-取值\" class=\"headerlink\" title=\"get(Object kye) 取值\"></a>get(Object kye) 取值</h2><p>接下来看看获取value的方法，get(key)规定了key不能为null，如果为null，则会抛出NPE。实现过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class=\"keyword\">int</span> n, eh; K ek;</span><br><span class=\"line\">    <span class=\"comment\">// 类似与HashMap中的hash方法</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"comment\">// table为当前对象中存储所有元素的数组，不能为空</span></span><br><span class=\"line\">    <span class=\"comment\">// tabAt是根据hash值，从table中找到hash为h的这个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (e = tabAt(tab, (n - <span class=\"number\">1</span>) &amp; h)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断元素的hash是否相等，接着判断key是否相等，如相等直接返回value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eh = e.hash) == h) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eh &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p = e.find(h, key)) != <span class=\"keyword\">null</span> ? p.val : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，直到找到对应的值为止。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get方法比较简单，没有加锁，只需要根据key直接取值就可以。类似<code>containsKey(Object key)</code>方法，其实就是调用了<code>get</code>方法，在判断get的返回值是否为空而已。</p>\n<h2 id=\"remove-Object-key-删除\"><a href=\"#remove-Object-key-删除\" class=\"headerlink\" title=\"remove(Object key) 删除\"></a>remove(Object key) 删除</h2><p>remove方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> replaceNode(key, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体实现在<code>replaceNode</code>方法中，接来下是该方法的具体实现。<code>replaceNode</code>是对<code>remove/replace</code>公共方法的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">replaceNode</span><span class=\"params\">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据key的hashCode计算出hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"comment\">// 循环table</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">// 如果tab为空或者通过tabAt得到的node节点为空，直接跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果链表头节点的hash值为-1，说明table可能正在进行扩容，调用helpTransfer方法帮助扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> validated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123; <span class=\"comment\">// 对链表头节点加锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        validated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"comment\">// 遍历链表查找key值</span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f, pred = <span class=\"keyword\">null</span>;;) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123; <span class=\"comment\">// 判断节点e的key是否相等</span></span><br><span class=\"line\">                                V ev = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (cv == <span class=\"keyword\">null</span> || cv == ev ||</span><br><span class=\"line\">                                    (ev != <span class=\"keyword\">null</span> &amp;&amp; cv.equals(ev))) &#123; <span class=\"comment\">// 如果给定的value为null，或者value与cv相等</span></span><br><span class=\"line\">                                    oldVal = ev;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果给定你的value不为null，替换节点e的value</span></span><br><span class=\"line\">                                        e.val = value;</span><br><span class=\"line\">                                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果链表的前一个节点不为null，将节点e的下一个节点指向前一个节点的下一个节点。相当于删除当前节点</span></span><br><span class=\"line\">                                        pred.next = e.next;</span><br><span class=\"line\">                                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                                        setTabAt(tab, i, e.next); <span class=\"comment\">// 前一个节点为null，说明是链表头节点，插入头节点，next指向原头节点的next</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) <span class=\"comment\">// 没有找到匹配的key，返回</span></span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果节点为树结构</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        validated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class=\"line\">                        <span class=\"comment\">// 调用findTreeNode方法根据key查找节点</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((r = t.root) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                            (p = r.findTreeNode(hash, key, <span class=\"keyword\">null</span>)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            V pv = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (cv == <span class=\"keyword\">null</span> || cv == pv ||</span><br><span class=\"line\">                                (pv != <span class=\"keyword\">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class=\"line\">                                oldVal = pv;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    p.val = value;</span><br><span class=\"line\">                                <span class=\"comment\">//调用树节点removeTreeNode方法删除节点，返回true说明节点太少，转化为链表结构</span></span><br><span class=\"line\">                                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t.removeTreeNode(p))</span><br><span class=\"line\">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (validated) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        addCount(-<span class=\"number\">1L</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>在JDK8中使用了CAS方法保证操作的原子性</li>\n<li>与JDK7不同的是，在JDK8中，当链表长度到达一定值时，会自动转为红黑树存储。</li>\n<li>与JDK7不同的是，在JDK8中，ConcurrentHashMap不再使用segment结构，而是使用synchronized关键字对table中的链表头节点进行加锁，粒度更小，从而使同时操作的线程数量更多，效率更高。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Java并发编程实战》</p>\n<p><a href=\"https://juejin.im/post/5a7844556fb9a06351725263\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a7844556fb9a06351725263</a></p>\n","site":{"data":{"variables":""}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>ConcurrentHashMap 是一个线程安全类，是为了解决HashMap的线程不安全衍生出的一个类。虽然说HashTable也是线程的安全，但是HashTable的同步机制颗粒度太粗（实现机制是将put、size等各种方法加上‘synchronized’，导致了所有并发操作需要竞争同一把锁），导致性能低下,现在已经很少被推荐使用。<br>在jdk8中，ConcurrentHashMap底层实现使用了数组+链表+红黑树的数据结构</p>\n<h1 id=\"常用变量\"><a href=\"#常用变量\" class=\"headerlink\" title=\"常用变量\"></a>常用变量</h1><h2 id=\"LOAD-FACTOR-加载因子\"><a href=\"#LOAD-FACTOR-加载因子\" class=\"headerlink\" title=\"LOAD_FACTOR 加载因子\"></a>LOAD_FACTOR 加载因子</h2><p>LOAD_FACTOR的默认大小是<code>0.75f</code>。为何是<code>0.75</code>    而不是其他的值呢？<br>首先理解一下，什么是加载因子。</p>\n<ul>\n<li>加载因子是表示Hsah表中元素的填满的程度。如果加载因子越大,填满的元素越多，所以空间利用率提高，但是冲突的机会加大了。反之亦然</li>\n<li>冲突的机会越大，查找所需要的成本增加，查找时间也相应的增加 了。反之亦然。</li>\n<li>结合前面两条，我们必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。这种平衡与折衷本质上是数据结构中有名的”时间复杂度-空间复杂度”矛盾的平衡与折衷。</li>\n</ul>\n<h2 id=\"DEFAULT-CAPACITY-默认容量\"><a href=\"#DEFAULT-CAPACITY-默认容量\" class=\"headerlink\" title=\"DEFAULT_CAPACITY 默认容量\"></a>DEFAULT_CAPACITY 默认容量</h2><p>DEFAULT_CAPACITY的默认值为16，可以通过构造方法定义该值，但是需要注意的是，DEFAULT_CAPACITY的值是2的幂次方。结合前面的加载因子，可以得出，ConcurrentHashMap的初始化容量为:<code>0.75*16=12</code>,当size大于12的时候，就会发生扩容。</p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认初始化表大小（16）创建一个空的map</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个新的空map，初始化表大小容纳指定数量的元素，不需要动态调转大小。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class=\"number\">1</span>)) ?</span><br><span class=\"line\">               MAXIMUM_CAPACITY :</span><br><span class=\"line\">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sizeCtl = cap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该构造方法 就是设置 sizeCtl; 首先计算<code>initialCapacity + (initialCapacity &gt;&gt;&gt; 1</code> （可以简写为： <code>1.5*initialCapacity + 1</code>）, 再调用<code>tableSizeFor</code> 方法，该方法的作用是：对<code>1.5*initialCapacity + 1</code>向上取最近的2的n次方。比如：初始化大小为：10，计算结果为16。 初始化大小为：15，计算结果为32.</p>\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"put-方法\"><a href=\"#put-方法\" class=\"headerlink\" title=\"put 方法\"></a>put 方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法主要是调用了 <code>putVal()</code>,接下来是实现具体实现方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// key 和 value 都不能为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">     <span class=\"comment\">// 计算 hash</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果数组为空，则初始化数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 初始化数组方法 后面单独介绍</span></span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通过hash值找到数组对应的节点f</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// f节点为空，调用casTabAt方法</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//casTabAt 具体执行过程是，底层通过sun.misc.Unsafe 调用了compareAndSwapObject。该方法是无锁算法，将值插入数组中。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// MOVED : 转换节点的hash值</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 帮助数据迁移。并发情况下。</span></span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 头结点的 hash 值大于 0，说明是链表。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// 根据hash判断是否有相等的key， 如果有匹配成功，通过onlyIfAbsent 判断是否需要覆盖该key对应的值。然后break。</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">// 到了这儿，说明没有匹配的key，如果该节点的下一个节点为空，说明已经到了链表的末端，将值给放在该链表的最末端即可，然后break。</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 判断是否为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 调用红黑树的put方法，根据onlyIfAbsent判断是否覆盖该值。</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果 binCount不等于0，则在进行链表操作。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// TREEIFY_THRESHOLD 默认为8</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果binCount的值大于等于8，则调用treeifyBin方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 后面单独介绍该方法</span></span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>put方法的主要流程就是这样，接下来看看，put流程中遗留的几个问题。</p>\n<h2 id=\"初始化数组-initTable\"><a href=\"#初始化数组-initTable\" class=\"headerlink\" title=\"初始化数组 initTable\"></a>初始化数组 initTable</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class=\"line\"><span class=\"comment\">* 使用sizeCtl中记录的大小初始化表。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">      Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化‘线程’竞争失败。等待。</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">              Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">\t<span class=\"comment\">// 利用CAS操作， 并设置sizeCtl的值。</span></span><br><span class=\"line\">          <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 三目运算，DEFAULT_CAPACITY默认为16</span></span><br><span class=\"line\">                      <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                      <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                      Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                      table = tab = nt;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果n的值为16，则sc计算结果为12</span></span><br><span class=\"line\">                      sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 设置sizeCtl值</span></span><br><span class=\"line\">                  sizeCtl = sc;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"链表转红黑树-treeifyBin\"><a href=\"#链表转红黑树-treeifyBin\" class=\"headerlink\" title=\"链表转红黑树 treeifyBin\"></a>链表转红黑树 treeifyBin</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">     Node&lt;K,V&gt; b; <span class=\"keyword\">int</span> n, sc;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (tab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 如果数组的长度小于 MIN_TREEIFY_CAPACITY（64），对数组进行扩容</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">\t<span class=\"comment\">// n值翻倍之后传入</span></span><br><span class=\"line\">             tryPresize(n &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\">         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((b = tabAt(tab, index)) != <span class=\"keyword\">null</span> &amp;&amp; b.hash &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">synchronized</span> (b) &#123; <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class=\"line\">                     TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历链表，建立红黑树。</span></span><br><span class=\"line\">                     <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = b; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">                         TreeNode&lt;K,V&gt; p =</span><br><span class=\"line\">                             <span class=\"keyword\">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class=\"line\">                                               <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                         <span class=\"keyword\">if</span> ((p.prev = tl) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                             hd = p;</span><br><span class=\"line\">                         <span class=\"keyword\">else</span></span><br><span class=\"line\">                             tl.next = p;</span><br><span class=\"line\">                         tl = p;</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将红黑树设置到数组的相应位置</span></span><br><span class=\"line\">                     setTabAt(tab, index, <span class=\"keyword\">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>链表转红黑树方法，在开始的时候回校验数组的长度，如果小于64，会进行扩容，反之，进行转红黑树过程。</p>\n<h2 id=\"扩容-tryPresize\"><a href=\"#扩容-tryPresize\" class=\"headerlink\" title=\"扩容 tryPresize\"></a>扩容 tryPresize</h2><p>将ConcurrentHashMap的容量扩展为原来的两倍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryPresize</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// size 在传递过来的时候，已经翻倍了。 如果size大于等于 最大容量的二分之一，c的值就是默认最大容量</span></span><br><span class=\"line\">\t<span class=\"comment\">// 反之，调用tableSizeFor方法，该方法就是对(size*1.5+1),在向上取2的n次方。</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class=\"number\">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class=\"line\">\ttableSizeFor(size + (size &gt;&gt;&gt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((sc = sizeCtl) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt;[] tab = table; <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tn = (sc &gt; c) ? sc : c;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (table == tab) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">\t\t\t\t\t\tNode&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">\t\t\t\t\t\ttable = nt;</span><br><span class=\"line\">\t\t\t\t\t\tsc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tsizeCtl = sc;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tab == table) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> rs = resizeStamp(n);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sc &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tNode&lt;K,V&gt;[] nt;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class=\"number\">1</span> ||</span><br><span class=\"line\">\t\t\t\t\tsc == rs + MAX_RESIZERS || (nt = nextTable) == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">\t\t\t\t\ttransferIndex &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, sc + <span class=\"number\">1</span>))</span><br><span class=\"line\">\t\t\t\t\ttransfer(tab, nt);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class=\"number\">2</span>))</span><br><span class=\"line\">\t\t\t\ttransfer(tab, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"get-Object-kye-取值\"><a href=\"#get-Object-kye-取值\" class=\"headerlink\" title=\"get(Object kye) 取值\"></a>get(Object kye) 取值</h2><p>接下来看看获取value的方法，get(key)规定了key不能为null，如果为null，则会抛出NPE。实现过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class=\"keyword\">int</span> n, eh; K ek;</span><br><span class=\"line\">    <span class=\"comment\">// 类似与HashMap中的hash方法</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"comment\">// table为当前对象中存储所有元素的数组，不能为空</span></span><br><span class=\"line\">    <span class=\"comment\">// tabAt是根据hash值，从table中找到hash为h的这个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (e = tabAt(tab, (n - <span class=\"number\">1</span>) &amp; h)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断元素的hash是否相等，接着判断key是否相等，如相等直接返回value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eh = e.hash) == h) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eh &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p = e.find(h, key)) != <span class=\"keyword\">null</span> ? p.val : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，直到找到对应的值为止。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>get方法比较简单，没有加锁，只需要根据key直接取值就可以。类似<code>containsKey(Object key)</code>方法，其实就是调用了<code>get</code>方法，在判断get的返回值是否为空而已。</p>\n<h2 id=\"remove-Object-key-删除\"><a href=\"#remove-Object-key-删除\" class=\"headerlink\" title=\"remove(Object key) 删除\"></a>remove(Object key) 删除</h2><p>remove方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> replaceNode(key, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体实现在<code>replaceNode</code>方法中，接来下是该方法的具体实现。<code>replaceNode</code>是对<code>remove/replace</code>公共方法的实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">replaceNode</span><span class=\"params\">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据key的hashCode计算出hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"comment\">// 循环table</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">// 如果tab为空或者通过tabAt得到的node节点为空，直接跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果链表头节点的hash值为-1，说明table可能正在进行扩容，调用helpTransfer方法帮助扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> validated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123; <span class=\"comment\">// 对链表头节点加锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        validated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"comment\">// 遍历链表查找key值</span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f, pred = <span class=\"keyword\">null</span>;;) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123; <span class=\"comment\">// 判断节点e的key是否相等</span></span><br><span class=\"line\">                                V ev = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (cv == <span class=\"keyword\">null</span> || cv == ev ||</span><br><span class=\"line\">                                    (ev != <span class=\"keyword\">null</span> &amp;&amp; cv.equals(ev))) &#123; <span class=\"comment\">// 如果给定的value为null，或者value与cv相等</span></span><br><span class=\"line\">                                    oldVal = ev;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果给定你的value不为null，替换节点e的value</span></span><br><span class=\"line\">                                        e.val = value;</span><br><span class=\"line\">                                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) <span class=\"comment\">// 如果链表的前一个节点不为null，将节点e的下一个节点指向前一个节点的下一个节点。相当于删除当前节点</span></span><br><span class=\"line\">                                        pred.next = e.next;</span><br><span class=\"line\">                                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                                        setTabAt(tab, i, e.next); <span class=\"comment\">// 前一个节点为null，说明是链表头节点，插入头节点，next指向原头节点的next</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) <span class=\"comment\">// 没有找到匹配的key，返回</span></span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果节点为树结构</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        validated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class=\"line\">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class=\"line\">                        <span class=\"comment\">// 调用findTreeNode方法根据key查找节点</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((r = t.root) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                            (p = r.findTreeNode(hash, key, <span class=\"keyword\">null</span>)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            V pv = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (cv == <span class=\"keyword\">null</span> || cv == pv ||</span><br><span class=\"line\">                                (pv != <span class=\"keyword\">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class=\"line\">                                oldVal = pv;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    p.val = value;</span><br><span class=\"line\">                                <span class=\"comment\">//调用树节点removeTreeNode方法删除节点，返回true说明节点太少，转化为链表结构</span></span><br><span class=\"line\">                                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t.removeTreeNode(p))</span><br><span class=\"line\">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (validated) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        addCount(-<span class=\"number\">1L</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>在JDK8中使用了CAS方法保证操作的原子性</li>\n<li>与JDK7不同的是，在JDK8中，当链表长度到达一定值时，会自动转为红黑树存储。</li>\n<li>与JDK7不同的是，在JDK8中，ConcurrentHashMap不再使用segment结构，而是使用synchronized关键字对table中的链表头节点进行加锁，粒度更小，从而使同时操作的线程数量更多，效率更高。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Java并发编程实战》</p>\n<p><a href=\"https://juejin.im/post/5a7844556fb9a06351725263\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a7844556fb9a06351725263</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8edhpgu0003i3slkqavgx1i","category_id":"ck8edhph10007i3slr2he1rds","_id":"ck8edhph8000hi3slg2k9hv3h"},{"post_id":"ck8edhpgy0005i3sltdt9iixm","category_id":"ck8edhph6000ci3slkleqexlu","_id":"ck8edhphb000mi3slubzja8sb"},{"post_id":"ck8edhph30009i3sl59i2pol6","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphc000ti3slayt2ktkn"},{"post_id":"ck8edhph3000ai3slfzpawuwl","category_id":"ck8edhphb000ni3slkt7pgeg4","_id":"ck8edhphe000zi3slerp0bs3n"},{"post_id":"ck8edhphd000wi3slor284can","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphg0015i3sl9og4okex"},{"post_id":"ck8edhphd000xi3sl8ypy2cr5","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphh0017i3slbfaktmcz"},{"post_id":"ck8edhph5000bi3slyd9wwyuq","category_id":"ck8edhphc000ui3slzvd674s3","_id":"ck8edhphk001ci3sl9u5dnzdr"},{"post_id":"ck8edhphe0010i3slec8ob3cq","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphl001fi3slah976bs3"},{"post_id":"ck8edhphf0014i3sl26ila16k","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphm001ki3sl6j70vs2m"},{"post_id":"ck8edhph7000fi3sl8qaoy606","category_id":"ck8edhphf0011i3sltinpr4yu","_id":"ck8edhphn001ni3slcjlj2egr"},{"post_id":"ck8edhphg0016i3slaa7baqnq","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphp001si3sllx0rekc6"},{"post_id":"ck8edhph8000gi3sl9zr5do7m","category_id":"ck8edhphf0011i3sltinpr4yu","_id":"ck8edhphq001vi3sluvrfuur9"},{"post_id":"ck8edhphk001ei3sltgcdf1h3","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphr0020i3slbmqh18rd"},{"post_id":"ck8edhph9000ki3slwwf6uhul","category_id":"ck8edhphl001gi3slgkzb5pua","_id":"ck8edhphs0023i3sl6drq9mhb"},{"post_id":"ck8edhphp001ri3slk9wp9gv7","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhpht0027i3slkqkwh6aa"},{"post_id":"ck8edhpha000li3slom1zp6ns","category_id":"ck8edhphf0011i3sltinpr4yu","_id":"ck8edhphu0029i3slk68b7gyu"},{"post_id":"ck8edhphq001ui3slh9bv727q","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhphu002bi3sl17qnowmq"},{"post_id":"ck8edhphb000pi3slpxat4scv","category_id":"ck8edhphr001wi3slpj43ny17","_id":"ck8edhphu002ei3slk5d24k17"},{"post_id":"ck8edhphs0022i3slhbrx7fih","category_id":"ck8edhphb000ni3slkt7pgeg4","_id":"ck8edhphu002gi3slho2mrphc"},{"post_id":"ck8edhphc000ri3sl50qkwso6","category_id":"ck8edhpht0025i3slyhdtrh5p","_id":"ck8edhphv002ji3slgmwcm2aj"},{"post_id":"ck8edhphj001bi3slqxda1c6i","category_id":"ck8edhphu002ci3sl8729hfci","_id":"ck8edhphv002mi3slnf6qhy9c"},{"post_id":"ck8edhphm001ji3slql7u5yjf","category_id":"ck8edhphr001wi3slpj43ny17","_id":"ck8edhphw002oi3slr0i17ott"},{"post_id":"ck8edhphn001mi3slywkjtrc6","category_id":"ck8edhphv002li3sleq2wqv2c","_id":"ck8edhphx002ti3slws79klp4"},{"post_id":"ck8edhphr001zi3sl3z7nrr0q","category_id":"ck8edhphw002pi3sll526wzb8","_id":"ck8edhphy002xi3sl95xij82e"},{"post_id":"ck8edhpiz003li3sl0z508i7b","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhpj6003si3slh7wtbikx"},{"post_id":"ck8edhpj1003ni3slhjkfed4b","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhpj7003ui3slp5sadnbn"},{"post_id":"ck8edhpj4003pi3slwyfm9k6u","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhpj7003wi3slodong0au"},{"post_id":"ck8edhpj5003ri3slp5lbl7kn","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhpj7003yi3sl3m30woby"},{"post_id":"ck8edhpk00041i3slgfbnajt6","category_id":"ck8edhph9000ii3slpkslzyzu","_id":"ck8edhpk20044i3slfvhu14nr"}],"PostTag":[{"post_id":"ck8edhpgu0003i3slkqavgx1i","tag_id":"ck8edhph20008i3sldsu4bsba","_id":"ck8edhph6000ei3sl299ezo0s"},{"post_id":"ck8edhpgy0005i3sltdt9iixm","tag_id":"ck8edhph6000di3sluj81biww","_id":"ck8edhphc000qi3slfwnjzzd7"},{"post_id":"ck8edhpgy0005i3sltdt9iixm","tag_id":"ck8edhph9000ji3slvb96a50y","_id":"ck8edhphc000si3slmsb6zmpq"},{"post_id":"ck8edhphd000wi3slor284can","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphe000yi3sld73gmcxi"},{"post_id":"ck8edhphd000xi3sl8ypy2cr5","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphf0013i3slkc8u48sd"},{"post_id":"ck8edhphf0014i3sl26ila16k","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphj001ai3slgpwa8eni"},{"post_id":"ck8edhph30009i3sl59i2pol6","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphk001di3sl3ko4wq3q"},{"post_id":"ck8edhph30009i3sl59i2pol6","tag_id":"ck8edhphc000vi3sl50bnyf67","_id":"ck8edhphm001ii3sl1vt0hgxu"},{"post_id":"ck8edhph30009i3sl59i2pol6","tag_id":"ck8edhphf0012i3sl6awtxdxr","_id":"ck8edhphm001li3slc9f81kk3"},{"post_id":"ck8edhphg0016i3slaa7baqnq","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpho001qi3slkamekidb"},{"post_id":"ck8edhph3000ai3slfzpawuwl","tag_id":"ck8edhph6000di3sluj81biww","_id":"ck8edhphq001ti3slrj2qmzfn"},{"post_id":"ck8edhph3000ai3slfzpawuwl","tag_id":"ck8edhphl001hi3slp98i32l6","_id":"ck8edhphr001yi3sljh38io3y"},{"post_id":"ck8edhph5000bi3slyd9wwyuq","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphs0021i3slqqh68x8m"},{"post_id":"ck8edhphr001zi3sl3z7nrr0q","tag_id":"ck8edhphf0012i3sl6awtxdxr","_id":"ck8edhpht0024i3slcpgzjula"},{"post_id":"ck8edhph7000fi3sl8qaoy606","tag_id":"ck8edhphr001xi3slxeyv9ahb","_id":"ck8edhpht0028i3slxtegbhux"},{"post_id":"ck8edhph8000gi3sl9zr5do7m","tag_id":"ck8edhphr001xi3slxeyv9ahb","_id":"ck8edhphu002di3slwj5o8fp9"},{"post_id":"ck8edhph9000ki3slwwf6uhul","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphv002ii3slem2q3o4i"},{"post_id":"ck8edhpha000li3slom1zp6ns","tag_id":"ck8edhphu002fi3slsp4dnqtu","_id":"ck8edhphw002qi3slvcz2nein"},{"post_id":"ck8edhpha000li3slom1zp6ns","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphx002ri3slk5ct82bm"},{"post_id":"ck8edhphb000pi3slpxat4scv","tag_id":"ck8edhph6000di3sluj81biww","_id":"ck8edhphx002ui3slxfsc2pyv"},{"post_id":"ck8edhphb000pi3slpxat4scv","tag_id":"ck8edhphw002ni3sl0t7wqxyg","_id":"ck8edhphx002vi3sl52g6gxnc"},{"post_id":"ck8edhphc000ri3sl50qkwso6","tag_id":"ck8edhphx002si3slc1jczrix","_id":"ck8edhphy002yi3slhkmih6t7"},{"post_id":"ck8edhphe0010i3slec8ob3cq","tag_id":"ck8edhphx002wi3slm7vql7lz","_id":"ck8edhphy0030i3slr5yefl5f"},{"post_id":"ck8edhphj001bi3slqxda1c6i","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphz0032i3sl00gf8ipk"},{"post_id":"ck8edhphj001bi3slqxda1c6i","tag_id":"ck8edhphy002zi3sleptxdryb","_id":"ck8edhphz0033i3slq2arzjad"},{"post_id":"ck8edhphk001ei3sltgcdf1h3","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhphz0035i3slg99tvbfu"},{"post_id":"ck8edhphk001ei3sltgcdf1h3","tag_id":"ck8edhphy002zi3sleptxdryb","_id":"ck8edhphz0036i3sldwypiple"},{"post_id":"ck8edhphm001ji3slql7u5yjf","tag_id":"ck8edhph6000di3sluj81biww","_id":"ck8edhphz0038i3slw57dijl0"},{"post_id":"ck8edhphm001ji3slql7u5yjf","tag_id":"ck8edhphz0034i3slc37xuhzc","_id":"ck8edhphz0039i3sl46r8eqdl"},{"post_id":"ck8edhphn001mi3slywkjtrc6","tag_id":"ck8edhphz0037i3slx1f1ksrj","_id":"ck8edhpi0003bi3sldxtlh6bf"},{"post_id":"ck8edhphn001mi3slywkjtrc6","tag_id":"ck8edhph9000ji3slvb96a50y","_id":"ck8edhpi0003ci3sl8coomocn"},{"post_id":"ck8edhphp001ri3slk9wp9gv7","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpi0003ei3slmcva2zib"},{"post_id":"ck8edhphp001ri3slk9wp9gv7","tag_id":"ck8edhphz003ai3slytyf8t0n","_id":"ck8edhpi1003fi3slhlj9sp9k"},{"post_id":"ck8edhphp001ri3slk9wp9gv7","tag_id":"ck8edhphf0012i3sl6awtxdxr","_id":"ck8edhpi1003hi3slao5esrsg"},{"post_id":"ck8edhphq001ui3slh9bv727q","tag_id":"ck8edhphz003ai3slytyf8t0n","_id":"ck8edhpi1003ii3slc41pfi6d"},{"post_id":"ck8edhphq001ui3slh9bv727q","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpi1003ji3sl109eqdfv"},{"post_id":"ck8edhphs0022i3slhbrx7fih","tag_id":"ck8edhpi1003gi3slmjhqbxeh","_id":"ck8edhpi1003ki3slcgv1nzw8"},{"post_id":"ck8edhpiz003li3sl0z508i7b","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpj4003oi3slqj6dk02r"},{"post_id":"ck8edhpj1003ni3slhjkfed4b","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpj5003qi3sl1uewknt9"},{"post_id":"ck8edhpj1003ni3slhjkfed4b","tag_id":"ck8edhphy002zi3sleptxdryb","_id":"ck8edhpj6003ti3sl1kwfssyw"},{"post_id":"ck8edhpj4003pi3slwyfm9k6u","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpj7003vi3sli1l7upoj"},{"post_id":"ck8edhpj4003pi3slwyfm9k6u","tag_id":"ck8edhphy002zi3sleptxdryb","_id":"ck8edhpj7003xi3sls6gtr7ww"},{"post_id":"ck8edhpj5003ri3slp5lbl7kn","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpj8003zi3slgqyzecsi"},{"post_id":"ck8edhpj5003ri3slp5lbl7kn","tag_id":"ck8edhphy002zi3sleptxdryb","_id":"ck8edhpj80040i3sl0qa97bjt"},{"post_id":"ck8edhpk00041i3slgfbnajt6","tag_id":"ck8edhphb000oi3slsbca8hqb","_id":"ck8edhpk20042i3sl4s1zrer4"},{"post_id":"ck8edhpk00041i3slgfbnajt6","tag_id":"ck8edhphy002zi3sleptxdryb","_id":"ck8edhpk20043i3sl92pj6y9q"}],"Tag":[{"name":"MyBatis","_id":"ck8edhph20008i3sldsu4bsba"},{"name":"mac","_id":"ck8edhph6000di3sluj81biww"},{"name":"mysql","_id":"ck8edhph9000ji3slvb96a50y"},{"name":"java","_id":"ck8edhphb000oi3slsbca8hqb"},{"name":"mail","_id":"ck8edhphc000vi3sl50bnyf67"},{"name":"springboot","_id":"ck8edhphf0012i3sl6awtxdxr"},{"name":"nodejs","_id":"ck8edhphl001hi3slp98i32l6"},{"name":"-剑指offer","_id":"ck8edhphr001xi3slxeyv9ahb"},{"name":"coderbyte","_id":"ck8edhphu002fi3slsp4dnqtu"},{"name":"fish","_id":"ck8edhphw002ni3sl0t7wqxyg"},{"name":"hexo","_id":"ck8edhphx002si3slc1jczrix"},{"name":"算法","_id":"ck8edhphx002wi3slm7vql7lz"},{"name":"源码","_id":"ck8edhphy002zi3sleptxdryb"},{"name":"nginx","_id":"ck8edhphz0034i3slc37xuhzc"},{"name":"python","_id":"ck8edhphz0037i3slx1f1ksrj"},{"name":"spring","_id":"ck8edhphz003ai3slytyf8t0n"},{"name":"ajax","_id":"ck8edhpi1003gi3slmjhqbxeh"}]}}